Жмакин А. П.
Ж77 Архитектура ЭВМ: 2-е изд., перераб. и доп.: учеб. пособие. — СПб.: БХВ-
Петербург, 2010. — 352 с.: ил. + CD-ROM — (Учебная литература для вузов)
ISBN 978-5-9775-0550-5
Пособие объединяет в одном издании теоретическую часть одноименной дисцип-
лины и лабораторный практикум. Рассмотрены базовые вопросы организации ЭВМ:
функциональная организация ЭВМ, системы команд и командный цикл. Большое вни-
мание уделено арифметическим основам ЭВМ, принципам построения различных уст-
ройств и их взаимодействию. Обсуждаются вопросы построения микропроцессорных
систем. Во втором издании лабораторный практикум дополнен программными моде-
лями арифметико-логического устройства, представленными, наряду с программной
моделью ЭВМ, на прилагаемом компакт-диске. Кроме того, пособие содержит мате-
риалы для выполнения курсового проектирования.
Для студентов и преподавателей технических вузов
УДК 681.3(075.8)
ББК 32.973-02я73
Группа подготовки издания:
Главный редактор Екатерина Кондукова
Зам. главного редактора Евгений Рыбаков
Зав. редакцией Григорий Добин
Редактор Анна Кузьмина
Компьютерная верстка Натальи Караваевой
Корректор Виктория Пиотровская
Дизайн серии Инны Тачиной
Оформление обложки Елены Беляевой
Фото Кирилла Сергеева
Зав. производством Николай Тверских
Лицензия ИД № 02429 от 24.07.00. Подписано в печать 03.03.10.
Формат 70×1001/16. Печать офсетная. Усл. печ. л. 28,38.
Тираж 1500 экз. Заказ №
"БХВ-Петербург", 190005, Санкт-Петербург, Измайловский пр., 29.
Санитарно-эпидемиологическое заключение на продукцию
№ 77.99.60.953.Д.005770.05.09 от 26.05.2009 г. выдано Федеральной службой
по надзору в сфере защиты прав потребителей и благополучия человека.
Отпечатано с готовых диапозитивов
в ГУП "Типография "Наука"
199034, Санкт-Петербург, 9 линия, 12
ISBN 978-5-9775-0550-5 © Жмакин А. П., 2010
© Оформление, издательство "БХВ-Петербург", 2010
Îãëàâëåíèå
Предисловие ........................................................................................................................ 1
ЧАСТЬ I. ПРИНЦИПЫ ОРГАНИЗАЦИИ ЭВМ.......................................................... 3
Глава 1. Начальные сведения об ЭВМ .......................................................................... 5
1.1. История развития вычислительной техники ............................................................... 5
1.2. Цифровые и аналоговые вычислительные машины................................................... 7
1.3. Варианты классификации ЭВМ ................................................................................... 8
1.4. Классическая архитектура ЭВМ ................................................................................ 12
1.5. Иерархическое описание ЭВМ .................................................................................. 13
Глава 2. Функциональная организация ЭВМ ............................................................ 16
2.1. Командный цикл процессора ..................................................................................... 16
2.2. Система команд процессора....................................................................................... 18
2.2.1. Форматы команд .................................................................................................. 18
2.2.2. Способы адресации .............................................................................................. 20
2.2.3. Система операций ................................................................................................ 21
Глава 3. Арифметические основы ЭВМ ...................................................................... 23
3.1. Системы счисления ..................................................................................................... 24
3.2. Представление чисел в различных системах счисления .......................................... 27
3.2.1. Перевод целых чисел из одной системы счисления в другую ......................... 27
Преобразование Zp → Z1 → Zq ................................................................................... 27
Преобразование Zp → Zw→ Zq .................................................................................. 28
3.2.2. Перевод дробных чисел из одной системы счисления в другую ..................... 31
3.2.3. Перевод чисел между системами счисления 2 ↔ 8 ↔ 16 ................................ 34
3.2.4. Понятие экономичности системы счисления .................................................... 36
3.3. Представление информации в ЭВМ. Прямой код .................................................... 38
3.4. Алгебраическое сложение/вычитание в прямом коде ............................................. 39
3.5. Обратный код и выполнение алгебраического сложения в нем ............................. 41
3.5.1. Алгебраическое сложение в обратном коде ...................................................... 42
IV Îãëàâëåíèå
3.6. Дополнительный код и арифметические операции в нем ....................................... 47
3.6.1. Алгебраическое сложение в дополнительном коде .......................................... 48
3.6.2. Модифицированные обратный и дополнительный коды ................................. 52
3.7. Алгоритмы алгебраического сложения в обратном
и дополнительном коде .............................................................................................. 52
3.8. Алгоритмы умножения ............................................................................................... 54
3.8.1. Умножение в дополнительном коде ................................................................... 56
3.8.2. Методы ускорения умножения ........................................................................... 56
3.9. Алгоритмы деления .................................................................................................... 60
3.9.1. Деление без восстановления остатка .................................................................. 62
3.10. Арифметические операции с числами, представленными
в формате с плавающей запятой .............................................................................. 62
3.10.1. Сложение и вычитание ...................................................................................... 64
3.10.2. Умножение и деление ........................................................................................ 68
3.11. Арифметические операции над десятичными числами ......................................... 68
3.11.1. Кодирование десятичных чисел ........................................................................ 68
3.11.2. Арифметические операции над десятичными числами .................................. 70
3.12. Машинная арифметика в остаточных классах........................................................ 73
3.12.1. Представление чисел в системе остаточных классов ..................................... 74
3.12.2. Арифметические операции с положительными числами ............................... 75
3.12.3. Арифметические операции с отрицательными числами ................................ 78
Глава 4. Организация устройств ЭВМ ........................................................................ 79
4.1. Принцип микропрограммного управления ............................................................... 79
4.2. Концепция операционного и управляющего автоматов .......................................... 80
4.3. Операционный автомат .............................................................................................. 81
4.3.1. Пример проектирования операционного автомата АЛУ .................................. 82
Определение форматов данных ................................................................................ 82
Разработка алгоритма деления .................................................................................. 83
Разработка структуры операционного автомата ..................................................... 85
4.4. Управляющий автомат ............................................................................................... 89
4.4.1. Управляющий автомат с "жесткой" логикой ..................................................... 89
Пример проектирования УАЖЛ ............................................................................... 90
4.4.2. Управляющий автомат с программируемой логикой ....................................... 97
Принципы организации ............................................................................................. 97
Адресация микрокоманд............................................................................................ 99
Кодирование микроопераций .................................................................................. 104
Пример проектирования УАПЛ .............................................................................. 107
Глава 5. Организация памяти в ЭВМ ........................................................................ 116
5.1. Концепция многоуровневой памяти ........................................................................ 116
5.2. Сверхоперативная память ........................................................................................ 118
5.2.1. СОЗУ с прямым доступом ................................................................................. 119
5.2.2. СОЗУ с ассоциативным доступом .................................................................... 119
Îãëàâëåíèå V
5.3. Виртуальная память .................................................................................................. 127
5.3.1. Алгоритмы замещения....................................................................................... 128
5.3.2. Сегментная организация памяти ....................................................................... 130
ЧАСТЬ II. АРХИТЕКТУРА МИКРОПРОЦЕССОРНЫХ СИСТЕМ ................... 131
Глава 6. Базовая архитектура микропроцессорной системы ............................... 137
6.1. Процессорный модуль .............................................................................................. 138
6.1.1. Внутренняя структура микропроцессора ......................................................... 138
6.1.2. Командный и машинный циклы микропроцессора......................................... 140
6.1.3. Реализация процессорных модулей и состав линий системного
интерфейса ........................................................................................................ 142
6.2. Машина пользователя и система команд ................................................................ 144
6.2.1. Распределение адресного пространства ........................................................... 145
6.2.2. Система команд i8086 ........................................................................................ 147
6.3. Функционирование основных подсистем МПС ..................................................... 148
6.3.1. Оперативная память ........................................................................................... 150
Диспетчер памяти..................................................................................................... 150
6.3.2. Ввод/вывод ......................................................................................................... 151
Параллельный обмен ............................................................................................... 151
Последовательный обмен ........................................................................................ 156
6.3.3. Прерывания ........................................................................................................ 158
Обнаружение изменения состояния внешней среды ............................................. 160
Идентификация источника прерывания ................................................................. 161
Приоритет запросов ................................................................................................. 161
Приоритет программ ................................................................................................ 162
Обработка прерывания ............................................................................................ 162
6.3.4. Прямой доступ в память .................................................................................... 165
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ ....................... 167
7.1. Защищенный режим и организация памяти............................................................ 168
7.1.1. Сегментная организация памяти ....................................................................... 168
7.1.2. Страничная организация памяти ...................................................................... 173
7.1.3. Защита памяти .................................................................................................... 177
Защита памяти на уровне сегментов ...................................................................... 177
Защита доступа к данным ........................................................................................ 179
Защита сегментов кода ............................................................................................ 180
Защита памяти на уровне страниц .......................................................................... 181
7.2. Мультизадачность ..................................................................................................... 183
7.2.1. Сегмент состояния задачи ................................................................................. 183
7.2.2. Переключение задачи ........................................................................................ 187
7.3. Прерывания и особые случаи ................................................................................... 189
7.3.1. Дескрипторная таблица прерываний ................................................................ 193
7.3.2. Учет уровня привилегий .................................................................................... 195
VI Îãëàâëåíèå
7.3.3. Код ошибки ......................................................................................................... 195
7.3.4. Описание особых случаев ................................................................................. 196
7.4. Средства отладки ...................................................................................................... 200
7.4.1. Регистры отладки ............................................................................................... 202
Регистрация нескольких особых случаев ............................................................... 206
7.5. Увеличение быстродействия процессора ................................................................ 206
7.5.1. Конвейеры .......................................................................................................... 208
7.5.2. Динамический параллелизм .............................................................................. 211
7.5.3. VLIW-архитектура ............................................................................................. 215
Выводы ...................................................................................................................... 217
7.6. Однокристальные микроЭВМ ................................................................................. 218
ЧАСТЬ III. ЛАБОРАТОРНЫЙ ПРАКТИКУМ
И КУРСОВОЕ ПРОЕКТИРОВАНИЕ ................................................. 225
Глава 8. Описание программных моделей АЛУ ...................................................... 229
8.1. Программная модель ALU-1 .................................................................................... 229
8.1.1. Операционный автомат ALU-1 ......................................................................... 230
8.1.2. Управляющий автомат с программируемой логикой ..................................... 239
8.2. Программная модель ALU-R ................................................................................... 244
8.2.1. Операционный автомат ALU-R ........................................................................ 245
8.2.2. Управляющий автомат ALU-R ......................................................................... 250
Глава 9. Описание архитектуры учебной ЭВМ ....................................................... 255
9.1. Структура ЭВМ ......................................................................................................... 255
9.2. Представление данных в модели ............................................................................. 258
9.3. Система команд ......................................................................................................... 258
9.3.1. Форматы команд ................................................................................................ 258
9.3.2. Способы адресации ............................................................................................ 259
9.3.3. Система операций .............................................................................................. 260
9.4. Состояния и режимы работы ЭВМ .......................................................................... 260
9.5. Интерфейс пользователя .......................................................................................... 261
9.5.1. Окна основных обозревателей системы ........................................................... 263
Окно Процессор ....................................................................................................... 263
Окно Память ............................................................................................................ 264
Окно Текст программы ........................................................................................... 265
Окно Программа ...................................................................................................... 267
Окно Микрокомандный уровень ............................................................................. 268
Окно Кэш-память .................................................................................................... 269
9.6. Внешние устройства ................................................................................................. 269
9.6.1. Контроллер клавиатуры ..................................................................................... 270
9.6.2. Дисплей ............................................................................................................... 273
9.6.3. Блок таймеров .................................................................................................... 275
9.6.4. Тоногенератор .................................................................................................... 277
Îãëàâëåíèå VII
9.7. Подсистема прерываний ........................................................................................... 278
9.8. Программная модель кэш-памяти ........................................................................... 280
9.9. Вспомогательные таблицы ....................................................................................... 283
Глава 10. Лабораторные работы................................................................................. 288
10.1. Лабораторная работа № 1. Разработка алгоритма
и микропрограммы арифметической операции.................................................... 289
10.1.1. Арифметические операции сложения и вычитания ...................................... 289
10.1.2. Задания повышенной сложности .................................................................... 290
10.1.3. Порядок выполнения заданий ......................................................................... 291
10.1.4. Содержание отчета ........................................................................................... 292
10.1.5. Контрольные вопросы ..................................................................................... 292
10.2. Лабораторная работа № 2. Программирование управляющего
автомата ................................................................................................................... 293
10.2.1. Порядок выполнения заданий при работе с программной
моделью ALU-1 ............................................................................................... 293
10.2.2. Содержание отчета при работе с программной моделью ALU-1 ................... 293
10.2.3. Порядок выполнения заданий при работе с программной
моделью ALU-R ............................................................................................... 294
10.2.4. Содержание отчета при работе с программной моделью ALU-R .................. 294
10.3. Лабораторная работа № 3. Архитектура ЭВМ и система команд....................... 295
10.3.1. Общие положения ............................................................................................ 295
10.3.2. Пример .............................................................................................................. 296
10.3.3. Задание .............................................................................................................. 296
10.3.4. Содержание отчета ........................................................................................... 297
10.3.5. Контрольные вопросы ..................................................................................... 297
10.4. Лабораторная работа № 4. Программирование разветвляющегося
процесса ................................................................................................................... 298
10.4.1. Пример .............................................................................................................. 298
10.4.2. Задание .............................................................................................................. 300
10.4.3. Содержание отчета ........................................................................................... 302
10.4.4. Контрольные вопросы ..................................................................................... 302
10.5. Лабораторная работа № 5. Программирование цикла
с переадресацией ..................................................................................................... 303
10.5.1. Пример .............................................................................................................. 303
10.5.2. Задание .............................................................................................................. 305
10.5.3. Содержание отчета ........................................................................................... 306
10.5.4. Контрольные вопросы ..................................................................................... 306
10.6. Лабораторная работа № 6. Подпрограммы и стек ............................................... 306
10.6.1. Пример .............................................................................................................. 308
10.6.2. Задание .............................................................................................................. 310
10.6.3. Содержание отчета ........................................................................................... 310
10.6.4. Контрольные вопросы ..................................................................................... 311
VIII Îãëàâëåíèå
10.7. Лабораторная работа № 7. Командный цикл процессора .................................... 311
10.7.1. Задание 1 ........................................................................................................... 311
10.7.2. Задание 2 ........................................................................................................... 311
10.7.3. Контрольные вопросы ..................................................................................... 313
10.8. Лабораторная работа № 8. Программирование внешних устройств .................. 313
10.8.1. Задание .............................................................................................................. 314
10.8.2. Задания повышенной сложности .................................................................... 316
10.8.3. Порядок выполнения работы .......................................................................... 317
10.8.4. Содержание отчета ........................................................................................... 317
10.8.5. Контрольные вопросы ..................................................................................... 317
10.9. Лабораторная работа № 9. Принципы работы кэш-памяти ................................. 317
10.9.1. Задание .............................................................................................................. 318
10.9.2. Порядок выполнения работы .......................................................................... 319
10.9.3. Содержание отчета ........................................................................................... 319
10.9.4. Контрольные вопросы ..................................................................................... 319
10.10. Лабораторная работа № 10. Алгоритмы замещения строк кэш-памяти ........... 320
10.10.1. Задание ............................................................................................................ 320
10.10.2. Порядок выполнения работы ........................................................................ 320
10.10.3. Содержание отчета ......................................................................................... 321
10.10.4. Контрольные вопросы ................................................................................... 321
Глава 11. Курсовая работа ........................................................................................... 323
11.1. Цель и содержание работы ..................................................................................... 323
11.2. Задания ..................................................................................................................... 323
11.3. Этапы выполнения работы ..................................................................................... 326
11.4. Содержание пояснительной записки ..................................................................... 328
ПРИЛОЖЕНИЯ ............................................................................................................ 331
Приложение 1. Список сокращений, используемых в тексте ............................... 333
Приложение 2. Описание компакт-диска.................................................................. 335
Литература ...................................................................................................................... 339
Предметный указатель ................................................................................................. 341
Предисловие
Эта книга создавалась как учебное пособие по архитектуре процессоров
и ЭВМ. Материал книги ориентирован на студентов инженерных специаль-
ностей, обучающихся в области разработки программного обеспечения и ин-
формационных систем, для которых "компьютерное железо" не является ос-
новным предметом изучения, но которые хотят (и должны) знать основы
построения процессоров, организацию взаимодействия основных устройств
ЭВМ, программирование на низком уровне. Книга может быть полезной
и студентам педагогических специальностей, в учебных планах которых пре-
дусмотрены курсы по изучению архитектуры ЭВМ (физика, математика, ин-
форматика).
Читателям необходимо владеть начальными знаниями в области цифровой
схемотехники (булева алгебра, логические элементы, триггеры, операцион-
ные элементы).
В основу книги положены материалы курсов лекций, читаемых автором на
кафедре вычислительной техники Курского государственного технического
университета (КГТУ) и кафедре программного обеспечения и администриро-
вания информационных систем КГУ. Книга объединяет в себе теоретический
материал, цикл лабораторных работ и задания на курсовое проектирование.
Пособие состоит из трех частей.
В части I рассматриваются общие принципы организации ЭВМ, включая их
функциональную и структурную организацию. Достаточно подробно рас-
смотрены арифметические основы ЭВМ, представление чисел в различных
кодах и алгоритмы выполнения арифметических операций. Уделено внима-
ние кодированию десятичных чисел и десятичной машинной арифметике,
а также системам счисления в остаточных классах. Далее рассматриваются
принципы построения устройств ЭВМ — концепция операционного и управ-
ляющего автоматов, подходы к их синтезу. Рассмотрены управляющие авто-
маты с жесткой и программируемой логикой. Отдельная глава посвящена
2 Предисловие
организации многоуровневой памяти ЭВМ, вопросам взаимодействия уст-
ройств памяти разных уровней.
Часть II посвящена обсуждению базовой архитектуры систем на основе
микропроцессоров х86. Кроме внутренней структуры микропроцессора и его
интерфейса рассматривается организация ввода/вывода, прерываний, прямо-
го доступа в память. Кратко рассмотрена эволюция архитектуры процессоров
семейства х86.
Часть III содержит лабораторный практикум и курсовое проектирование.
Лабораторный практикум включает в себя большинство тем части I. Для вы-
полнения лабораторных работ предлагается ряд программных моделей, раз-
мещенных на компакт-диске. Программные модели арифметико-логических
устройств позволяют разрабатывать и отлаживать алгоритмы арифметиче-
ских и логических преобразований, знакомиться со структурами операцион-
ных автоматов, проектировать управляющие автоматы по заданным (разра-
ботанным) микропрограммам. На базе программной модели учебной ЭВМ
можно познакомиться со структурой ЭВМ, системой команд, программиро-
ванием на уровне ассемблера, изучить принципы взаимодействия процессора
с внешними устройствами, организацию многоуровневой памяти ЭВМ. Для
каждой из десяти лабораторных работы сформулирована цель, индивидуаль-
ные задания, требования к оформлению отчета и контрольные вопросы; для
некоторых заданий приведены примеры выполнения.
Содержанием курсовой работы является разработка арифметико-логического
устройства, реализующего заданный набор операций с учетом ограничений
на код выполнения операций и способ построения управляющего автомата.
Сформулированы индивидуальные задания, определены этапы выполнения
работы и содержание пояснительной записки.
В работе над книгой принимал участие канд. тех. наук, доцент А. М. Фрум-
кин, совместно с которым написаны разд. 8.1, 10.1 и 10.2.
Автор благодарит студентов и выпускников факультета информатики и вы-
числительной техники КГУ В. Кузьминова, А. Ильина, А. Алферова, руково-
дителя отдела архитектуры корпорации Skyros И. Жмакина, принимавших
активное участие в разработке и отладке приведенных в книге программных
моделей АЛУ и ЭВМ.
Автор выражает искреннюю признательность заведующему кафедрой сис-
темного программирования СпбГУ, профессору, доктору физ.-мат. наук
А. Н. Терехову и доценту, канд. физ.-мат. наук В. А. Костину за ценные заме-
чания, сделанные при рецензировании книги.
ЧАСТЬ I
Принципы организации ЭВМ
Глава 1. Начальные сведения об ЭВМ
Глава 2. Функциональная организация ЭВМ
Глава 3. Арифметические основы ЭВМ
Глава 4. Организация устройств ЭВМ
Глава 5. Организация памяти в ЭВМ
4 Часть I. Принципы организации ЭВМ
Принято считать, что ЭВМ — "сложная система". Это понятие имеет много
трактовок, в т. ч. и такую: "сложную систему невозможно адекватно опи-
сать на одном языке". Обычно ЭВМ рассматривают на нескольких
уровнях:
􀂈 логические элементы;
􀂈 операционные элементы (узлы);
􀂈 устройства;
􀂈 структура ЭВМ и система команд.
На каждом из уровней используются свои языки описания. И "выше", и "ни-
же" приведенных элементов списка можно выделить другие уровни, но их
рассмотрение лежит за пределами этой книги.
Приступая к изучению вопросов архитектуры ЭВМ, читатель должен иметь
представление о логических и операционных элементах цифровой техники
(конъюнкторы, инверторы, ..., триггеры, регистры, мультиплексоры, дешиф-
раторы, сумматоры и т. д.).
Центральным в структуре ЭВМ является, несомненно, процессор, а главными
устройствами любого процессора можно считать арифметико-логическое
устройство (АЛУ) и устройство управления (УУ). Далее мы подробно рас-
смотрим принципы и способы организации АЛУ. Поскольку АЛУ разраба-
тывается для реализации определенных алгоритмов арифметической и логи-
ческой обработки данных, то неизбежным становится и рассмотрение
различных вариантов таких алгоритмов.
Глава 1
Начальные сведения об ЭВМ
1.1. История развития
вычислительной техники
С тех пор как человечество осознало понятие количества, разрабатывались
и применялись различные приспособления для отображения количественных
эквивалентов и операций над величинами. Отбросив рассмотрение "доисто-
рических" с точки зрения вычислительной техники средств (кучки камней,
счеты и т. д.), рассмотрим кратко историю развития вычислительных машин.
Пожалуй, первой реально созданной машиной для выполнения арифметиче-
ских действий в десятичной системе счисления можно считать счетную ма-
шину Паскаля. В 1642 г. Б. Паскаль продемонстрировал ее работу. Машина
выполняла суммирование чисел (восьмиразрядных) с помощью колес, кото-
рые при добавлении единицы поворачивались на 36° и приводили в движе-
ние следующее по старшинству колесо всякий раз, когда цифра 9 должна бы-
ла перейти в значение 10. Машина Паскаля получила известность во многих
странах, было изготовлено более 50 экземпляров машины.
Впрочем, еще до Паскаля машину, механически выполняющую арифметиче-
ские операции, изобразил в эскизах Леонардо да Винчи (1452—1519). Сум-
мирующая машина по его эскизам выполнена в наши дни и доказала свою
работоспособность.
В средние века (расцвет механики) было предложено и выполнено много раз-
личных вариантов арифметических машин: Морлэнд (1625—1695), К. Перро
(1613—1688), Якобсон, Чебышев и др. Первую машину, с помощью которой
можно было не только складывать, но и умножать и делить, разработал
Г. Лейбниц (1646—1716). Однако большинство подобных машин изготавли-
вались авторами в единичных экземплярах. Удачное решение инженера
В. Однера, разработавшего колесо с переменным числом зубьев, позволило
6 Часть I. Принципы организации ЭВМ
почти век серийно выпускать арифмометры (например, "Феликс" Курского
завода "Счетмаш"), являвшиеся основным средством вычислений вплоть до
эпохи ПЭВМ и калькуляторов.
Все упомянутые выше механизмы обладали одной особенностью — могли
автоматически выполнять только отдельные действия над числами, но не
могли хранить промежуточные результаты и, следовательно, выполнять по-
следовательность действий.
Первой вычислительной машиной, реализующей автоматическое выполнение
последовательности действий, можно считать разностную машину
Ч. Беббеджа (1792—1871). В 1819 г. он изготовил ее для расчета астрономи-
ческих и морских таблиц. Машина обеспечивала хранение необходимых
промежуточных значений и выполнение последовательности сложений для
получения значения функции. В дальнейшем Беббедж предложил так назы-
ваемую аналитическую машину, предназначенную для решения любых вы-
числительных задач. При желании в аналитической машине Беббеджа можно
найти прообразы всех основных устройств современной ЭВМ: арифметиче-
ское устройство ("мельница"), память ("склад"), устройство управления (на
перфокартах), позволяющее выбирать различные пути решения в зависимо-
сти от значений исходных данных и промежуточных результатов. Проект
аналитической машины Беббеджа так и не был реализован — из-за несоот-
ветствия идеи и элементной базы.
Даже выпускаемые большими сериями электрические релейные машины
Холлерита (1860—1929) — табуляторы — не произвели переворота в сред-
ствах обработки информации, хотя и широко использовались для обработки
статистической информации вплоть до 70-х годов прошлого века.
Идеи аналитической машины Беббеджа были использованы в релейных ма-
шинах, выпускавшихся в 30—40-х годах XX века. Теоретической основой
разработки релейно-контактных схем явился аппарат булевой алгебры, кото-
рый в дальнейшем использовался для синтеза схем ЭВМ. Однако и электри-
ческие реле как элементная база вычислительной техники не удовлетворяли
потребностям этой техники по всем основным параметрам (быстродействие,
надежность, потребляемая мощность, стоимость, габариты и др.).
Только освоение электронных схем в качестве элементной базы положило
начало действительно массовому внедрению сначала вычислительной, а по-
том и информационной техники во все сферы человеческой деятельности.
Первые электронные цифровые вычислительные машины (ЭВМ) были раз-
работаны и выпущены на рубеже 40—50-х годов прошлого века в США,
Англии и чуть позднее — в СССР.
Глава 1. Начальные сведения об ЭВМ 7
1.2. Цифровые и аналоговые
вычислительные машины
Все приведенные ранее факты относятся к истории так называемой цифровой
вычислительной техники, в которой информация представлена в дискретной
форме (в форме чисел, кодов, знаков). Однако большинство физических величин
может принимать значение из непрерывного множества — континуума. Сущест-
вуют вычислительные устройства, оперирующие непрерывной информацией
(пример — логарифмическая линейка, где информация представлена отрезками
длины). Существует и целый класс электронных вычислительных машин — так
называемые аналоговые, информация в которых представляется непрерывными
значениями электрического напряжения или тока. Принцип работы таких ма-
шин — в построении электрических цепей, процессы в которых описываются
теми дифференциальными уравнениями, которые требуется решить.
а б
Рис. 1.1. Модель: а — механическая система; б — "аналогичная" ей электрическая цепь
Классический пример такого подхода показан на рис. 1.1. Например, требуется
изучить поведение механической колебательной системы, описываемой диффе-
ренциальным уравнением (1.1). Подберем электрическую цепь, процессы в кото-
рой описываются тем же дифференциальным уравнением с точностью до обо-
значений (1.2). Между механическими величинами (рис. 1.1, а) и электрическими
(рис. 1.1, б) существует соответствие (сравните уравнения (1.1) и (1.2)).
mg x dt kx
dt
dx
m
t
= − ∫ ⋅ −
0
. (1.1)
U i dt Ri
dt
di
L
t
− ⋅ − = ∫
0
. (1.2)
8 Часть I. Принципы организации ЭВМ
Таким образом, для механического устройства можно подобрать электриче-
скую цепь, процессы в которой описываются аналогичными дифференциаль-
ными уравнениями. Или, для заданного дифференциального уравнения (сис-
темы) построить электрическую цепь, которая описывается этим уравнением.
Существуют хорошо отработанная методика синтеза таких цепей и наборы
функциональных блоков (АВМ), позволяющие собирать и исследовать син-
тезированные цепи.
Достоинства АВМ: простота подготовки решения, высокая скорость решения.
Недостатки АВМ: неуниверсальность (предназначены только для решения
дифференциальных уравнений) и низкая точность решения.
В настоящее время АВМ находят применение лишь в ограниченных областях
технического моделирования. Поэтому в дальнейшем будем употреблять
термин "ЭВМ", имея в виду только цифровые вычислительные машины, как
это принято в современной терминологии.
1.3. Варианты классификации ЭВМ
За свою полувековую историю ЭВМ из единичных экземпляров инструмен-
тов ученых превратились в предмет массового потребления. Спектр приме-
нения ЭВМ в современном обществе чрезвычайно широк, причем именно
область применения накладывает основной отпечаток на характеристики
ЭВМ. Поэтому в большинстве подходов к классификации ЭВМ именно об-
ласть применения является основным параметром классификации.
Изделия современной техники, особенно вычислительной, традиционно при-
нято делить на поколения (табл. 1.1), причем основным признаком поколения
ЭВМ считается ее элементная база. Следует помнить, что любая классифика-
ция не является абсолютной. Всегда можно отыскать объект классификации,
который по одним параметрам относится к одному классу, а по другим —
к другому. Это в большой степени относится и к классификации поколений
ЭВМ: некоторые авторы выделяют три поколения ЭВМ (дальнейшее разви-
тие ЭВМ идет как бы вне поколений), другие насчитывают целых шесть.
В рамках первого поколения ЭВМ не возникала необходимость в классифи-
кации, т. к. машин были считанные единицы и использовались они, как пра-
вило, для выполнения научно-технических расчетов. Отдельные машины
характеризовались быстродействием (числом выполняемых операций в се-
кунду), объемом памяти, стоимостью, надежностью (наработка на отказ), га-
баритно-весовыми характеристиками, потребляемой мощностью и другими
параметрами.
Глава 1. Начальные сведения об ЭВМ 9
Таблица 1.1. Поколения ЭВМ
Поколение Элементная база Годы
существования Области применения
Первое Электронные лампы 50—60 Научно-технические расчеты
Второе Транзисторы,
ферритовые сердеч-
ники
60—70 Научно-технические расчеты,
планово-экономические рас-
четы
Третье Интегральные схемы 70—80 Научно-технические расчеты,
планово-экономические расче-
ты, системы управления
Четвертое СИС, БИС, СБИС
и т. д.
80 и по сей день Все сферы деятельности
Использование транзисторов в качестве элементной базы второго поколе-
ния привело к улучшению примерно на порядок каждого из основных па-
раметров ЭВМ. Это, в свою очередь, резко расширило сферу применения
ЭВМ, причем в разных областях применения к ЭВМ предъявлялись раз-
личные требования. Так называемые "научно-технические расчеты" харак-
теризовались относительно небольшим объемом входной и выходной
информации, но очень большим числом сложных операций с высокой точ-
ностью над входной информацией, а "планово-экономические расчеты"1 —
наоборот, простейшими операциями (сложение, сравнение) над огромными
объемами информации.
Соответственно в рамках второго поколения ЭВМ выделялись:
􀂈 ЭВМ для научно-технических расчетов, характеризующиеся мощным бы-
стродействующим процессором с развитой системой команд (в т. ч. реали-
зующей арифметику с плавающей запятой) и относительно небольшой
внешней памятью и номенклатурой устройств ввода/вывода;
􀂈 ЭВМ для планово-экономических расчетов, характеризующиеся, прежде
всего, большой многоуровневой памятью, развитой номенклатурой уст-
ройств ввода/вывода (УВВ), но относительно простым и дешевым процес-
сором, система команд которого включает простые арифметические ко-
манды (сложение, вычитание) с фиксированной запятой.
Характерно, что и языки программирования "второго поколения" так же раз-
делялись на "математические" (FORTRAN) и "экономические" (COBOL).
1 Здесь используется терминология, принятая в годы существования второго поколе-
ния ЭВМ.
10 Часть I. Принципы организации ЭВМ
Однако по мере расширения сферы применения ЭВМ, улучшения их основ-
ных характеристик, появления новых задач, границы между выделенными
классами стали размываться. Уже в рамках второго поколения стали выде-
лять так называемые ЭВМ общего назначения, одинаково хорошо приспо-
собленные для решения разнообразных задач. Такие машины объединяли
в себе достоинства "научно-технических" и "планово-экономических" ЭВМ:
мощный процессор, большую память, широкую номенклатуру УВВ (в то
время это уже можно было себе позволить). Такие машины могли решать
задачи, недоступные предыдущим моделям. Но для решения более простых
задач их ресурсы являлись избыточными и, следовательно, решение этих
задач экономически не оправдано. Поэтому ЭВМ общего назначения (уни-
версальные ЭВМ) стали выпускать различной вычислительной мощности
(и, следовательно, стоимости): большие, средние и малые.
В рамках ЭВМ третьего поколения стал усиленно развиваться новый
класс — управляющие ЭВМ. К ЭВМ, работающим в контуре управления объ-
ектом или технологическим процессом, предъявляются специфические тре-
бования: прежде всего, высокая надежность, способность работать в экстре-
мальных внешних условиях (перепады температуры, давления, питающих
напряжений, высокий уровень электромагнитных помех и т. п.), быстрая ре-
акция на изменения состояния внешней среды, малые габариты и вес, про-
стота обслуживания. В то же время к таким характеристикам, как быстродей-
ствие процессора, мощность системы команд, объем памяти, часто не
предъявлялись слишком высоких требований, зато решающим становился
фактор стоимости. Эти особенности привели к появлению класса так назы-
ваемых мини-ЭВМ, а затем и микроЭВМ, хотя в дальнейшем и мини- и мик-
роЭВМ использовались не только в качестве управляющих. Иногда эти клас-
сы объединяли понятием проблемно-ориентированные ЭВМ.
Наряду с упомянутыми классами ЭВМ широкого применения всегда выпус-
кались машины, которые можно было считать специализированными. Это,
во-первых, так называемые суперЭВМ, выпускаемые в единичных экземпля-
рах и предназначенные для решения задач, недоступных для серийной вы-
числительной техники. Для ряда применений создавались специализирован-
ные ЭВМ, архитектура и структура которых оптимизировалась под решение
конкретной задачи. Ту же задачу можно было решить и на универсальной
ЭВМ подходящего класса, но со значительно более низкими показателями
качества. В то же время решение других задач на специализированной ЭВМ
было либо невозможно, либо крайне неэффективно. Одна из возможных
классификаций ЭВМ на рубеже 3—4 поколений показана на рис. 1.2.
Еще одним важным явлением, проявившимся при развитии третьего поколе-
ния ЭВМ, стало появление семейств ЭВМ. В рамках одного семейства, объе-
Глава 1. Начальные сведения об ЭВМ 11
диненного общими архитектурными, структурными, а иногда — и конструк-
тивными решениями, выпускались несколько (иногда — более десятка) клас-
сов ЭВМ: малые, средние, "полусредние", большие, очень большие и т. д.
ЭВМ
ЭВМ
общего назначения
Проблемно-ориентированные
ЭВМ
Специализированные
ЭВМ
Малые
Средние
Большие
Мини-ЭВМ
МикроЭВМ
СуперЭВМ
Спец. ЭВМ
Рис. 1.2. Вариант классификации ЭВМ
Общими для большинства семейств являются:
􀂈 внутренний язык, что позволяет осуществлять совместимость программ на
уровне машинных кодов (IBM-360, ЕС ЭВМ) либо системы команд, обла-
дающие совместимостью "снизу вверх" (PDP-11), когда старшие предста-
вители семейства реализуют все команды младших моделей плюс еще не-
которые команды;
􀂈 форматы данных;
􀂈 форматы записи на внешний носитель;
􀂈 интерфейс, что позволяет иметь единую номенклатуру внешних устройств
для всех представителей семейства;
􀂈 преемственность программного обеспечения (как правило, та же совмес-
тимость "снизу вверх").
Для решения конкретной задачи пользователь подбирал соответствующий
экземпляр семейства, а по мере усложнения задачи осуществлялся переход
на более старшие модели семейства, причем уже отлаженные на младших
моделях программы, как правило, не требовали доработки.
Наиболее известными примерами семейств ЭВМ могут служить:
􀂈 семейство универсальных ЭВМ третьего поколения IBM-360 и его совет-
ский аналог — ЕС ЭВМ, включающее малые машины ЕС-1010 и ЕС-1020,
средние ЕС-1022, ЕС-1030, ЕС-1035 и др., большие ЕС-1050, ЕС-1060,
ЕС-1065;
12 Часть I. Принципы организации ЭВМ
􀂈 семейство мини-ЭВМ PDP-11 и его советский аналог — СМ ЭВМ (лишь
часть представителей семейства — СМ-3, СМ-4, СМ-1420);
􀂈 семейство микроЭВМ LXI-11 (Электроника-60 и ее модификации);
􀂈 семейство микропроцессоров i80x86.
1.4. Классическая архитектура ЭВМ
Считается, что основные идеи построения современных ЭВМ в 1945 г. сфор-
мулировал американский математик Дж. фон Нейман, определив их как
принципы программного управления:
1. Информация кодируется в двоичной форме и разделяется на единицы —
слова.
2. Разнотипные по смыслу слова различаются по способу использования, но
не по способу кодирования.
3. Слова информации размещаются в ячейках памяти и идентифицируются
номерами ячеек — адресами слов.
4. Алгоритм представляется в форме последовательности управляющих
слов, называемых командами. Команда определяет наименование опера-
ции и слова информации, участвующие в ней. Алгоритм, записанный
в виде последовательности команд, называется программой.
5. Выполнение вычислений, предписанных алгоритмом, сводится к последо-
вательному выполнению команд в порядке, однозначно определенном
программой.
Поэтому классическую архитектуру современных ЭВМ, представленную
на рис. 1.3, часто называют "архитектурой фон Неймана".
Рис. 1.3. Классическая архитектура ЭВМ
Глава 1. Начальные сведения об ЭВМ 13
Программа вычислений (обработки информации) составляется в виде после-
довательности команд и загружается в память машины — запоминающее
устройство (ЗУ). Там же хранятся исходные данные и промежуточные резуль-
таты обработки. Центральное устройство управления (ЦУУ) последовательно
извлекает из памяти команды программы и организует их выполнение. Ариф-
метико-логическое устройство (АЛУ) предназначено для реализации опера-
ций преобразования информации. Программа и исходные данные вводятся
в память машины через устройства ввода (УВв), а результаты обработки
предъявляются на устройства вывода (УВыв).
Характерной особенностью архитектуры фон Неймана является то, что па-
мять представляет собой единое адресное пространство, предназначенное для
хранения как программ, так и данных.
Такой подход, с одной стороны, обеспечивает большую гибкость организа-
ции вычислений — возможность перераспределения памяти между програм-
мой и данными, возможность самомодификации программы в процессе ее
выполнения. С другой стороны, без принятия специальных мер защиты сни-
жается надежность выполнения программы, что особенно недопустимо
в управляющих системах.
Действительно, поскольку и команды программы, и данные кодируются
в ЭВМ двоичными числами, теоретически возможно как разрушение про-
граммы (при обращении в область программы как к данным), так и попытка
"выполнения" области данных как программы (при ошибочных переходах
программы в область данных).
Альтернативной фон-неймановской является так называемая гарвардская
архитектура. ЭВМ, реализованные по этому принципу, имеют два непере-
секающихся адресных пространства — для программы и для данных, при-
чем программу нельзя разместить в свободной области памяти данных
и наоборот. Гарвардская архитектура применяется главным образом в
управляющих ЭВМ.
1.5. Иерархическое описание ЭВМ
ЭВМ как сложная система может быть адекватно описана на нескольких
уровнях с применением различных языков описания на каждом из уровней.
Принципы структурного описания предполагают введение следующих по-
нятий:
􀂈 система — совокупность элементов, объединенных в одно целое для дос-
тижения определенных целей. Для полного описания системы следует оп-
ределить ее функции и структуру;
14 Часть I. Принципы организации ЭВМ
􀂈 структура системы — фиксированная совокупность элементов системы
и связей между ними;
􀂈 элемент — неделимая часть системы, структура которого не рассматрива-
ется, а определяются только его функции.
Функции системы стремятся описывать в математической форме, иногда —
в словесной (содержательной форме). Структура системы может быть задана
в виде графа или эквивалентных ему математических форм (матриц). Инже-
нерной формой задания структуры является схема (отличается от графа толь-
ко формой). Различным уровням представления систем соответствуют раз-
личные виды схем.
Свойства системы не являются простой суммой свойств входящих в нее эле-
ментов; за счет организации связей между элементами приобретается новое
качество, отсутствующее в элементах. Например, радиокомпоненты → логи-
ческие элементы → сумматор.
Для сложных систем характерно, что функция, реализуемая системой, не
может быть представлена как композиция функций, реализуемых наимень-
шими элементами системы (иначе говоря, функцию сложной системы нельзя
адекватно описать на одном языке). Действительно, функционирование ЭВМ
нельзя описать лишь на языке электрических процессов, в ней происходя-
щих. Функции ЭВМ как системы выявляются лишь при рассмотрении ин-
формационных и логических аспектов ее работы.
Поэтому в описании сложных систем используют несколько форм описания
(языков) функций и структуры — иерархию функций и структуры. Иерархи-
ческий подход к описанию сложных систем предполагает, что на высшем
уровне иерархии система рассматривается как один элемент, имеющий вхо-
ды и выходы для связи с внешней средой. В этом случае функция не может
быть задана подробно и представляется как отображение состояний входов
на состояние выходов системы.
Чтобы раскрыть устройство и порядок функционирования системы, глобаль-
ная функция и сама система разделяются на части — функции и структурные
элементы следующего более низкого уровня иерархии и т. д. до тех пор, пока
функции и структура системы не будут раскрыты полностью, с необходимой
степенью детализации.
В этом случае элемент — это, прежде всего, удобное понятие, а не физиче-
ское свойство, т. к. один и тот же физический объект может рассматриваться
как элемент на одном уровне иерархии и как система — на другом (более
низком) уровне. В табл. 1.2 представлены основные уровни ЭВМ и языки
описания этих уровней.
Глава 1. Начальные сведения об ЭВМ 15
Таблица 1.2. Уровни описания ЭВМ
Уровень
описания Объект Структурный базис Язык описания
Электрические
схемы
Логические и запоми-
нающие элементы
Электронные и радио-
компоненты — тран-
зисторы, резисторы
и др.
Соотношения тео-
рии электрических
цепей
Логические
схемы
Операционные элементы
(счетчики, сумматоры,
дешифраторы, регистры
и т. д.), микропрограмм-
ные автоматы
Логические и запоми-
нающие элементы
Булева алгебра,
теория конечных
автоматов
Операционные
схемы
Операционные устройст-
ва: (арифметико-
логическое устройство,
устройство управления,
запоминающее устройст-
во и др.)
Операционные эле-
менты, микропро-
граммные автоматы
Языки описания
микроопераций
Структурные
схемы
ЭВМ и системы Операционные
устройства
Языки машинных
команд, микропро-
грамм
Программный
уровень
Операционные системы,
вычислительный процесс
Команды и операторы Алгоритмические
языки
Глава 2
Функциональная
организация ЭВМ
Термин "функциональная организация ЭВМ" часто используют в качестве сино-
нима (в некотором смысле) более широкого термина — "архитектура ЭВМ",
который, в свою очередь, трактуется разными авторами несколько в различных
смыслах. Наиболее близким к трактовке автора может служить определение тер-
мина "архитектура ЭВМ", данное в [7]. Приведем это определение.
Архитектура ЭВМ — это абстрактное представление ЭВМ, которое отража-
ет ее структурную, схемотехническую и логическую организацию. Понятие
архитектуры ЭВМ является комплексным и включает в себя:
􀂈 структурную схему ЭВМ;
􀂈 средства и способы доступа к элементам структурной схемы;
􀂈 организацию и разрядность интерфейсов ЭВМ;
􀂈 набор и доступность регистров;
􀂈 организацию и способы адресации памяти;
􀂈 способы представления и форматы данных ЭВМ;
􀂈 набор машинных команд ЭВМ;
􀂈 форматы машинных команд;
􀂈 обработку нештатных ситуаций (прерываний).
В рамках данной книги мы, в основном, будем рассматривать перечисленные
выше вопросы.
2.1. Командный цикл процессора
Командой называется элементарное действие, которое может выполнить про-
цессор без дальнейшей детализации. Последовательность команд, выполнение
которых приводит к достижению определенной цели, называется программой.
Глава 2. Функциональная организация ЭВМ 17
Команды программы кодируются двоичными словами и размещаются в памя-
ти ЭВМ. Вся работа ЭВМ состоит в последовательном выполнении команд
программы. Действия по выбору из памяти и выполнению одной команды
называются командным циклом.
В составе любого процессора имеется специальная ячейка, которая хранит
адрес выполняемой команды — счетчик команд или программный счетчик.
После выполнения очередной команды его значение увеличивается на еди-
ницу (если код одной команды занимает несколько ячеек памяти, то содер-
жимое счетчика команд увеличивается на длину команды). Таким образом
осуществляется выполнение последовательности команд. Существуют спе-
циальные команды (передачи управления), которые в процессе своего вы-
полнения модифицируют содержимое программного счетчика, обеспечивая
переходы по программе. Сама выполняемая команда помещается в регистр
команд — специальную ячейку процессора.
Во время выполнения командного цикла процессор реализует такую после-
довательность действий:
1. Извлечение из памяти содержимого ячейки, адрес которой хранится
в программном счетчике, и размещение этого кода в регистре команд
(чтение команды).
2. Увеличение содержимого программного счетчика на единицу.
3. Формирование адреса операндов.
4. Извлечение операндов из памяти.
5. Выполнение заданной в команде операции.
6. Размещение результата операции в памяти.
7. Переход к п. 1.
Пункты 1, 2 и 7 обязательно выполняются в каждом командном цикле, ос-
тальные могут не выполняться в некоторых командах. Если длина кода ко-
манды составляет несколько машинных слов, то пп. 1 и 2 повторяются.
Фактически вся работа процессора заключается в циклическом выполнении
пунктов 1—7 командного цикла. При запуске машины в счетчик команд ап-
паратно помещается фиксированное значение — начальный адрес програм-
мы (часто 0 или последний адрес памяти; встречаются и более экзотические
способы загрузки начального адреса). В дальнейшем содержимое программ-
ного счетчика модифицируется в командном цикле. Прекращение выполне-
ния командных циклов может произойти только при выполнении специаль-
ной команды "СТОП".
18 Часть I. Принципы организации ЭВМ
2.2. Система команд процессора
Разнообразие типов данных, форм их представления и действий, которые
необходимы для обработки информации и управления ходом вычислений,
порождает необходимость использования различных команд — набора ко-
манд. Каждый процессор имеет собственный вполне определенный набор
команд, называемый системой команд процессора. Система команд должна
обладать двумя свойствами — функциональной полнотой и эффектив-
ностью.
Функциональная полнота — это достаточность системы команд для описа-
ния любого алгоритма. Требование функциональной полноты не является
слишком жестким. Доказано, что свойством функциональной полноты обла-
дает система, включающая всего три команды (система Поста): присвоение 0,
присвоение 1, проверка на 0. Однако составление программ в такой системе
команд крайне неэффективно.
Эффективность системы команд — степень соответствия системы команд
назначению ЭВМ, т. е. классу алгоритмов, для выполнения которых предна-
значается ЭВМ, а также требованиям к производительности ЭВМ. Очевидно,
что реализация развитой системы команд связана с большими затратами обо-
рудования и, следовательно, с высокой стоимостью процессора. В то же вре-
мя ограниченный набор команд приводит к снижению производительности
и повышенным требованиям к памяти для размещения программы. Даже
простые и дешевые современные микропроцессоры поддерживают систему
команд, содержащую несколько десятков (а с модификациями — сотен)
команд.
Система команд процессора характеризуется тремя аспектами: форматами,
способами адресации и системой операций.
2.2.1. Форматы команд
Под форматом команды следует понимать длину команды, количество, раз-
мер, положение, назначение и способ кодировки ее полей.
Команды, как и любая информация в ЭВМ, кодируются двоичными словами,
которые должны содержать в себе следующие виды информации:
􀂈 тип операции, которую следует реализовать в данной команде (КОП);
􀂈 место в памяти, откуда следует взять первый операнд (А1);
􀂈 место в памяти, откуда следует взять второй операнд (А2);
􀂈 место в памяти, куда следует поместить результат (A3).
Глава 2. Функциональная организация ЭВМ 19
Каждому из этих видов информации соответствует своя часть двоичного сло-
ва — поле, а совокупность полей (их длины, расположение в командном слове,
способ кодирования информации) называется форматом команды. В свою
очередь, некоторые поля команды могут делиться на подполя. Формат
команды, поля которого перечислены выше, называется трехадресным
(рис. 2.1, а).
а
б
в
г
Рис. 2.1. Форматы команд: а — трехадресный; б — двухадресный;
в — одноадресный; г — безадресный
Команды трехадресного формата занимают много места в памяти, в то же
время далеко не всегда поля адресов используются в командах эффективно.
Действительно, наряду с двухместными операциями (сложение, деление,
конъюнкция и др.) встречаются и одноместные (инверсия, сдвиг, инкремент
и др.), для которых третий адрес не нужен. При выполнении цепочки вычис-
лений часто результат предыдущей операции используется в качестве опе-
ранда для следующей. Более того, нередко встречаются команды, для кото-
рых операнды не определены (СТОП) или подразумеваются самим кодом
операций (DAA, десятичная коррекция аккумулятора).
Поэтому в системах команд реальных ЭВМ трехадресные команды встреча-
ются редко. Чаще используются двухадресные команды (рис. 2.1, б), в этом
случае в бинарных операциях результат помещается на место одного из опе-
рандов.
Для реализации одноадресных форматов (рис. 2.1, в) в процессоре преду-
сматривают специальную ячейку — аккумулятор. Первый операнд и резуль-
тат всегда размещаются в аккумуляторе, а второй операнд адресуется
полем А.
Реальная система команд обычно имеет команды нескольких форматов, при-
чем тип формата определяется в поле КОП.
20 Часть I. Принципы организации ЭВМ
2.2.2. Способы адресации
Способ адресации определяет, каким образом следует использовать инфор-
мацию, размещенную в поле адреса команды.
Не следует думать, что во всех случаях в поле адреса команды помещается
адрес операнда. Существует пять основных способов адресации операндов
в командах.
􀂈 Прямая — в этом случае в адресном поле располагается адрес операнда.
Разновидность — прямая регистровая адресация, адресующая не ячейку
памяти, а РОН. Поле адреса регистра имеет в команде значительно мень-
шую длину, чем поле адреса памяти.
􀂈 Непосредственная — в поле адреса команды располагается не адрес опе-
ранда, а сам операнд. Такой способ удобно использовать в командах
с константами.
􀂈 Косвенная — в поле адреса команды располагается адрес ячейки памяти,
в которой хранится адрес операнда ("адрес адреса"). Такой способ позво-
ляет оперировать адресами как данными, что облегчает организацию цик-
лов, обработку массивов данных и др. Его основной недостаток — потеря
времени на двойное обращение к памяти — сначала за адресом, потом —
за операндом. Разновидность — косвенно-регистровая адресация, при ко-
торой в поле команды размещается адрес РОН, хранящего адрес операнда.
Этот способ, помимо преимущества обычной косвенной адресации, по-
зволяет обращаться к большой памяти с помощью коротких команд и не
требует двойного обращения к памяти (обращение к регистру занимает
гораздо меньше времени, чем к памяти).
􀂈 Относительная — адрес формируется как сумма двух слагаемых: базы,
хранящейся в специальном регистре или в одном из РОН, и смещения, из-
влекаемого из поля адреса команды. Этот способ позволяет сократить
длину команды (смещение может быть укороченным, правда в этом слу-
чае не вся память доступна в команде) и/или перемещать адресуемые мас-
сивы информации по памяти (изменяя базу). Разновидности — индексная
и базово-индексная адресации. Индексная адресация предполагает нали-
чие индексного регистра вместо базового. При каждом обращении содер-
жимое индексного регистра автоматически модифицируется (обычно уве-
личивается или уменьшается на 1). Базово-индексная адресация
формирует адрес операнда как сумму трех слагаемых: базы, индекса
и смещения.
􀂈 Безадресная — поле адреса в команде отсутствует, а адрес операнда или
не имеет смысла для данной команды, или подразумевается по умолча-
Глава 2. Функциональная организация ЭВМ 21
нию. Часто безадресные команды подразумевают действия над содержи-
мым аккумулятора. Характерно, что безадресные команды нельзя приме-
нить к другим регистрам или ячейкам памяти.
Одной из разновидностей безадресного обращения является использова-
ние так называемой магазинной памяти или стека. Обращение к такой
памяти напоминает обращение с магазином стрелкового оружия. Имеется
фиксированная ячейка, называемая верхушкой стека. При чтении слово
извлекается из верхушки, а все остальное содержимое "поднимается
вверх" подобно патронам в магазине, так что в верхушке оказывается сле-
дующее по порядку слово. Одно слово нельзя прочитать из стека дважды.
При записи новое слово помещается в верхушку стека, а все остальное со-
держимое "опускается вниз" на одну позицию. Таким образом, слово, по-
мещенное в стек первым, будет прочитано последним. Говорят, что стек
поддерживает дисциплину LIFO — Last In First Out (последний пришел —
первый ушел). Реже используется безадресная память типа очередь с дис-
циплиной FIFO — First In First Out (первый пришел — первый ушел).
2.2.3. Система операций
Все операции, выполняемые в командах ЭВМ, принято делить на пять
классов.
􀂈 Арифметико-логические и специальные — команды, в которых выполня-
ется собственно преобразование информации. К ним относятся арифмети-
ческие операции: сложение, вычитание, умножение и деление (с фиксиро-
ванной и плавающей занятой), команды десятичной арифметики,
логические операции конъюнкции, дизъюнкции, инверсии и др., сдвиги,
преобразование чисел из одной системы счисления в другую и такие экзо-
тические, как извлечение корня, решение системы уравнений и др. Конеч-
но, очень редко встречаются ЭВМ, система команд которых включает все
эти команды.
􀂈 Пересылки и загрузки — обеспечивают передачу информации между про-
цессором и памятью или между различными уровнями памяти
(СОЗУ↔ОЗУ). Разновидность — загрузка регистров и ячеек констан-
тами.
􀂈 Ввода/вывода — обеспечивают передачу информации между процессором
и внешними устройствами. По структуре они очень похожи на команды
предыдущего класса. В некоторых ЭВМ принципиально отсутствует раз-
личие между ячейками памяти и регистрами внешних устройств (единое
адресное пространство) и класс команд ввода/вывода не выделяется, все
обмены осуществляются в рамках команд пересылки и загрузки.
22 Часть I. Принципы организации ЭВМ
􀂈 Передачи управления — команды, которые изменяют естественный поря-
док выполнения команд программы. Эти команды меняют содержимое
программного счетчика, обеспечивая переходы по программе. Существу-
ют команды безусловной и условной передачи управления. В последнем
случае передача управления происходит, если выполняется заданное в ко-
де команды условие, иначе выполняется следующая по порядку команда.
В качестве условий обычно используются признаки результата предыду-
щей операции, которые хранятся в специальном регистре признаков
(флажков). Чаще всего формируются и проверяются признаки нулевого
результата, отрицательного результата, наличия переноса из старшего
разряда, четности числа единиц в результате и др. Различают три разно-
видности команд передачи управления:
• переходы;
• вызовы подпрограмм;
• возвраты из подпрограмм.
Команды переходов помещают в программный счетчик содержимое сво-
его адресного поля — адрес перехода. При этом старое значение про-
граммного счетчика теряется. В микроЭВМ часто для экономии длины
адресного поля команд условных переходов адрес перехода формируется
как сумма текущего значения программного счетчика и относительно ко-
роткого знакового смещения, размещаемого в команде. В крайнем случае,
в командах условных переходов можно и вовсе обойтись без адресной
части — при выполнении условия команда "перепрыгивает" через сле-
дующую команду, которой обычно является безусловный переход.
Команда вызова подпрограммы работает подобно команде безусловного
перехода, но старое значение программного счетчика предварительно со-
храняется в специальном регистре или в стеке. Команда возврата передает
содержимое верхушки стека или специального регистра в программный
счетчик. Команды вызова и возврата работают "в паре". Подпрограмма,
вызываемая командой вызова, должна заканчиваться командой возврата,
что обеспечивает по окончании работы подпрограммы передачу управле-
ния в точку вызова. Хранение адресов возврата в стеке обеспечивает воз-
можность реализации вложенных подпрограмм.
􀂈 Системные — команды, выполняющие управление процессом обработки
информации и внутренними ресурсами процессора. К таким командам от-
носятся команды управления подсистемой прерывания, команды установ-
ки и изменения параметров защиты памяти, команда останова программы
и некоторые другие. В простых процессорах класс системных команд
немногочисленный, а в сложных мультипрограммных системах преду-
сматривается большое число системных команд.
Глава 3
Арифметические основы ЭВМ
Безусловно, одним из основных направлений применения компьютеров были
и остаются разнообразные вычисления. Обработка числовой информации
ведется и при решении задач, на первый взгляд не связанных с какими-то
расчетами, например, при использовании компьютерной графики или звука.
В связи с этим встает вопрос о выборе оптимального представления чисел
в компьютере. Безусловно, можно было бы использовать 8-битное (байтовое)
кодирование отдельных цифр, а из них составлять числа. Однако такое коди-
рование не будет оптимальным, что легко увидеть из простого примера.
Пусть имеется двузначное число 13. При 8-битном кодировании отдельных
цифр в кодах ASCII его представление выглядит следующим образом:
0011000100110011, т. е. код имеет длину 16 битов; если же определять это
число просто в двоичном коде, то получим 4-битную цепочку 1101.
Важно, что представление определяет не только способ записи данных (букв
или чисел), но и допустимый набор операций над ними; в частности, буквы
могут быть только помещены в некоторую последовательность (или исклю-
чены из нее) без изменения их самих; над числами же возможны операции,
изменяющие само число, например, извлечение корня или сложение с другим
числом.
Представление чисел в компьютере имеет две особенности:
􀂈 числа записываются в двоичной системе счисления (в отличие от привыч-
ной десятичной);
􀂈 для записи и обработки чисел отводится конечное количество разрядов
(в "некомпьютерной" арифметике такое ограничение отсутствует).
Следствия, к которым приводят эти отличия, и рассматриваются в данной
главе.
24 Часть I. Принципы организации ЭВМ
3.1. Системы счисления
Начнем с некоторых общих замечаний относительно понятия "число" [10].
Можно считать, что любое число имеет значение (содержание) и форму
представления.
Значение числа задает его отношение к значениям других чисел ("больше",
"меньше", "равно") и, следовательно, порядок расположения чисел на число-
вой оси. Форма представления, как следует из названия, определяет порядок
записи числа с помощью предназначенных для этого знаков. При этом значе-
ние числа является инвариантом, т. е. не зависит от способа его представле-
ния. Это означает также, что число с одним и тем же значением может быть
записано по-разному, т. е. отсутствует взаимно однозначное соответствие
между представлением числа и его значением.
В связи с этим возникают вопросы, во-первых, о формах представления
чисел и, во-вторых, о возможности и способах перехода от одной формы
к другой.
Способ представления числа определяется системой счисления.
Определение
Система счисления — это правило записи чисел с помощью заданного набора
специальных знаков — цифр.
Людьми использовались различные способы записи чисел, которые можно
объединить в несколько групп: унарная, непозиционные и позиционные.
Унарная — это система счисления, в которой для записи чисел используется
только один знак — | (вертикальная черта, палочка). Следующее число полу-
чается из предыдущего добавлением новой палочки: их количество (сумма)
равно самому числу. Унарная система важна в теоретическом отношении,
поскольку в ней число представляется наиболее простым способом и, следо-
вательно, просты операции с ним. Кроме того, именно унарная система опре-
деляет значение целого числа количеством содержащихся в нем единиц, ко-
торое, как было сказано, не зависит от формы представления.
Из непозиционных наиболее распространенной можно считать римскую сис-
тему счисления. В ней некоторые базовые числа обозначены заглавными ла-
тинскими буквами: 1 — I, 5 — V, 10 — X, 50 — L, 100 — С, 500 — D,
1000 — М. Все другие числа строятся комбинацией базовых в соответствии
со следующими правилами:
􀂈 если цифра меньшего значения стоит справа от большей цифры, то их
значения суммируются; если слева — то меньшее значение вычитается из
большего;
Глава 3. Арифметические основы ЭВМ 25
􀂈 цифры I, X, С и М могут следовать подряд не более трех раз каждая;
􀂈 цифры V, L и D могут использоваться в записи числа не более одного
раза.
Например, запись XIX соответствует числу 19, MDXLIX — числу 1549.
Запись чисел в такой системе громоздка и неудобна, но еще более неудоб-
ным оказывается выполнение в ней даже самых простых арифметических
операций. Отсутствие нуля и знаков для чисел больше М не позволяют рим-
скими цифрами записать любое число (хотя бы натуральное). По указанным
причинам теперь римская система используется лишь для нумерации.
В настоящее время для представления чисел применяют, в основном, позици-
онные системы счисления.
Определение
Позиционными называются системы счисления, в которых значение каждой
цифры в изображении числа определяется ее положением (позицией) в ряду
других цифр.
Наиболее распространенной и привычной является система счисления, в ко-
торой для записи чисел используется 10 цифр: 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9. Число
представляет собой краткую запись многочлена, в который входят степени
некоторого другого числа — основания системы счисления. Например:
575,15 = 5⋅102 + 7 ⋅101 + 5⋅100 +1⋅10−1 + 5⋅10−2 .
В данном числе цифра 5 встречается трижды, однако значение этих цифр
различно и определяется их положением (позицией) в числе. Количество
цифр для построения чисел, очевидно, равно основанию системы счисле-
ния. Также очевидно, что максимальная цифра на 1 меньше основания.
Причина широкого распространения именно десятичной системы счисле-
ния понятна — она происходит от унарной системы с пальцами рук в каче-
стве "палочек".
Однако в истории человечества имеются свидетельства использования и дру-
гих систем счисления — пятеричной, шестеричной, двенадцатеричной, двад-
цатеричной и даже шестидесятеричной. Общим для унарной и римской сис-
тем счисления является то, что значение числа в них определяется
посредством операций сложения и вычитания базисных цифр, из которых
составлено число, независимо от их позиции в числе. Такие системы получи-
ли название аддитивных.
В отличие от них позиционное представление следует считать аддитивно-
мультипликативным, поскольку значение числа определяется операциями
26 Часть I. Принципы организации ЭВМ
умножения и сложения. Главной же особенностью позиционного представ-
ления является то, что в нем посредством конечного набора знаков (цифр,
разделителя десятичных разрядов и обозначения знака числа) можно запи-
сать неограниченное количество различных чисел. Кроме того, в позицион-
ных системах гораздо легче, чем в аддитивных, осуществляются операции
умножения и деления. Именно эти обстоятельства обуславливают доминиро-
вание позиционных систем при обработке чисел как человеком, так и компь-
ютером.
По принципу, положенному в основу десятичной системы счисления, оче-
видно, можно построить системы с иным основанием. Пусть p — основание
системы счисления. Тогда любое число Z (пока ограничимся только целыми
числами), удовлетворяющее условию Z < pk ( k > 0 , целое), может быть
представлено в виде многочлена со степенями (при этом, очевидно, макси-
мальный показатель степени будет равен k −1):
Σ −
=
−
−
−
= − ⋅ + ⋅ + + ⋅ + ⋅ = ⋅
1
1
0
0
1
1
2
2
1
1
k
j
j
j
k
k
k
Z p ak p a p … a p a p a p . (3.1)
Из коэффициентов a j при степенях основания строится сокращенная запись
числа:
Z p = (ak−1ak−2…a1a0 ).
Индекс p числа Z указывает, что оно записано в системе счисления с осно-
ванием p : общее число цифр числа равно k . Все коэффициенты a j — це-
лые числа, удовлетворяющие условию: 0 < a j < p −1 .
Уместно задаться вопросом: каково минимальное значение p ? Очевидно,
p = 1 невозможно, поскольку тогда все a j = 0 и форма (3.1) теряет смысл.
Первое допустимое значение p = 2 — оно и является минимальным для по-
зиционных систем.
Система счисления с основанием 2 называется двоичной. Цифрами двоичной
системы являются 0 и 1, а форма (3.1) строится по степеням 2. Интерес имен-
но к этой системе счисления связан с тем, что, как указывалось ранее, любая
информация в компьютерах представляется с помощью двух состояний —
0 и 1, которые легко реализуются технически.
Наряду с двоичной в компьютерах используются восьмеричная и шестнадца-
теричная системы счисления — причины будут рассмотрены далее.
Глава 3. Арифметические основы ЭВМ 27
3.2. Представление чисел
в различных системах счисления
Очевидно, что значение целого числа, т. е. общее количество входящих в не-
го единиц, не зависит от способа его представления и остается одинаковым
во всех системах счисления; различаются только формы представления од-
ного и того же количественного содержания числа.
Например: |||||1= 510 =1012 = 516 .
Поскольку одно и то же число может быть записано в различных системах
счисления, встает вопрос о переводе представления числа из одной системы
в другую.
3.2.1. Перевод целых чисел
из одной системы счисления в другую
Обозначим преобразование числа Z , представленного в p -ричной системе
счисления в представление в q -ричной системе как Z p →Zq . Теоретически
возможно произвести его при любых q и p . Однако подобный прямой пе-
ревод будет затруднен тем, что придется выполнять операции по правилам
арифметики недесятичных систем счисления (полагая в общем случае,
что p , q ≠ 10 ).
По этой причине более удобными с практической точки зрения оказыва-
ются варианты преобразования с промежуточным переводом Z p → Zr → Zq
с основанием r , для которого арифметические операции выполнить легко.
Такими удобными основаниями являются r = 1 и r = 10 , т. е. перевод осу-
ществляется через унарную или десятичную систему счисления.
Преобразование Zp → Z1 → Zq
Идея алгоритма перевода предельно проста: положим начальное значение
Zq := 0 ; из числа Z p вычтем 1 по правилам вычитания системы p , т. е.
Z p := Z p −1, и добавим ее к Zq по правилам сложения системы q , т. е.
Zq := Zq +1 . Будем повторять эту последовательность действий, пока не
достигнем Z p = 0 . Правила сложения с 1 (инкремента) и вычитания 1 (дек-
ремента) могут быть записаны так, как представлено в табл. 3.1.
28 Часть I. Принципы организации ЭВМ
Таблица 3.1. Правила сложения и вычитания 1
Для системы p Для системы q
( p −1) −1 = p − 2 0 +1 =1
( p − 2) −1 = p − 3 1+1 = 2
... ...
1−1 = 0 (q − 2) +1 = q −1
0 −1 = π( p −1) (q −1) +1 = π.0
Примечание: π — перенос в случае инкремента или заем в случае декремента.
Промежуточный переход к унарной системе счисления в данном случае
осуществляется неявно — используется упоминавшееся ранее свойство неза-
висимости значения числа от формы его представления. Рассмотренный
алгоритм перевода может быть легко реализован программным путем.
Преобразование Zp → Zw → Zq
Очевидно, первая и вторая часть преобразования не связаны друг с другом,
что дает основание рассматривать их по отдельности. Алгоритмы перевода
Zw →Zq вытекают из следующих соображений. Многочлен (3.1) для Zq
может быть представлен в виде:
1 2 3 1 0
1
0
Z b q (( (bm q bm ) q bm ) q b ) q b
m
j
j
q = j ⋅ = − ⋅ + − ⋅ + − ⋅ + + ⋅ +
−
= Σ
… … , (3.2)
где m — число разрядов в записи Z p , a b j ( j = 0, ..., m −1) — цифры чис-
ла Zq .
Разделим число Zq на две части по разряду номер i . Число, включающее
m − i разрядов с (m− i) -го по i -й, обозначим γi , а число с i разрядами
с (i −1) -го по 0-й — δi . Очевидно, i∈[0, m −1], γ0 = δm−1 = Zq .
(􀀈􀀋1􀀋􀀉2􀀋…􀀋􀀊􀀈􀀋1…􀀉􀀋1􀀊0 )
i i
Zq bm bm bi bi b b
δ
−
γ
= − − .
Позаимствуем из языка PASCAL обозначение двух операций: div — ре-
зультат целочисленного деления двух целых чисел и mod — остаток от це-
лочисленного деления (13 div 4 = 3; 13 mod 4 = 1).
Глава 3. Арифметические основы ЭВМ 29
Теперь если принять γm−1 = bm−1 , то в (3.2) усматривается следующее ре-
куррентное соотношение: γi = γi+1 + bi , из которого, в свою очередь, полу-
чаются выражения:
γi+1 = γi div q ; bi = γi mod q . (3.3)
Аналогично, если принять δ0 = b0 , то для правой части числа будет спра-
ведливо другое рекуррентное соотношение: i
δi = δi−1 + biq , из которого
следуют:
i
bi = δi div q ; i
δi−1 = δi mod q . (3.4)
Из соотношений (3.3) и (3.4) непосредственно вытекают два способа пере-
вода целых чисел из десятичной системы счисления в систему с произ-
вольным основанием q .
Способ 1 является следствием соотношений (3.3), предполагающий сле-
дующий алгоритм перевода:
1. Целочисленно разделить исходное число ( Z10 ) на основании новой сис-
темы счисления ( q ) и найти остаток от деления — это будет цифра 0-го
разряда числа Zq .
2. Частное от деления снова целочисленно разделить на q с выделением
остатка; процедуру продолжать до тех нор, пока частное от деления не
окажется меньше q .
3. Образовавшиеся остатки от деления, поставленные в порядке, обратном
порядку их получения, и представляют Zq .
Пример 3.1
Выполнить преобразование 12310 → Z5 . Результат — на рис. 3.1.
123 5
120 24 5
3 20 4
4
Рис. 3.1. Результат выполнения примера 3.1
30 Часть I. Принципы организации ЭВМ
Остатки от деления (3, 4) и результат последнего целочисленного деле-
ния (4) образуют обратный порядок цифр нового числа. Следовательно,
12310 = 4435 .
Необходимо заметить, что полученное число нельзя читать как "четыреста
сорок три", поскольку десятки, сотни, тысячи и прочие подобные обозначе-
ния чисел относятся только к десятичной системе счисления. Прочитывать
число следует простым перечислением его цифр с указанием системы счис-
ления ("число четыре, четыре, три в пятеричной системе счисления").
Способ 2 вытекает из соотношения (3.4), действия производятся в соответ-
ствии со следующим алгоритмом:
1. Определить m −1 — максимальный показатель степени в представлении
числа по форме (3.1) для основания q .
2. Целочисленно разделить исходное число ( Z10 ) на основание новой систе-
мы счисления в степени m −1 (т. е. qm−1 ) и найти остаток от деления; ре-
зультат деления определит первую цифру числа Zq .
3. Остаток от деления целочисленно разделить на g m−2 , результат деления
принять за вторую цифру нового числа; найти остаток; продолжать эту
последовательность действий, пока показатель степени q не достигнет
значения 0.
Продемонстрируем действие алгоритма на той же задаче, что была рассмот-
рена выше.
Определить m −1 можно либо путем подбора ( 50 = 1<123 ; 51 = 5 < 123;
52 = 25 <123; 53 =125 >123, следовательно, m −1 = 2 ), либо логарифмиро-
ванием с оставлением целой части логарифма ( log5 123 = 2,99 , т. е.
m −1 = 2 ).
Далее:
123 div 52 4
b2 = = 23mod 5 23 2
δ1 = = i = 2 −1 = 1
23 div 51 4
b1 = = 23 mod 5 3 1
δ0 = = i = 0
Алгоритмы перевода Zg →Zw явно вытекают из представлений (3.1) или
(3.2): необходимо Z p представить в форме многочлена и выполнить все опе-
рации по правилам десятичной арифметики.
Глава 3. Арифметические основы ЭВМ 31
Пример 3.2
Выполнить преобразование 4435 → Z10 .
Решение:
10
2 1 0
4435 = 4⋅5 + 4⋅5 + 3⋅5 = 4 ⋅ 25 + 4⋅5 + 3⋅1 = 123 .
Необходимо еще раз подчеркнуть, что приведенными алгоритмами удобно
пользоваться при переводе числа из десятичной системы в какую-то иную
или наоборот. Они работают и для перевода между любыми иными система-
ми счисления, однако преобразование будет затруднено тем, что все арифме-
тические операции необходимо осуществлять по правилам исходной (в пер-
вых алгоритмах) или конечной (в последнем алгоритме) системы счисления.
По этой причине переход, например, Z3 → Z8 проще осуществить через
промежуточное преобразование к десятичной системе Z3 →Z10 →Z8 . Си-
туация, однако, значительно упрощается, если основания исходной и конеч-
ной систем счисления оказываются связанными соотношением p = qr , где
r — целое число (естественно, большее 1) или r = 1 n ( n > 1, целое) — эти
случаи будут рассмотрены далее.
3.2.2. Перевод дробных чисел
из одной системы счисления в другую
Вещественное число, в общем случае содержащее целую и дробную части,
всегда можно представить в виде суммы целого числа и правильной дроби.
Поскольку в предыдущем разделе проблема записи натуральных чисел в раз-
личных системах счисления уже была решена, можно ограничить рассмотре-
ние только алгоритмами перевода правильных дробей.
Введем следующие обозначения: правильную дробь в исходной системе
счисления p будем записывать в виде 0,Yp , дробь в системе q — 0,Yq ,
а преобразование — в виде 0,Yp →0,Yq .
Последовательность рассуждений весьма напоминает проведенную ранее для
натуральных чисел. В частности, это касается рекомендации осуществлять
преобразование через промежуточный переход к десятичной системе, чтобы
избежать необходимости производить вычисления в "непривычных" систе-
мах счисления, т. е. 0,Yp →0,Y10 →0,Yq .
32 Часть I. Принципы организации ЭВМ
Это, в свою очередь, разбивает задачу на две составляющие: преобразова-
ние 0,Yp →0,Y10 и 0,Y10 →0,Yq , каждое из которых может рассматриваться
независимо.
Алгоритмы перевода 0,Y10 →0,Yq выводятся путем следующих рассужде-
ний. Если основание системы счисления q , простая дробь содержит n цифр,
и bk — цифры дроби (1 < bk < n , 0 < bk < n −1), то она может быть пред-
ставлена в виде суммы:
) ),
1
(
1
(
1
(
1
0, 1 2 1
1
… n n …
n
k
k
q k b
q
b
q
b
q
b
q
Y = b ⋅ q = + + + − +
=
Σ − (3.5)
0, (0, 1 1…􀀈􀀋􀀉1…􀀋􀀊).
i
Yq b b bibi bn
ε
= +
Часть дроби от разряда i до ее конца обозначим εi и примем εn = bn q .
Очевидно, ε1 = 0,Yq , тогда в (3.5) легко усматривается рекуррентное соот-
ношение:
( ).
1
εi = bi + εi+1
q
(3.6)
Если вновь позаимствовать в PASCAL обозначение функции — на этот раз
trunc, производящей округление вещественного числа путем отбрасывания
его дробной части, то следствием (3.6) будут соотношения, позволяющие на-
ходить цифры новой дроби:
bi = trunc(q ⋅ εi ) ; εi+1 = q ⋅ εi − trunc(q ⋅ εi ) . (3.7)
Соотношения (3.7) задают алгоритм преобразования: 0,Y10 →0,Yq :
1. Умножить исходную дробь в десятичной системе счисления на q , выде-
лить целую часть — она будет первой (старшей) цифрой новой дроби; от-
бросить целую часть.
2. Для оставшейся дробной части операцию умножения с выделением целой
и дробных частей повторять, пока в дробной части не окажется 0 или не
будет достигнута желаемая точность конечного числа; появляющиеся при
этом целые будут цифрами новой дроби.
3. Записать дробь в виде последовательности цифр после нуля с разделите-
лем в порядке их появления в пп. 1 и 2.
Глава 3. Арифметические основы ЭВМ 33
Пример 3.3
Выполнить преобразование 0,37510 →0,Y2 . Результат — на рис. 3.2.
Таким образом, 0,37510 →0,0112 .
0,375 × 2 = 0, 750
0,75 × 2 = 1, 50
0,5 × 2 = 1, 0
Рис. 3.2. Результат выполнения примера 3.3
Перевод 0,Yp →0,Y10 , как и в случае натуральных чисел, сводится к вычис-
лению значения формы (3.5) в десятичной системе счисления. Например:
10
1 2 3
0,0112 = 0 ⋅ 2 +1⋅ 2 +1⋅ 2 = 0 + 0,25 + 0,125 = 0,375 − − − .
Следует сознавать, что после перевода дроби, которая была конечной в ис-
ходной системе счисления, она может оказаться бесконечной в новой систе-
ме. Соответственно, рациональное число в исходной системе может после
перехода превратиться в иррациональное. Справедливо и обратное утвер-
ждение: число иррациональное в исходной системе счисления в иной системе
может оказаться рациональным.
Пример 3.4
Выполнить преобразование 5,3(3)10 →Y8 .
Перевод целой части, очевидно, дает: 510 = 123 . Перевод дробной части:
0,3(3)10 →0,1. Окончательно: 5,3(3)10 →12,13 .
Как уже было сказано, значение целого числа не зависит от формы его пред-
ставления и выражает количество входящих в него единиц. Простая дробь
имеет смысл доли единицы, и это "дольное" содержание также не зависит от
выбора способа представления. Другими словами, треть пирога остается тре-
тью в любой системе счисления.
34 Часть I. Принципы организации ЭВМ
3.2.3. Перевод чисел
между системами счисления 2 ↔ 8 ↔ 16
Интерес к двоичной системе счисления вызван тем, что именно она исполь-
зуется для представления чисел в компьютере. Однако двоичная запись ока-
зывается громоздкой, поскольку содержит много цифр и, кроме того, плохо
воспринимается и запоминается человеком из-за зрительной однородности
(все число состоит из нулей и единиц). Поэтому в нумерации ячеек памяти
компьютера, записи кодов команд, нумерации регистров и устройств и пр.
используются системы счисления с основаниями 8 и 16. Выбор именно этих
систем счисления обусловлен тем, что переход от них к двоичной системе
и обратно осуществляется, как будет показано далее, весьма простым образом.
Двоичная система счисления имеет основание 2 и, соответственно, две
цифры: 0 и 1.
Восьмеричная система счисления имеет основание 8 и цифры 0, 1, ..., 7.
Шестнадцатеричная система счисления имеет основание 16 и цифры 0,
1, ..., 9, А, В, С. D, Е, F. При этом знак А является шестнадцатеричной циф-
рой, соответствующей числу 10 в десятичной системе, B16 = 1110 ,
C16 =1210 , D16 = 1310 , E16 = 1410 и F16 =1510 . Другими словами, в данном
случае А, ..., F — это не буквы латинского алфавита, а цифры шестнадца-
теричной системы счисления.
Докажем две теоремы [10].
Теорема 1. Для преобразования целого числа Z p →Zq в том случае, если
системы счисления связаны соотношением q = pr , где r — целое число,
большее 1, достаточно Z p разбить справа налево на группы по r цифр и ка-
ждую из них независимо перевести в систему q .
Доказательство. Пусть максимальный показатель степени в записи числа p
по форме (3.1) равен k −1, причем 2r > k −1 > r .
( ) 0 .
0
1
1
2
2
1
Z a 1 a1a0 a 1 p a p a p a p k
k
k
p = k = k ⋅ + ⋅ + ⋅ + ⋅ −
−
−
− … − …
Вынесем множитель pr из всех слагаемых, у которых j ≥ r . Получим:
( ) ,
( )
0
0
1
1
0 0
0
1
1
2
1
1
1
1 0
1
2
2
1
1
a p a p a p a p p b q b q
Z a p a p a p a p p
r
r
r
r
r
r r
k r
k
k r
p k
+ ⋅ + ⋅ + ⋅ + ⋅ ⋅ = ⋅ + ⋅
= ⋅ + ⋅ + ⋅ + ⋅ ⋅ +
−
−
−
−
+
− −
−
− −
−
…
…
Глава 3. Арифметические основы ЭВМ 35
где
( ) .
( ) ,
1 0
0
0
1
1
2
1
1
0 1
1
1 0
1
2
2
1
1 1
r p
r
r
r
r
r r k r p
k r
k
k r
k
b a p a p a p a p a a
b a p a p a p a p a a
… …
… …
−
−
−
−
−
+ −
− −
−
− −
−
= ⋅ + ⋅ + ⋅ + ⋅ =
= ⋅ + ⋅ + ⋅ + ⋅ =
Таким образом, r -разрядные числа системы с основанием p оказываются за-
писанными как цифры системы с основанием q . Этот результат можно обоб-
щить на ситуацию произвольного k −1 > r — в этом случае выделятся не
две, а больше (m ) цифр числа с основанием q . Очевидно, Zq = (bm ... b0 )q .
Теорема 2. Для преобразования целого числа Z p → Zq в том случае,
если системы счисления связаны соотношением p = qr , где r — целое
число, большее 1, достаточно каждую цифру Z p заменить соответст-
вующим r -разрядным числом в системе счисления q , дополняя его при
необходимости незначащими нулями слева до группы в r цифр.
Доказательство. Пусть исходное число содержит две цифры, т. е.
( ) 0 .
0
1
Z p = a1a0 p = a1 ⋅ p + a ⋅ p
Для каждой цифры справедливо: 0 ≤ ai ≤ p −1, и поскольку p = qr ,
0 ≤ ≤ r −1
ai q , то в представлении этих цифр в системе счисления q мак-
симальная степень многочленов (3.1) будет не более r −1 и эти много-
члены будут содержать по r цифр:
; 0 ) 1 (
0
(1) 1
1
(1) 2
2
(1) 1
a1 b 1 q b q b q b q r
r
r
r = ⋅ + ⋅ − + + ⋅ + ⋅
−
−
− …
. 0 ) 0 (
0
(0) 1
1
(0) 2
2
(0) 1
a1 b 1 q b q b q b q r
r
r
r = ⋅ + ⋅ − + + ⋅ + ⋅
−
−
− …
Тогда
(1) 1 (1) 2 (1) 1 (1) 0 (0) 1
1 0 1 2 1 0 1
(0) 2 (0) 1 (0) 0 0 (1) 2 1 (1) 2 2
2 1 0 1 2
(1) 1 (1) (0) 1 (0) 2
1 0 1 2
(0)
1
( ) ( ) (
)
r r r r
p p r r r
r r r
r r r
r r r r
r r
Z aa b q b q b q b q q b q
b q b q b q q b q b q
b q b q b q b q
b
− − −
− − −
− − −
− − −
+ − −
− −
= = ⋅ + ⋅ + + ⋅ + ⋅ ⋅ + ⋅ +
+ ⋅ + + ⋅ + ⋅ ⋅ = ⋅ + ⋅ +
+ + ⋅ + ⋅ + ⋅ + ⋅ + +
+ ⋅
…
…
… …
1 (0) 0 (1) (1) (0) (0)
q + b0 ⋅ q = (br−1br−2…b1 b0 ) = Zq ,
причем число Zq содержит 2r цифр. Доказательство легко обобщается на
случай произвольного количества цифр в числе Z p .
36 Часть I. Принципы организации ЭВМ
3.2.4. Понятие экономичности системы счисления
Число в системе счисления с k разрядами, очевидно, будет иметь наиболь-
шее значение в том случае, если все цифры числа окажутся максимальными,
т. е. равными p −1. Тогда
( ) 1 1 1.
цифр
max = < − > < − > = k −
k
Z p p p p 􀀈􀀋􀀋􀀋􀀉…􀀋􀀋􀀋􀀊 (3.8)
Количество разрядов числа при переходе от одной системы счисления к дру-
гой в общем случае меняется.
Очевидно, если p = qσ ( σ — не обязательно целое), то
( )max = k −1 = σk −1
Z p p q ,
т. е. количество разрядов числа в системах счисления p и q будут разли-
чаться в σ раз, причем
q
p
log
log σ = . (3.9)
При этом основание логарифма никакого значения не имеет, поскольку σ
определяется отношением логарифмов. Сравним количество цифр в числе
9910 и его представлении в двоичной системе счисления: 9910 = 11000112 ,
т. е. двоичная запись требует 7 цифр вместо 2 в десятичной,
σ = log10 log 2 = 3,322 ; следовательно, количество цифр в десятичном пред-
ставлении нужно умножить на 3,322 и округлить в большую сторону:
2 ⋅3,322 = 6,644 ≈ 7 .
Введем понятие экономичности представления числа в данной системе счис-
ления [10].
Определение
Под экономичностью системы счисления будем понимать то количество чисел,
которое можно записать в данной системе с помощью определенного коли-
чества цифр.
Речь в данном случае идет не о количестве разрядов, а об общем количестве
сочетаний цифр, которые интерпретируются как различные числа. Поясним
на примере: пусть в распоряжении имеется 12 цифр. Можно разбить их на
6 групп по 2 цифры ("0" и "1") и получить шестиразрядное двоичное число;
общее количество таких чисел, как уже неоднократно обсуждалось, равно 26 .
Можно разбить заданное количество цифр на 4 группы по три цифры и вос-
Глава 3. Арифметические основы ЭВМ 37
пользоваться троичной системой счисления — в этом случае общее количе-
ство различных их сочетаний составит 34 . Аналогично можно произвести
другие разбиения; при этом число групп определит разрядность числа, а ко-
личество цифр в группе — основание системы счисления. Результаты раз-
личных разбиений можно проиллюстрировать табл. 3.2.
Таблица 3.2. Результаты разбиения цифр на группы
Параметр Значения
Основание системы
счисления ( p )
2 3 4 6 12
Разрядность числа ( k ) 6 4 3 2 1
Общее количество
различных чисел ( N )
26 = 64 34 = 81 43 = 64 62 = 36 121 =12
Из приведенных оценок видно, что наиболее экономичной оказывается тро-
ичная система счисления, причем результат будет тем же, если исследовать
случаи с другим исходным количеством сочетаний цифр.
Точное расположение максимума экономичности может быть установлено пу-
тем следующих рассуждений. Пусть имеется n знаков для записи чисел,
а основание системы счисления равно p . Тогда количество разрядов числа
k = n p , а общее количество чисел N , которые могут быть составлены,
равно:
p .
n
N = p (3.10)
Если считать N( p) непрерывной функцией, то можно найти такое значение
pm , при котором N принимает максимальное значение. Для нахождения
положения максимума нужно найти производную функции N( p) , прирав-
нять ее к нулю и решить полученное уравнение относительно p .
ln (1 ln ).
1 2
2 p n p p
p
n
p p
p
n
dp
dN p
n
p
n
p
n
= − ⋅ ⋅ + ⋅ = ⋅ ⋅ −
− −
(3.11)
Приравнивая полученное выражение к нулю, получаем ln p = 1, или pm = e ,
где e = 2,71828... — основание натурального логарифма. Ближайшее к e
целое число, очевидно, 3 — по этой причине троичная система счисления
38 Часть I. Принципы организации ЭВМ
оказывается самой экономичной для представления чисел, однако следую-
щей по экономичности оказывается двоичная система счисления.
Таким образом, простота технических решений — не единственный аргумент
в пользу применения двоичной системы в компьютерах.
3.3. Представление информации в ЭВМ.
Прямой код
В современных ЭВМ используются, в основном, два способа представления
двоичных чисел — с фиксированной и с плавающей запятой, причем в фор-
мате с фиксированной запятой (ФЗ) используется как беззнаковое представ-
ление чисел ("целое без знака"), так и представление чисел со знаком.
В последнем случае знак также кодируется двоичной цифрой — обычно
плюсу соответствует 0, а минусу — 1. Под код знака обычно отводится стар-
ший разряд a0 двоичного вектора a0a1a2...an , называемый знаковым.
Запятая может быть фиксирована после любого разряда двоичного числа,
однако чаще всего используются два формата ФЗ: целые числа, когда запятая
фиксируется после младшего разряда an , а диапазон представления лежит
в пределах
A ≤ 2n −1, (3.12)
и дробные числа — запятая фиксирована после a0 , а диапазон
A ≤ 1− 2−n. (3.13)
Далее, если не сделано специальных оговорок, будем рассматривать дробные
двоичные числа со знаком, запятая в которых фиксирована после знакового
разряда a0 :
a0 , a1a2a3…an . (3.14)
Очевидно, если двоичное число A = 0,a1a2a3…an > 0 , то оно будет представ-
лено в форме (3.14) как 0,a1a2a3…an , а если A = 0,a1a2a3…an < 0 , то как
1,a1a2a3…an . Приведенное кодирование дробных двоичных чисел со знаком
принято называть прямым кодом числа (обозначается как [ ]A d ). Итак
[ ]
⎩ ⎨ ⎧
+ <
≥
=
1 , если 0.
, если 0;
A A
A A
A d (3.15)
Глава 3. Арифметические основы ЭВМ 39
3.4. Алгебраическое сложение/вычитание
в прямом коде
Сформулируем правила выполнения операций сложения и вычитания чисел
со знаками (такие операции принято называть алгебраическими). Во-первых,
алгебраическое вычитание всегда можно свести к алгебраическому сложе-
нию, изменив знак второго операнда. Далее следует сравнить знаки слагае-
мых. При одинаковых знаках складывают модули слагаемых и результату
присваивают знак любого слагаемого (они одинаковые). Если знаки слагае-
мых разные, то из большего модуля слагаемого вычитают меньший модуль
и присваивают результату знак слагаемого, имеющего больший модуль.
Введем обозначения:
A = a0a1a2a3...an ,
B = b0b1b2b3...bn ,
C = A + B = c0c1c2...cn ,
где:
􀂈 a0 , b0 — знаковые разряды слагаемых;
􀂈 c0 — код знака результата;
􀂈 ai , bi , ci , i∈{0, 1, 2, ..., n} — двоичные переменные;
􀂈 f — тип выполняемой операции: f = 0 — сложение, f = 1 — вычитание;
􀂈 OV — признак переполнения,
и выразим сформулированный выше алгоритм алгебраического сложения/
вычитания в форме граф-схемы алгоритма (ГСА), приведенной на рис. 3.3.
Отдельно следует рассмотреть проблему обнаружения факта переполнения
разрядной сетки данных с фиксированной запятой. Это может произойти, если
C = A + B ≥ 1. (3.16)
Очевидно, при сложении чисел с разными знаками переполнение невозмож-
но. Если знаки слагаемых одинаковы, признаком переполнения может слу-
жить перенос, возникающий при сложении старших разрядов модулей
a1 + b1 . При отсутствии этого переноса сложение двух любых одинаковых
знаковых разрядов даст в результате c0 = 0 , а при появлении переноса из
первого разряда c0 =1 . Таким образом, после сложения чисел с одинаковыми
знаками значение знакового разряда суммы можно рассматривать как при-
знак переполнения OV .
40 Часть I. Принципы организации ЭВМ
Рис. 3.3. Граф алгоритма алгебраического сложения/вычитания
Характерно, что полученное в знаковом разряде c0 значение не является зна-
ком результата (алгебраической суммы). Истинное значение знака образуется
не в процессе арифметической операции над знаковыми разрядами, а форми-
руется искусственно.
Рассмотрим случай сложения чисел с разными знаками. Он сводится к вычи-
танию модулей слагаемых, причем уменьшаемым должен стать больший мо-
дуль. Чтобы избежать дополнительной модульной операции сравнения, мож-
но произвести "наугад" вычитание A − B . Признаком того, что A > B , будет
отсутствие заема из нулевого в первый разряд. Поскольку рассматривается
случай разных знаков слагаемых, то при отсутствии заема значение знаково-
го разряда разности определится как 0 −1 = 1− 0 = 1 , а при наличии заема
0 −1−1 =1− 0 −1 = 0 . Таким образом, если при вычитании A − B получим
Глава 3. Арифметические основы ЭВМ 41
c0 =1 , это будет означать, что A > B , и результату следует присвоить
знак числа A ( c0 := a0 ). Если окажется c0 = 0 , то A < B , и следует осуще-
ствить вычитание B − A , присвоив результату знак числа B ( c0 := b0 ).
3.5. Обратный код и выполнение
алгебраического сложения в нем
При выполнении алгебраического сложения в прямом коде приходится, во-
первых, не только складывать, но и вычитать двоичные коды; во-вторых, код
знака результата формируется искусственно, т. е. знаковые разряды обраба-
тываются по правилам, отличным от правил обработки разрядов числа. Для
устранения отмеченных недостатков в ЭВМ широко используются специаль-
ные представления двоичных чисел — так называемые обратный и допол-
нительный коды.
Представление обратного кода определяется следующим соотношением:
[ ]
⎩ ⎨ ⎧
+ − ≤
≥
= 2 2− , если 0.
, если 0;
A A
A A
A i n (3.17)
Из (3.17) следует, что обратный код положительного числа равен самому
числу! Для получения обратного кода отрицательного числа достаточно при-
своить знаковому разряду значение 1 и проинвертировать все остальные раз-
ряды числа:
[−0, a1a2…an ] i = 1, a1a2…an . (3.18)
Действительно, из (3.17) следует, что при A = −0, a1a2a3…an обратный код
числа [ ] n
A i A = 2 + − 2− . Откуда [ ] n
A i A − = 2 − 2− .
1,11 1 2 2 ,
1, 1 2 0, 1 2 (1 0),( 1 1)( 2 2 ) ( )
n
a a an a a an a a a a an an
= = − −
+ = + + + + =
…
… … …
учитывая, что (ai + ai ) = 1.
Для перехода из обратного кода в прямой осуществляется следующее преоб-
разование:
[1, a1a2…an ] i = 1, a1a2…an ,
т. е. [[ ] ] [ ]A i i = A d .
42 Часть I. Принципы организации ЭВМ
3.5.1. Алгебраическое сложение
в обратном коде
Очевидно, что при отсутствии переполнения возможны четыре случая соче-
тания знаков и модулей слагаемых [9].
􀂈 Случай 1.
A > 0 , B > 0 , A+ B <1 .
Этот случай соответствует обычному сложению прямых кодов чисел:
[A > 0]i + [B > 0]i = A+ B .
􀂈 Случай 2.
A > 0 , B < 0 , A+ B > 0 .
[ ] [ ] n
A i B i A B > 0 + < 0 = + 2 + − 2− . Назовем этот результат предваритель-
ным. Истинное значение результата в рассматриваемом случае (сумма по-
ложительна) будет A + B . Следовательно, предварительный результат
нуждается в коррекции путем вычитания 2 и добавления 2−n .
􀂈 Случай 3.
A > 0 , B < 0 , A+ B < 0 .
[ ] [ ] n
A i B i A B > 0 + < 0 = + 2 + − 2− . Этот результат соответствует правиль-
ному, поскольку рассматривается случай отрицательной суммы.
􀂈 Случай 4.
A < 0 , B < 0 , A+ B <1.
[ ] [ ] n n
A i B i A B < 0 + < 0 = 2 + − 2− + 2 + − 2− . Здесь предварительный ре-
зультат нуждается в коррекции путем вычитания 2 и добавления 2−n , как
и в случае 2, поскольку истинное значение отрицательной суммы, пред-
ставленной в обратном коде, равно A + B + 2 − 2−n .
Заметим, что в случаях 2 и 4 требуется одинаковая коррекция: − 2 + 2−n , при-
чем только в этих двух случаях возникает перенос из знакового разряда. Дейст-
вительно, в случае 4 оба знаковых разряда равны 1, а в случае 2 знак результа-
та — 0, что при разных знаках слагаемых может получиться только при
появлении переноса из первого разряда в нулевой (знаковый), а следовательно,
обязательно будет перенос и из знакового разряда. Вес знакового разряда соот-
ветствует 20 , а вес переноса из него — 21 . Таким образом, игнорируя перенос
из знакового разряда, мы вычитаем из результата 2, что соответствует перво-
Глава 3. Арифметические основы ЭВМ 43
му члену корректирующего выражения. Для учета второго члена следует доба-
вить 1 к младшему разряду суммы, вес которого составляет 2−n .
В случаях 1 и 3 переноса из знакового разряда не возникает и коррекция ре-
зультата не требуется.
Таким образом, для выполнения алгебраического сложения двоичных чисел,
представленных в обратном коде, достаточно, не анализируя соотношение
знаков и модулей, произвести сложение чисел, включая знаковые разряды, по
правилам двоичной арифметики, причем возникающий в знаковом разряде
перенос должен быть добавлен к младшему разряду результата, осуществляя
тем самым коррекцию предварительной суммы. Полученный код является
алгебраической суммой слагаемых, представленной в обратном коде.
Рассмотрим несколько примеров.
Пример 3.5
Сложить два числа в обратном коде. Результат — на рис. 3.4.
A = +0,1101 [A]d = 0,1101 [A]i = 0,1101
B = −0,0011 [B]d =1,0011 [B]i =1,1100
1 ← 0,1001
1
C = 0,1010 ⇐ [C]d = 0,1010 ⇐ [C]i = 0,1010
Рис. 3.4. Результат выполнения примера 3.5
Приведенный пример соответствует рассмотренному выше случаю 2; пере-
нос, возникающий в знаковом разряде, циклически передается в младший
разряд предварительного результата.
Пример 3.6
Сложить два числа в обратном коде (случай 3). Результат — на рис. 3.5.
A = −0,1101 [A]d =1,1101 [A]i =1,0010
B = +0,0011 [B]d = 0,0011 [B]i = 0,0011
C = −0,1010 ⇐ [C]d =1,1010 ⇐ [C]i =1,0101
Рис. 3.5. Результат выполнения примера 3.6
44 Часть I. Принципы организации ЭВМ
Пример 3.7
Сложить два числа в обратном коде (случай 4). Результат — на рис. 3.6.
A = −0,0101 [A]d =1,0101 [A]i =1,1010
B = −0,0110 [B]d =1,0110 [B]i =1,1001
1 ← 1,0011
1
C = −0,1011 ⇐ [C]d =1,1011 ⇐ [C]i =1,0100
Рис. 3.6. Результат выполнения примера 3.7
Пример 3.8
Сложить два числа в обратном коде (одинаковые модули, но разные знаки).
Результат — на рис. 3.7.
A = −0,0101 [A]d =1,0101 [A]i =1,1010
B = +0,0101 [B]d = 0,0101 [B]i = 0,0101
C = −0,0000 ⇐ [C]d =1,0000 ⇐ [C]i =1,1111
Рис. 3.7. Результат выполнения примера 3.8
Таким образом, ноль в обратном коде бывает "положительным" и "отрица-
тельным" (обратите внимание на выражение (3.17)), причем добавление
к числу "отрицательного" нуля, как и "положительного", дает в результате
значение первого слагаемого.
Пример 3.9
Сложить два числа в обратном коде: 3 + (−0) . Результат — на рис. 3.8.
A = +0,0011 [A]d = 0,0011 [A]i = 0,0011
B = −0,0000 [B]d =1,0000 [B]i = 1,1111
1 ← 0,0010
1
C = +0,0011 ⇐ [C]d = 0,0011 ⇐ [C]i = 0,0011
Рис. 3.8. Результат выполнения примера 3.9
Глава 3. Арифметические основы ЭВМ 45
Теперь рассмотрим случаи, когда A + B ≥ 1, что соответствует переполнению
разрядной сетки. Очевидно, учитывая, что A <1 и B <1, переполнение воз-
можно только при сложении чисел с одинаковыми знаками. Рассмотрим
примеры.
Пример 3.10
Сложить два числа в обратном коде: 13 16 + 5 16 = 18 16 . Результат — на
рис. 3.9.
A = +0,1101 [A]d = 0,1101 [A]i = 0,1101
B = +0,0101 [B]d = 0,0101 [B]i = 0,0101
C = −0,1101 ⇐ [C]d =1,1101 ⇐ [C]i =1,0010
Рис. 3.9. Результат выполнения примера 3.10
Пример 3.11
Сложить два числа в обратном коде: (−11 16) + (−8 16) = (−19 16) . Резуль-
тат — на рис. 3.10.
A = −0,1011 [A]d =1,1011 [A]i =1,0100
B = −0,1000 [B]d =1,1000 [B]i =1,0111
1 ← 0,1011
1
C = +0,1100 ⇐ [C]d = 0,1100 ⇐ [C]i = 0,1100
Рис. 3.10. Результат выполнения примера 3.11
Таким образом, признаком переполнения в обратном коде можно считать
знак результата, противоположный одинаковым знакам слагаемых:
OV = a0b0c0 ∨ a0b0c0 . (3.19)
Пример 3.12
Сложить числа в обратном коде ( A > B , B > 0 , A + B = 1 ). Результат —
на рис. 3.11.
46 Часть I. Принципы организации ЭВМ
A = +0,0111 [A]d = 0,0111 [A]i = 0,0111
B = +0,1001 [B]d = 0,1001 [B]i = 0,1001
C = −0,1111 ⇐ [C]d =1,1111 ⇐ [C]i =1,0000
Рис. 3.11. Результат выполнения примера 3.12
Пример 3.13
Сложить числа в обратном коде ( A < 0 , B < 0 , A + B = 1 ). Результат — на
рис. 3.12.
A = −0,0111 [A]d =1,0111 [A]i =1,1000
B = −0,1001 [B]d =1,1001 [B]i = 1,0110
1 ← 0,1110
1
C = +0,1111 ⇐ [C]d = 0,1111 ⇐ [C]i = 0,1111
Рис. 3.12. Результат выполнения примера 3.13
Переполнение в соответствии с (3.19) обнаруживается и в этих случаях.
Итак, использование обратного кода в операциях алгебраического сложе-
ния/вычитания позволяет:
􀂈 использовать только действие арифметического сложения двоичных
кодов;
􀂈 получать истинное значение знака результата, выполняя над знаковыми
разрядами операндов те же действия, что и над разрядами чисел;
􀂈 обнаруживать переполнение разрядной сетки.
Еще одним достоинством применения обратного кода можно считать просто-
ту взаимного преобразования прямого и обратного кода.
Однако использование обратного кода имеет один существенный недоста-
ток — коррекция предварительной суммы требует добавления единицы к ее
младшему разряду и может вызвать (в некоторых случаях) распространение
переноса по всему числу, что, в свою очередь, приводит к увеличению вдвое
времени суммирования. Для преодоления этого недостатка можно использо-
вать вместо обратного дополнительный код.
Глава 3. Арифметические основы ЭВМ 47
3.6. Дополнительный код
и арифметические операции в нем
Связь между числом и его изображением в дополнительном коде определяет-
ся соотношениями
[ ]
⎩ ⎨ ⎧
+ <
≥
=
2 , если 0.
, если 0;
A A
A A
A c (3.20)
Таким образом, и дополнительный код положительного числа равен самому
числу (как обратный и прямой). Дополнительный код отрицательного числа
дополняет исходное число до основания системы счисления.
Дополнительный код отрицательного числа образуется в соответствии со
следующим выражением:
[ 0, 1 2 ] 1, 1 2 2 [ 0, 1 2 ] 2 .
n
n i
n
a a an c a a an a a a − … = … + − = − … + − (3.21)
Действительно, из (3.20) следует, что для отрицательного числа
A = −0,a1a2a3…an дополнительный код [A]c = 2 + A , откуда [A]c − A = 2 или
[A]c + A = 2 . Тогда
10,00 0 2 ,
1, 1 2 2 0, 1 2 (1 0),( 1 1)( 2 2 ) ( 2 )
= =
+ − + = + + + + + − =
…
… … … n
n n n
n
a a an a a a a a a a a a
учитывая, что (ai + ai ) = 1.
Таким образом, для преобразования отрицательного двоичного числа в до-
полнительный код следует преобразовать его сначала в обратный код (уста-
новив знаковый разряд в 1 и проинвертировав все остальные разряды числа)
и добавить единицу к младшему разряду обратного кода.
Другой способ перевода прямого кода отрицательного двоичного числа в
дополнительный (приводящий, разумеется, к такому же результату) опре-
деляется следующим правилом: оставить без изменения все младшие нули
и одну младшую единицу, остальные разряды (кроме знакового!) проин-
вертировать.
Пример 3.14
Преобразовать числа в дополнительный код. Результат — на рис. 3.13.
48 Часть I. Принципы организации ЭВМ
Число Прямой код Обратный
код
Дополнит ель-
ный код
+ 0,0111 ⇒ [A]d = 0,0111 ⇒ [A]i = 0,0111 ⇒ [A]c = 0,0111
− 0,0111 ⇒ [A]d =1,0111 ⇒ [A]i =1,1000 ⇒ [A]c =1,1001
− 0,1000 ⇒ [A]d =1,1000 ⇒ [A]i =1,0111 ⇒ [A]c =1,1000
− 0,0101 ⇒ [A]d =1,0101 ⇒ [A]i =1,1010 ⇒ [A]c =1,1011
Рис. 3.13. Результат выполнения примера 3.14
3.6.1. Алгебраическое сложение
в дополнительном коде
Рассмотрим те же четыре случая сочетания знаков и модулей операндов, что
и при рассмотрении сложения в обратном коде в разд. 3.5.1.
􀂈 Случай 1.
A > 0 , B > 0 , A+ B <1 .
Этот случай соответствует обычному сложению прямых кодов чисел:
[A > 0]c + [B > 0]c = A+ B .
􀂈 Случай 2.
A > 0 , B < 0 , A+ B > 0 .
[A > 0]c + [B < 0]c = A + 2 + B . Истинное значение результата в рассматри-
ваемом случае (сумма положительна) будет A + B , и коррекция заключа-
ется в вычитании 2.
􀂈 Случай 3.
A > 0 , B < 0 , A+ B < 0 .
[A > 0]c + [B < 0]c = A + 2 + B . Этот результат соответствует правильному,
поскольку рассматривается случай отрицательной суммы.
􀂈 Случай 4.
A < 0 , B < 0 , A+ B <1.
[A < 0]i + [B < 0]i = 2 + A + 2 + B . Здесь предварительный результат, как и в
случае 2, нуждается в коррекции путем вычитания 2, поскольку истинное
значение отрицательной суммы, представленной в дополнительном коде,
равно A + B + 2 .
Глава 3. Арифметические основы ЭВМ 49
Как и в обратном коде, коррекция требуется только в случаях 2 и 4, причем
в дополнительном коде коррекция заключается просто в игнорировании пе-
реноса, возникающего из знакового разряда.
Рассмотрим несколько примеров.
Пример 3.15
Сложить два числа в дополнительном коде: (+13 16) + (−3 16) = (+10 16) .
Результат — на рис. 3.14.
A = +0,1101 [A]d = 0,1101 [A]c = 0,1101
B = −0,0011 [B]d =1,0011 [B]c =1,1101
C = +0,1010 ⇐ [C]d = 0,1010 ⇐ [C]c =11,1010
Рис. 3.14. Результат выполнения примера 3.15
Пример 3.16
Сложить два числа в дополнительном коде (случай 3). Результат — на
рис. 3.15.
A = −0,1101 [A]d =1,1101 [A]c =1,0011
B = +0,0011 [B]d = 0,0011 [B]c = 0,0011
C = −0,1010 ⇐ [C]d =1,1010 ⇐ [C]c =1,0110
Рис. 3.15. Результат выполнения примера 3.16
Пример 3.17
Сложить два числа в дополнительном коде (случай 4). Результат — на
рис. 3.16.
A = −0,0101 [A]d =1,0101 [A]c =1,1011
B = −0,0110 [B]d =1,0110 [B]c =1,1010
C = −0,1011 ⇐ [C]d =1,1011 ⇐ [C]c =11,0101
Рис. 3.16. Результат выполнения примера 3.17
50 Часть I. Принципы организации ЭВМ
Пример 3.18
Сложить два числа в дополнительном коде (одинаковые модули, но разные
знаки). Результат — на рис. 3.17.
A = −0,0101 [A]d =1,0101 [A]c =1,1011
B = +0,0101 [B]d = 0,0101 [B]c = 0,0101
C = +0,0000 ⇐ [C]d = 0,0000 ⇐ [C]c =10,0000
Рис. 3.17. Результат выполнения примера 3.18
Из примера 3.18 видно, что "ноль" в дополнительном коде имеет единствен-
ное "положительное" представление.
Теперь рассмотрим случаи, когда A+ B >1 , что соответствует переполнению
разрядной сетки.
Пример 3.19
Сложить два числа в дополнительном коде: 13 16 + 5 16 = 18 16 . Результат —
на рис. 3.18.
A = +0,1101 [A]d = 0,1101 [A]c = 0,1101
B = +0,0101 [B]d = 1,0101 [B]c = 0,0101
C = −0,1110 ⇐ [C]d =1,1110 ⇐ [C]c =1,0010
Рис. 3.18. Результат выполнения примера 3.19
Пример 3.20
Сложить два числа в дополнительном коде: (−11 16) + (−8 16) = (−19 16) .
Результат — на рис. 3.19.
A = −0,1011 [A]d =1,1011 [A]c = 1,0101
B = −0,0011 [B]d =1,1000 [B]c =1,1000
C = +0,1101 ⇐ [C]d = 0,1101 ⇐ [C]c = 10,1101
Рис. 3.19. Результат выполнения примера 3.20
Глава 3. Арифметические основы ЭВМ 51
Очевидно, для дополнительного кода, как и для обратного, справедливо вы-
ражение (3.19). Теперь рассмотрим случаи A + B = 1 . Для положительных
слагаемых пример 3.12 может относиться как к обратным, так и к дополни-
тельным кодам, но преобразование результата — дополнительного кода
в прямой приведет к другому значению. Действительно,
[ ] =1,0000→[[ ] ] +1=1,1111+1=1,0000 = −0,0000 C c C c i .
Для случая A < 0 , B < 0 , A+ B =1 имеем следующее.
Пример 3.21
Сложить два числа в дополнительном коде: (−11 16) + (−5 16) = (−16 16) .
Результат — на рис. 3.20.
A = −0,1011 [A]d =1,1011 [A]c =1,0101
B = −0,0101 [B]d =1,0101 [B]c =1,1011
C = −0,0000 ⇐ [C]d =1,0000 ⇐ [C]c =10,0000
Рис. 3.20. Результат выполнения примера 3.21
Переполнение по признакам выражения (3.19) не обнаружено! Однако ре-
зультат операции — "отрицательный ноль", который не может использовать-
ся в дополнительном коде. Действительно, сложение в дополнительном коде
любого числа с "отрицательным нулем" 1,00...0 меняет знак этого числа.
Итак, при A < 0 , B < 0 , A + B =1 признаком переполнения служит не вы-
ражение (3.19), а код результата 1, 00...0.
Таким образом, значение признака переполнения в дополнительном коде
можно получить в соответствии со следующим выражением:
OV = a0b0c0 ∨ a0b0c0 ∨ c0c1c2…cn . (3.22)
Подведем итоги. Применение дополнительного кода, по сравнению с обрат-
ным, имеет одно существенное преимущество — коррекция результата сво-
дится просто к отбрасыванию переноса из знакового разряда и не требует
дополнительных затрат времени. К недостаткам применения дополнитель-
ного кода можно отнести, во-первых, более сложную процедуру взаимного
преобразования ПК↔ДК, требующую дополнительных затрат времени, и,
во-вторых, проблемы с обнаружением переполнения. Для того чтобы мини-
52 Часть I. Принципы организации ЭВМ
мизировать влияние первого недостатка, данные в памяти часто хранят в до-
полнительном коде. В этом случае преобразования ПК↔ДК выполняются
относительно редко — только при вводе и выводе.
3.6.2. Модифицированные обратный
и дополнительный коды
Для определения переполнения используют выражение (3.19) — булеву
функцию трех переменных. С целью более удобного обнаружения перепол-
нения в обратном и дополнительном кодах можно применить так называемые
"модифицированные" их представления:
[ ]
⎪⎩
⎪⎨ ⎧
+ − ≤
≥
= 4 2− , если 0.
, если 0;
A A
A A
A n
m
i (3.23)
[ ]
⎩ ⎨ ⎧
+ <
≥
=
4 , если 0.
, если 0;
A A
A A
A m
c (3.24)
Нетрудно показать, что модифицированные коды отличаются от соответст-
вующих обычных наличием дополнительного знакового разряда: "плюс" ко-
дируется 00, а "минус" — 11. Эта своеобразная избыточность, сохраняя все
качества обычных обратных и дополнительных кодов, позволяет фиксиро-
вать факт переполнения по неравнозначности знаковых разрядов результа-
та. Заметим, что использование модифицированного дополнительного кода
не решает проблемы обнаружения переполнения в случаях A < 0 , B < 0 ,
A+ B =1.
3.7. Алгоритмы алгебраического сложения
в обратном и дополнительном коде
В разд. 3.5.1 и 3.6 подробно обсуждалось, как выполнить операцию алгеб-
раического сложения чисел, уже представленных соответственно в обратном
или дополнительном коде. Для этого достаточно выполнить арифметическое
сложение двоичных векторов, получив истинное значение результата в коде
представления операндов. При операции в обратном коде возникающий из
знакового разряда перенос следует добавить к младшему разряду суммы. Пе-
реполнение обнаруживается согласно выражению (3.19).
В случае если слагаемые представлены в прямом коде, а операция выполня-
ется в обратном или дополнительном, их следует сначала преобразовать
Глава 3. Арифметические основы ЭВМ 53
в соответствующий код, затем выполнить сложение и сумму вновь преобра-
зовать в прямой код — код результата всегда должен соответствовать коду
исходных данных. На рис. 3.21 приведен пример алгоритма алгебраического
сложения в обратном коде чисел, представленных в прямом коде, а на
рис. 3.22 — алгебраическое сложение/вычитание чисел в дополнительном
коде.
Рис. 3.21. Алгоритм алгебраического
сложения в обратном коде
Рис. 3.22. Алгоритм алгебраического сложения/
вычитания в дополнительном коде
54 Часть I. Принципы организации ЭВМ
При рассмотрении алгоритмов использованы те же обозначения, которые
были введены в разд. 3.4 для рис. 3.1. Дополнительно введем обозначения:
􀂈 A′ = a1a2 ...an , B′ = b1b2...bn , C′ = c1c2...cn — модули чисел;
􀂈 c−1 — перенос из знакового разряда;
􀂈 α* = a0b0c0 ∨ a0b0c0 ∨ c0c1c2…cn — ситуации переполнения в дополни-
тельном коде.
В алгоритме на рис. 3.22 можно отметить один недостаток. При выполнении
вычитания ( f = 1) необходимо получить дополнение второго операнда:
B′ := B′ +1 , что является арифметической операцией и требует времени, дос-
таточного для прохождения переноса по всем разрядам числа. Для исключе-
ния дополнительной арифметической операции можно в первой операторной
вершине осуществить только инверсию (логическую операцию, которая вы-
полняется быстро), а недостающую "единицу" к младшему разряду добавить,
если это необходимо, в качестве входного переноса младшего разряда в мо-
мент суммирования слагаемых. Таким образом, в двух первых операторных
вершинах алгоритма рис. 3.22 следует поместить такие операторы:
: .
': ';
C A B f
B B
= + +
=
3.8. Алгоритмы умножения
Умножение двоичных чисел со знаком удобнее всего проводить в прямом
коде. Действительно, знак произведения не зависит от соотношения величин
модулей сомножителей, а зависит только от их знаков:
c0 = a0 ⊕ b0 = a0b0 ∨ a0b0 , (3.25)
а модуль произведения равен произведению модулей сомножителей.
Обозначим A′ , B′ , C′ — модули сомножителей и произведения соответст-
венно. Тогда
1 2 ( 1)
1 2 1
( 1) 2 1
1 2 1
( 1) ( 2) 1 1
1 2 1
( 2) ( 3) 1
1 2
' ' ' '( 2 2 2 2 )
' 2 ' 2 ' 2 ' 2
( ' 2 ' 2 ' 2 ' ) 2
(( ' 2 ' 2 ' ) 2
n n
n n
n n
n n
n n
n n
n n
n n
C A B A b b b b
A b A b A b A b
A b A b A b A b
A b A b A b
− − − − −
−
− −− − −
−
− − − − − −
−
− − − − −
−
= ⋅ = ⋅ ⋅ + ⋅ + + ⋅ + ⋅ =
= ⋅ ⋅ + ⋅ ⋅ + + ⋅ ⋅ + ⋅ ⋅ =
= ⋅ ⋅ + ⋅ ⋅ + + ⋅ ⋅ + ⋅ ⋅ =
= ⋅ ⋅ + ⋅ ⋅ + + ⋅ ⋅ +
…
…
…
… 1
1
1 1 1 1
1 2 1
' ) 2
......................................................................................
( (0 ' n ) 2 ' n ) 2 ' ) 2 ' ) 2 .
A b
A b A b A b A b
−
− − − −
−
⋅ ⋅ =
= … + ⋅ ⋅ + ⋅ ⋅ +…+ ⋅ ⋅ + ⋅ ⋅
(3.26)
Глава 3. Арифметические основы ЭВМ 55
Выражение (3.26) определяет процесс формирования произведения путем
вычисления частичных сумм и суммы частичных произведений. Напомним,
что b1 — старший разряд множителя, а bn — младший. Вычисляя непосред-
ственно по формуле (3.26), следует на каждом шаге:
1. Проанализировать очередную цифру множителя bi . Если bi = 1, то оче-
редная частичная сумма равна A, и она добавляется к накопленной ранее
сумме частичных произведений S (на первом шаге S = 0 ), иначе добав-
ления не производится.
2. Осуществить правый сдвиг частичного произведения S на один разряд.
Умножение S ⋅ 2−1 соответствует делению на 2, что в двоичной системе
счисления равносильно сдвигу числа на один разряд вправо.
3. Пункты 1 и 2 повторяются до тех пор, пока не будут исчерпаны все цифры
множителя.
Рис. 3.23. Умножение в прямом коде
56 Часть I. Принципы организации ЭВМ
Очевидно, число шагов при использовании приведенного выше метода равно
разрядности модуля множителя. Алгоритм умножения чисел, представлен-
ных в прямом коде, приведен на рис. 3.23.
В изображенном на рис. 3.23 алгоритме, в отличие от алгоритмов сложе-
ния/вычитания, значение OV = 0 устанавливается безусловно. Действитель-
но, A и B — дробные числа; очевидно при A < 1 и B < 1 всегда A× B < 1.
В результате вычисления по формуле (3.26) получается произведение раз-
рядностью 2n . Если рассматривать сомножители как дроби, то младшие n
разрядов можно просто отбросить (округление с недостатком) или округлить
до n -разрядного модуля по правилам округления.
Очевидно, из выражения (3.26) легко получить
2 ) 2 2 ) 2,
( (0 2 ) 2 2 ) 2
1
1 2
+ ⋅ ′ ⋅ ⋅ + ⋅ ′ ⋅ ⋅
= + ⋅ ′ ⋅ ⋅ + ⋅ ′ ⋅ ⋅ + +
′ = ′ ⋅ ′ =
−
−
−
− −
n
n
n
n
n n
A b A b
A b A b
C A B
… … (3.27)
что позволяет производить умножение, начиная со старших разрядов множи-
теля. При этом сдвиг суммы частичных произведений осуществляется влево
на один разряд, чему соответствует умножение двоичного числа на 2.
3.8.1. Умножение в дополнительном коде
Если на обработку поступают числа, уже представленные в дополнительном
коде, то для умножения их можно перевести в прямой код или умножать сра-
зу в дополнительном коде. В последнем случае в умножении участвуют и
знаковые разряды сомножителей, причем знак произведения получается в
том же цикле, что и разряды модуля произведения. Однако в некоторых слу-
чаях требуется коррекция предварительного результата. Мы не будем рас-
сматривать здесь случаи умножения в дополнительном коде. Любознатель-
ным рекомендуем соответствующую литературу, например [9].
3.8.2. Методы ускорения умножения
Методы ускорения умножения принято делить [6, 9] на аппаратные и логиче-
ские. Как те, так и другие требуют дополнительных затрат оборудования.
При использовании аппаратных методов дополнительные затраты оборудо-
вания прямо пропорциональны числу разрядов в операндах. Эти методы вы-
зывают усложнение схемы операционного автомата АЛУ.
Дополнительные затраты оборудования при реализации логических методов
ускорения умножения не зависят от разрядности операндов. Усложняется
Глава 3. Арифметические основы ЭВМ 57
в основном схема управления АЛУ. В ЭВМ для ускорения умножения часто
используются комбинации этих методов.
К аппаратным методам ускорения умножения относятся ускорение выполне-
ния операций сложения и сдвига, введение дополнительных цепей сдвига,
позволяющих за один такт производить сдвиг информации в регистрах сразу
на несколько разрядов, совмещение во времени операций сложения и сдвига,
построение комбинационных схем множительных устройств, реализующих
"табличное" и "матричное" умножение.
Пример реализации умножения с использованием n -входового сумматора
показан на рис. 3.24.
Здесь частичные произведения формируются на схемах n -разрядных конъ-
юнкторов одновременно и подаются на входы n -входового сумматора, при-
чем в сумматоре за счет соответствующей коммутации цепей осуществляют-
ся сдвиги частичных произведений (как при выполнении умножения на
бумаге "в столбик"). На выходе сумматора получается 2n -разрядное произ-
ведение.
Метод табличного умножения (рис. 3.25) позволяет получить произведение
за один такт при условии, что вся таблица умножения (результаты умноже-
ния всевозможных пар n -разрядных сомножителей!) будет размещена в па-
мяти. Очевидно, для этого понадобится запоминающее устройство объемом
22n 2n -разрядных слов (точно таким же способом можно выполнять и дру-
гие "длинные" операции — деление, вычисление функций). Так, для органи-
зации 8-разрядного умножителя потребуется память объемом 216 ×16 бит =
= 128 Кбайт, что для современного уровня развития интегральной техноло-
гии не кажется чрезмерным.
Однако для 16-разрядного АЛУ умножитель "потянет" уже на 232 ×32 бит =
= 16 Гбайт! Что касается современных 32-разрядных процессоров, то к рас-
чету потребности в памяти для таких умножителей даже страшно присту-
пать.
В этом случае можно воспользоваться таблицей умножения меньшей разряд-
ности, получая с ее помощью частичные произведения, а потом просуммиро-
вать их, предварительно сдвинув на соответствующее число разрядов.
Рассмотрим этот способ умножения подробнее. Пусть n — четное. Тогда
каждый из двух сомножителей можно представить конкатенацией двух по-
лей одинаковой разрядности n 2 : A = Ah Al , B = BhBl . В этом случае про-
изведение можно представить следующим выражением:
h h
n
l h
n
h l
n
A× B = Al ⋅ Bl + 2 ⋅ A ⋅ B + 2 ⋅ A ⋅ B + 2 ⋅ A ⋅ B 2 2 . (3.28)
58 Часть I. Принципы организации ЭВМ
Рис. 3.24. Матричное умножение
Рис. 3.25. Табличное умножение
Таким образом, располагая, например, таблицей умножения 8×8, можно по-
лучить произведение двух 16-разрядных сомножителей, сложив (с соответст-
вующим сдвигом) всего 4 слагаемых. Проиллюстрируем этот метод на про-
стом примере.
Пусть требуется перемножать 4-разрядные числа без знака. Построим таблицу
умножения 2× 2 (при рассмотрении примера не будем включать в нее пары
Глава 3. Арифметические основы ЭВМ 59
сомножителей, когда один из них равен нулю, а так же пары сомножителей,
симметричные уже включенным) — рис. 3.26.
01 × 01 = 0001 10 × 10 = 0100
01 × 10 = 0010 10 × 11 = 0110
01 × 11 = 0011 11 × 11 = 1001
Рис. 3.26. Вспомогательная таблица умножения
Пример 3.22
Выполним умножение 6×10 = 60 или в двоичном коде 01.10×10.10 = 00111100 .
Из таблицы получаем частичные произведения: Al × Bl = 10×10 = 0100 ,
Al × Bh = 10×10 = 0100 , Ah × Bl = 01×10 = 0010 , Ah × Bh = 01×10 = 0010 .
Теперь сложим частичные произведения, предварительно сдвинув их в соот-
ветствии с (3.28). Результат — на рис. 3.27.
01 00
+
01 00
00 10
00 10
00 11 11 00
Рис. 3.27. Результат выполнения примера 3.22
Пример 3.23
Выполним умножение 7×11 = 77 или в двоичном коде 01.11×10.11 = 01001101.
Из таблицы получаем частичные произведения: Al × Bl = 11×11 = 1001 ,
Al × Bh = 11×10 = 0110 , Ah × Bl = 01×11 = 0011, × = 01×10 = 0010 h h A B .
Теперь сложим частичные произведения, предварительно сдвинув их в соот-
ветствии с (3.28). Результат — на рис. 3.28.
10 01
+
01 10
00 11
00 10
01 00 11 01
Рис. 3.28. Результат выполнения примера 3.23
60 Часть I. Принципы организации ЭВМ
Среди логических наиболее распространены в настоящее время методы, по-
зволяющие за один шаг умножения обработать несколько разрядов множите-
ля. Рассмотрим один из способов умножения на два разряда множителя, на-
чиная с его младших разрядов. В зависимости от результата анализа пары
разрядов множителя предусматриваются следующие действия (табл. 3.3).
Таблица 3.3. Действия
Комбинация Действие Добавлено
00 Сдвиг — Сдвиг 0
01 Сложение — Сдвиг — Сдвиг A
10 Сдвиг — Сложение — Сдвиг 2A
11 Сложение — Сдвиг — Сложение — Сдвиг 3A = 4A − A
Таким образом, для умножения сразу на два разряда множителя достаточно:
􀂈 при 00 просто произвести сдвиг на два разряда;
􀂈 при 01 прибавить к сумме частичных произведений множимое и произве-
сти сдвиг на два разряда;
􀂈 при 10 прибавить к сумме частичных произведений удвоенное множимое
и произвести сдвиг на два разряда;
􀂈 при 11 вычесть из суммы частичных произведений множимое (или доба-
вить обратный (дополнительный) код множимого), произвести сдвиг на
два разряда и добавить 1 к следующей (старшей) паре цифр множителя.
При классическом методе умножения двоичных n -разрядных чисел согласно
выражению (3.26) потребуется n сдвигов суммы частичных произведений и
n 2 (в среднем) сложений множимого с суммой частичных произведений.
Один из методов ускорения операции умножения — анализ сразу двух разря-
дов множителя. Это позволит получить результат, применяя n 2 сдвигов и
(в среднем) 3n 8 сложений/вычитаний.
3.9. Алгоритмы деления
Знак частного, как и знак произведения, не зависит от соотношения модулей
операндов и определяется в зависимости от знаков операндов по выражению
(3.25). Поэтому рассмотрим сначала процесс деления модулей двоичных чисел.
Пусть A — делимое, B — делитель, C — частное, W — остаток.
Глава 3. Арифметические основы ЭВМ 61
Очевидно, при представлении чисел с фиксированной запятой как дробных,
должно соблюдаться условие
A < B , (3.29)
иначе C ≥ 1, что соответствует переполнению разрядной сетки.
Процесс деления двоичных чисел может быть сведен к последовательности
вычитаний и анализа знаков получающихся остатков. Сформулируем словес-
ный алгоритм деления следующим образом:
1. Вычитают из делимого делитель. Если знак разности 0, то деление невоз-
можно в силу нарушения условия (3.29), и следует, установив OV = 1 , за-
вершить операцию; иначе в разряд целой части частного записывают 0
(в конце операции в этот разряд помещается знак частного).
2. Так как остаток (разность A − B ) оказался отрицательным, восстанавли-
вают остаток путем добавления делителя к остатку.
3. Сдвигают восстановленный остаток влево на один разряд.
4. Вычитают из сдвинутого остатка делитель; если полученная разность по-
ложительна, то очередной цифрой частного становится 1, и следует пе-
рейти к п. 3; иначе очередная цифра частного — 0 и переходят к п. 2.
Пункты 2—4 повторяют столько раз, сколько цифр требуется получить в частном.
Пример 3.24
Деление дробных положительных чисел + (3 16) : + (12 16) = + (1 4) = + (4 16)
приведено на рис. 3.29.
Рис. 3.29. Пример деления
62 Часть I. Принципы организации ЭВМ
3.9.1. Деление без восстановления остатка
Приведенный ранее метод деления называется методом деления с восстанов-
лением остатка. При получении отрицательного остатка на очередном шаге
деления необходимо перед левым сдвигом восстановить остаток путем до-
бавления к нему делителя. При этом для получения n -разрядного частного
требуется в среднем 1,5n циклов сложения/вычитания.
Существует алгоритм деления без восстановления остатка, позволяющий
корректировать отрицательные остатки без дополнительного цикла сложе-
ния. Рассмотрим действия, производимые с остатками в цикле деления в за-
висимости от полученного знака остатка (табл. 3.4).
Видно, что если на очередном шаге остаток получился отрицательный, его
можно не восстанавливать, но на следующем шаге в этом случае нужно вме-
сто вычитания делителя из сдвинутого остатка добавить делитель к сдвину-
тому остатку.
Таблица 3.4. Действия, производимые с остатками в цикле деления
Номер шага Действие W>0 W<0
1 Восстановление остатка Нет W + B
2 Сдвиг влево 2W 2 ⋅ (W + B)
3 Вычитание делителя 2W − B 2 ⋅ (W + B) − B = 2W + B
Действительно, если W − B < 0 , то следует восстановление остатка и сдвиг вос-
становленного остатка влево (его удвоение) 2 ⋅ (W − B + B) . На следующем шаге
вычитаем делитель и получаем 2W − B . Тот же результат может быть получен,
если сдвинуть невосстановленный остаток, но на следующем шаге вместо вычи-
тания произвести добавление делителя: 2 ⋅ (W − B) + B = 2W − 2B + B = 2W + B .
3.10. Арифметические операции с числами,
представленными в формате
с плавающей запятой
В таком формате число определяется значениями мантиссы и порядка:
N = m⋅ q p , (3.30)
где m — мантисса числа, p — порядок, q — основание.
Глава 3. Арифметические основы ЭВМ 63
Мантисса и порядок могут иметь свои знаки, причем знак мантиссы соответ-
ствует знаку числа. Основание q может не совпадать с основанием системы
счисления. При операциях с двоичными числами часто для расширения диа-
пазона представления чисел выбирают q = 2k , например, q =16 .
В машинном представлении формат числа с плавающей запятой (рис. 3.30)
задается двумя полями — полем мантиссы m и полем порядка p , причем
каждое поле имеет свой разряд знака. Значение порядка в формате числа не
указывается — оно подразумевается одинаковым для всех чисел.
Мантисса и порядок представляются в формате с фиксированной запятой,
причем обычно порядок — целое число со знаком (запятая фиксирована по-
сле младшего разряда), а мантисса — правильная дробь (запятая фиксирова-
на между знаковым разрядом и старшим разрядом модуля). С целью увели-
чения точности представления числа в заданном формате мантиссу
представляют в нормализованной форме, когда старший разряд модуля ман-
тиссы — не ноль (для прямых кодов). Действительно,
0,2364⋅104 ≈ 0,0024⋅106 ,
однако в последнем случае мантисса не нормализована и точность представ-
ления числа — всего два десятичных разряда.
Рис. 3.30. Формат числа с плавающей запятой
Существуют и другие форматы представления чисел с плавающей запятой.
Так, стандарт IEEE1, который, кстати, поддерживают (со)процессоры семей-
ства х86(87), предусматривает числа с одинарной и двойной точностью.
Форматы представлены тремя полями:
􀂈 s — знак числа;
􀂈 e — характеристика;
􀂈 m — мантисса.
1 Institute of Electrical and Electronics Engineers — институт инженеров по электротехнике и
электронике.
64 Часть I. Принципы организации ЭВМ
Формат с одинарной точностью занимает 32-разрядное двоичное слово,
причем знак s размещается в его старшем разряде, характеристика e —
в следующих 8 разрядах и, наконец, 23 младших разряда занимает ман-
тисса m .
Порядок p , под который отводится один байт, может принимать значения
в диапазоне ±127. Характеристика в стандарте IEEE получается как порядок
с избытком 127: e = p +127 . При этом характеристика всегда положительна,
что упрощает выполнение арифметических операций.
Мантисса числа в стандарте IEEE нормализована и лежит в диапазоне
1 ≤ m < 2 . Целая часть мантиссы всегда равна 1, поэтому значение целой
части не хранится в формате числа, а подразумевается (так называемая
"скрытая единица"). Дробная часть мантиссы хранится в 23 младших раз-
рядах формата.
Формат с двойной точностью отличается длиной полей характеристики
(11 битов с избытком 1023) и мантиссы (52 бита) и размещается в 64-раз-
рядном двоичном слове.
Попробуйте самостоятельно оценить диапазон представления чисел в форма-
тах IEEE. Подробности о выполнении операций с этими форматами можно
посмотреть в [3, 11].
3.10.1. Сложение и вычитание
Ранее мы договорились, что алгебраическое вычитание легко свести к алгеб-
раическому сложению путем замены знака второго операнда. Поэтому рас-
смотрим процесс алгебраического сложения. Для уяснения принципа выполне-
ния сложения чисел с плавающей запятой рассмотрим пример в десятичной
системе.
Пример 3.25
Сложить два числа, представленные в формате с плавающей запятой:
A = 0,315290⋅10−2 , B = 0,114082⋅10+2 .
Обратите внимание, мантиссы чисел нормализованы. Очевидно, прежде чем
складывать мантиссы, требуется преобразовать числа таким образом, чтобы
они имели одинаковые порядки. Выравнивание порядков можно выполнить
двумя способами — уменьшением большего порядка до меньшего или уве-
личением меньшего до большего (рис. 3.31).
Глава 3. Арифметические основы ЭВМ 65
A = 0,315290 ⋅10−2 A = 0,000031 5290 ⋅10+2
B = 1140 0,820000⋅10−2 B = 0,114082 ⋅10+2
C = 1,135290⋅10−2 C = 0,114114 ⋅10+2
а б
Рис. 3.31. Выравнивание порядков
В первом случае за разрядную сетку выходят старшие разряды сдвигаемой
мантиссы и результат сложения оказывается неверным. Во втором случае
при сдвиге теряются младшие разряды мантиссы, что не влияет на точность
результата. Поэтому при выравнивании порядков всегда следует увели-
чивать меньший порядок до большего при соответствующем уменьшении
мантиссы.
Для выравнивания порядков следует определить разность порядков слагае-
мых и сдвинуть мантиссу числа с меньшим порядком вправо на величину
этой разности. Если разность порядков превышает разрядность поля
мантиссы, то значение слагаемого с меньшим порядком может быть приня-
то за 0, а результат суммирования будет равен слагаемому с большим по-
рядком.
После выравнивания порядков следует сложить мантиссы и определить в ка-
честве порядка результата порядок любого из слагаемых (после выравнива-
ния порядки слагаемых равны). Если при сложении мантисс возникает пере-
полнение, то результат может быть исправлен путем сдвига мантиссы суммы
на один разряд вправо и добавления единицы к порядку результата.
Однако если в результате этого добавления произойдет переполнение раз-
рядной сетки порядков, то результат окажется неверным — имеет место так
называемое положительное переполнение: OV := 1 (рис. 3.32).
A = 0,96502⋅10+2 A = 0,96502⋅10+2
B = 0,73005⋅10+1 B = 0,07300⋅10+2
C = 1,03802⋅10+2 — переполнение мантисс!
C =1,0380⋅10+3 — правильный результат
Рис. 3.32. Положительное переполнение
66 Часть I. Принципы организации ЭВМ
В результате алгебраического сложения мантисс результат может оказаться
ненормализованным. Для нормализации результата необходимо сдвигать
мантиссу результата влево до тех нор, пока в старшем значащем разряде не
окажется цифра, отличная от 0 (в двоичной системе это 1), сопровождая каж-
дый сдвиг уменьшением на 1 порядка результата (рис. 3.33). Этот процесс
называется нормализацией результата.
A = 0,24512⋅10−8
B = −0,24392⋅10−8
C = 0,00120⋅10−8 = 0,12000⋅10−10
Рис. 3.33. Положительное переполнение
В процессе уменьшения порядка при нормализации может оказаться, что
модуль порядка превысил максимальную величину, размещаемую в поле по-
рядка. Этот случай называют отрицательным переполнением. Его можно
избежать, оставив результат ненормализованным, однако принято считать,
что сохранять ненормализованный результат в памяти недопустимо. Поэтому
в случае отрицательного переполнения результат принимает значение "ма-
шинный ноль".
Итак, процедура алгебраического сложения чисел с плавающей запятой
складывается из следующих этапов:
1. Выравнивание порядков.
2. Алгебраическое сложение мантисс как чисел с фиксированной запятой.
3. Нормализация результата.
Алгоритм операции сложения с плавающей запятой представлен на
рис. 3.34. Первая часть алгоритма — выравнивание порядков, представлена
достаточно подробно, хотя можно предложить несколько различных спосо-
бов реализации этой процедуры (в зависимости от способа кодирования
порядков, требования к быстродействию и экономичности арифметическо-
го устройства). Алгоритм алгебраического сложения мантисс (как чисел
с фиксированной запятой) подробно обсуждался ранее (см. разд. 3.4—3.6,
рис. 3.3, 3.21, 3.22), поэтому в рассматриваемом алгоритме он представлен
одним блоком. Нормализация результата приведена для случая представ-
ления чисел в прямом коде.
Глава 3. Арифметические основы ЭВМ 67
Рис. 3.34. Алгоритм операции сложения чисел с плавающей запятой
68 Часть I. Принципы организации ЭВМ
3.10.2. Умножение и деление
Положим
.
;
;
;
D
C
B
A
p
D
p
C
p
B
p
A
D m q
C m q
B m q
A m q
= ⋅
= ⋅
= ⋅
= ⋅
Тогда
( ) pA pB ,
C A B mA mB q = × = × ⋅ + т. е. mC = mA ×mB , pC = pA + pB .
( ) pA pB ,
D A B mA mB q = ÷ = ÷ ⋅ − т. е. mD = mA ÷mB , pD = pA − pB .
Таким образом, умножение чисел с плавающей запятой сводится к двум опе-
рациям (умножение мантисс и сложение порядков) над числами с фиксиро-
ванной запятой, а деление — к делению мантисс и вычитанию порядков —
также к двум операциям с фиксированной запятой, которые были подробно
рассмотрены ранее.
3.11. Арифметические операции
над десятичными числами
3.11.1. Кодирование десятичных чисел
При использовании в ЭВМ десятичные числа кодируются группой двоичных
разрядов. Учитывая, что
log2 10 ≈ 3,32 , (3.31)
для представления одной десятичной цифры требуется не менее четырех
двоичных разрядов. Соответствие между десятичной цифрой и ее двоичным
представлением называют двоичным кодом десятичной цифры. Наиболее
естественным представляется кодирование десятичных цифр позиционными
двоичными кодами с естественными весами разрядов. Такой код принято на-
зывать кодом "8421".
Ясно, что это далеко не единственный способ кодирования десятичных цифр.
Используя только четырехразрядные двоичные коды, следует выбрать 10 из
шестнадцати возможных комбинаций для представления цифр. Количество
Глава 3. Арифметические основы ЭВМ 69
способов, которыми могут быть выбраны 10 комбинаций из 16, равно числу
сочетаний из 16 по 10:
10
16
16!
.
10! 6!
C =
⋅
После того как выбор комбинаций сделан, можно P10 = 10! способами сопос-
тавить комбинацию десятичной цифре. Таким образом, общее число различ-
ных четырехразрядных кодов десятичных цифр составляет
10 10 10
16 16 10
16! 16!
10! 3 10 .
10! 6! 6!
A = C ⋅ P = ⋅ = ≈ ⋅
⋅
Практически лишь 5—6 различных кодов используют в ЭВМ для представ-
ления десятичных цифр.
Основной недостаток кодирования десятичных цифр в коде "8421" состоит
в несоответствии веса десятичного и шестнадцатеричного переносов. Дейст-
вительно, перенос из тетрады шестнадцатеричной цифры имеет вес 16, а де-
сятичный перенос — 10.
Для устранения этого противоречия можно выбрать другие способы кодиро-
вания десятичных цифр. Например, код "8421+3" (иногда его называют
кодом с избытком три) позволяет при сложении получать сумму "с избыт-
ком 6", при этом вес переноса соответствует десятичному.
Можно подобрать такие веса двоичных разрядов при кодировании деся-
тичных цифр, чтобы их сумма равнялась 10. Например, код "5211" обла-
дает именно таким свойством. При этом, однако, нарушается свойство
функциональности соответствия десятичных цифр и их двоичного пред-
ставления. Например, цифра 7 может быть представлена как 1100 или
как 1011. Для преодоления этого недостатка достаточно договориться,
чтобы в подобных ситуациях всегда сначала заполнялись младшие разря-
ды кода.
В табл. 3.5 приведены упомянутые двоичные коды десятичных цифр.
Арифметические операции над десятичными числами можно выполнять как
на специальных десятичных сумматорах (в этом случае можно применять
любую кодировку десятичных цифр), так и на обычных двоичных суммато-
рах. В последнем случае десятичные числа обрабатываются по правилам дво-
ичной арифметики, и десятичный результат операции, естественно, нуждает-
ся в коррекции. В этом случае сложность коррекции и длительность ее
реализации существенно зависят от выбранного кода.
70 Часть I. Принципы организации ЭВМ
Таблица 3.5. Двоичные коды десятичных цифр
Цифры Код "8421" Код "8421+3" Код "5211"
0 0000 0011 0000
1 0001 0100 0001
2 0010 0101 0011
3 0011 0110 0101
4 0100 0111 0111
5 0101 1000 1000
6 0110 1001 1001
7 0111 1010 1011
8 1000 1011 1101
9 1001 1100 1111
3.11.2. Арифметические операции
над десятичными числами
Рассмотрим выполнение операции сложения десятичных чисел в коде "8421"
по правилам двоичной арифметики.
Пример 3.26
Результат — на рис. 3.35.
А = 4754 = 0100 0111 0101 0100
B = 2917 = 0010 1001 0001 0111
C = 7671 = 0111 ←0000 0110 1011
7 0 6 11
Рис. 3.35. Результат выполнения примера 3.26
Из рассмотренного примера видно, что тетрады результата (назовем его
предварительным), обрамленные рамкой, нуждаются в коррекции. Действи-
тельно, если сумма тетрад, представляющих соответствующие десятичные
разряды слагаемых, больше 9, но не превышает 15, двоичный перенос в сле-
дующую тетраду не формируется. В этом случае требуется выработать ис-
кусственный перенос и удалить из тетрады 10, что соответствует добавлению
шестерки (0110) и передаче обязательно возникающего при этом переноса
в следующий старший разряд.
Глава 3. Арифметические основы ЭВМ 71
Если из тетрады был двоичный перенос (в примере он отмечен знаком ←), то
он "унес" из тетрады 16, в то время как десятичный перенос должен "уно-
сить" только 10. Значит, в такие тетрады, из которых был перенос, следует
добавить шестерку (0110).
Таким образом, коррекция предварительной двоичной суммы при использо-
вании кода "8421" заключается в добавлении кода 0110 ко всем тетрадам
предварительной суммы, значение которых превышает 9 или из которых был
двоичный перенос. Возникающие при коррекции переносы должны обяза-
тельно передаваться в следующую старшую тетраду. Выполним операции
примера 3.26 с учетом сформулированных правил коррекции.
Пример 3.27
Результат — на рис. 3.36.
А = 4754 = 0100 ←0111 0101 0100
B = 2917 = 0010 1001 0001 0111
C = 7671 0111 0000 0110 ←1011
0110 0110
=0111 0110 0111 0001
7 6 7 1
Рис. 3.36. Результат выполнения примера 3.27
Рассмотрим еще один пример арифметического сложения в коде "8421".
Пример 3.28
Результат — на рис. 3.37.
А = 3852 = 0011 1000 0101 0010
B = 5179 = 0101 0001 0111 1001
C = 9031 1000 1001 ←110
0
←101
1
0110 0110
1000 ←1010 0011 0001
0110
= 1001 0000 0011 0001
9 0 3 1
Рис. 3.37. Результат выполнения примера 3.28
72 Часть I. Принципы организации ЭВМ
Из примера 3.28 видно, что межтетрадные переносы, возникающие в процес-
се коррекции предварительной суммы, могут таким образом изменить стар-
шие тетрады, что их также потребуется корректировать. В худшем случае
количество последовательных коррекций будет равно разрядности слагаемых
(рассмотрите пример сложения 9999 + 1 в коде "8421").
На основании вышеизложенного можно отметить следующие недостатки
применения кода "8421":
􀂈 необходимо отслеживать не только переносы из тетрад, но и значения мо-
дулей тетрад предварительной суммы;
􀂈 в общем случае невозможно произвести одновременно коррекцию во всех
тетрадах, где может потребоваться коррекция.
Для преодоления отмеченных выше недостатков можно использовать другие
коды, например "8421+3". При кодировании с избытком три каждая десятич-
ная цифра представляется как ′ = + 0011 ai ai , где ai — код "8421" цифры.
Тогда при сложении
= ( i + 3) + ( i + 3) + i−1 = i + i + i−1 + 6
h
ci a b p a b p , (3.32)
где ch — предварительная сумма, в тетраде всегда будет формироваться ис-
тинное значение десятичного переноса — для всех комбинаций десятичных
слагаемых, для которых ai + bi + pi−1 > 0 , значение ai′ + bi′ + pi−1 > 15 . Однако
если переноса из тетрады не было, то результат сформируется "с избытком
6", поэтому потребуется коррекция тетрады предварительной суммы — уда-
ление из тетрады лишней тройки. Вычитание ( − 3 ) можно заменить сложе-
нием с дополнением до 3 — ( +13 ). Обязательно возникающий при этом пе-
ренос не передается в следующую тетраду. Потеря переноса равносильна
потере 16, т. е. −16 +13 = −3 .
Если перенос из тетрады был, то его вес равен 24 =16 , таким образом, из
тетрады удаляется 16, а вес десятичного переноса — 10. Поэтому перенос из
тетрады в коде "8421+3" уносит из тетрады лишнюю шестерку, которую
и нужно добавить при коррекции. Но согласно (3.32) сложение тетрад
"с избытком 3" приводит к получению суммы "с избытком 6", поэтому вме-
сто добавления шестерки достаточно добавить тройку.
Итак, коррекции при сложении в коде "8421+3" подлежат все тетрады пред-
варительной суммы, причем к тем тетрадам, из которых сформировался пе-
ренос, следует добавить константу 0011, а к тетрадам, из которых не было
переноса, добавить константу 1101. Возникающие при коррекции межтет-
радные переносы игнорируются!
Глава 3. Арифметические основы ЭВМ 73
Таким образом, коррекция при сложении в коде "8421+3", во-первых, опре-
деляется только значениями переносов из тетрад предварительной суммы и,
во-вторых, может проводиться параллельно во всех тетрадах.
Пример 3.29
Результат — на рис. 3.38.
А = 3852 = 0110 1011 1000 0101
B = 5179 = 1000 0100 1010 1100
C = 9031 1111 ←0000 ←0011 ←0001
1101 0011 0011 0011
= 1100 0011 0110 0100
12 – 3 = 9 3 – 3 = 0 6 – 3 = 3 4 – 3 = 1
Рис. 3.38. Результат выполнения примера 3.29
Еще одним достоинством кода "8421+3" является простой способ получения
дополнения до 9 — достаточно просто проинвертировать разряды кода.
Действительно, проинвертировав все разряды четырехразрядного двоичного
числа a , мы получим его дополнение до 1111 =1510 , что в коде "с избыт-
ком 3" соответствует 15 − (a + 3) = (9 − a) + 3 .
Это свойство позволяет довольно просто реализовать операцию вычитания
через сложение в обратном или дополнительном коде.
3.12. Машинная арифметика
в остаточных классах
Органическим недостатком любой позиционной системы счисления является
наличие межразрядных связей. Действительно, результат сложения в i -м
разряде зависит не только от значений i -х разрядов слагаемых, но и от пере-
носа из i −1 разряда и, в конечном итоге — от значений всех младших разря-
дов слагаемых: i −1, i − 2 , ..., 1, 0. Поэтому вычисление разрядов суммы мо-
жет проходить только последовательно (с учетом формирования переноса из
предыдущего (младшего) разряда). Это обстоятельство препятствует распа-
раллеливанию процесса вычисления и, естественно, снижает быстродействие
процессора.
74 Часть I. Принципы организации ЭВМ
В рамках позиционных систем счисления известно [6, 7, 9] несколько спосо-
бов логического и схемотехнического ускорения арифметических опера-
ций — параллельный перенос, матричная и табличная арифметика и др., од-
нако все они требуют весьма значительных аппаратных затрат.
Поиск новых путей построения арифметических устройств ЭВМ, позволяю-
щий исключить зависимость между разрядами при выполнении арифметиче-
ских операций, привел к применению в машинной арифметике аппарата
теории вычетов — одного из разделов теории чисел. В рамках этого аппара-
та разработана [1] непозиционная система счисления — система счисления
в остаточных классах (СОК).
3.12.1. Представление чисел
в системе остаточных классов
Будем говорить, что α есть остаток числа A по модулю p (иногда говорят,
что A сравнимо с α по модулю p ), если имеет место следующее равенство:
p
p
A
A ⋅ ⎥⎦
⎤
⎢⎣
⎡
α = − , (3.33)
где ⎥⎦
⎤
⎢⎣
⎡
p
A
— целая часть частного A p , причем a — наименьший целый
остаток от деления A на p .
Часто это соотношение записывают так:
α ≡ A (mod p) . (3.34)
Для представления чисел в СОК необходимо выбрать так называемую сис-
тему оснований — множество целых чисел p1 , p2 , ..., pn . Тогда любое чис-
ло A может быть представлено в СОК следующим образом:
A = (α1,α2 ,…,αn ) , (3.35)
где α ≡ A (mod p) .
Обозначим произведение
p p p pn P
n
i
i = ⋅ ⋅ ⋅ = Π=
1 2 …
1
. (3.36)
Можно показать [1], что если все основания pi — взаимно-простые числа, то
между числами 0, 1, 2, ..., (P −1) и числами, представленными в СОК соглас-
но (3.35), имеет место взаимно-однозначное соответствие.
Глава 3. Арифметические основы ЭВМ 75
Пример 3.30
Пусть p1 = 3 , p2 = 5 , p3 = 7 — взаимно-простые числа.
P = 3⋅5⋅ 7 = 105 .
Представим в СОК несколько десятичных чисел:
17 = (2,2,3) 1 = (1,1,1) 100 = (1,0,2)
63 = (0,3,0) 0 = (0,0,0) 105 = (0,0,0)
55 = (1,0,6) 11 = (2,1,4) 106 = (1,1,1)
Заметим, что при выходе за пределы диапазона [0, (P −1)] нарушается взаим-
но-однозначное соответствие между представлением чисел в позиционной
системе счисления и СОК. Действительно,
0 ≡105 ≡ 210 ≡ ... ≡ (mod 3) , (mod 5) , (mod 7) ;
1 ≡106 ≡ 211≡ ... ≡ (mod 3) , (mod 5) , (mod 7)
и т. д. Очевидно, для расширения диапазона представления чисел в СОК сле-
дует увеличить число и/или значения оснований.
3.12.2. Арифметические операции
с положительными числами
Рассмотрим правила выполнения операций сложения и умножения в СОК
в случае, если оба операнда и результат операции находятся в диапазоне [0, P).
Пусть
( , , , ),
( , , , ),
( , , , ),
( , , , ),
1 2
1 2
1 2
1 2
n
n
n
n
A B
A B
B
A
⋅ = δ δ δ
+ = γ γ γ
= β β β
= α α α
…
…
…
…
и при этом имеет место соотношение A < P , B < P , A + B < P , A⋅ B < P .
Покажем [1], что
( ) (mod ),
( ) (mod ),
i i i i
i i i i
p
p
δ = α ⋅β
γ = α + β
при этом в качестве цифры результата берется наименьший остаток
i
i
i i
i i i p
p
⋅
α + β
γ = α + β − , (3.37)
76 Часть I. Принципы организации ЭВМ
i
i
i i
i i i p
p
⋅
α ⋅β
δ = α ⋅β − . (3.38)
Действительно, на основании (3.33) можно написать
i
i
i i
i i i p
p
⋅
α + β
γ = α + β − , для i =1, 2, …, n .
Из представления A и B следует, что
A = ki pi + αi , B = li pi + βi , i =1, 2, …, n , (3.39)
где ki и li — целые неотрицательные числа. Тогда
A + B = (ki + li ) pi + αi + βi ,
⎥⎦
⎤
⎢⎣
⎡α + β
+ + = ⎥⎦
⎤
⎢⎣
⎡ +
i
i i
i i
i p
k l
p
A B
, i = 1, 2, …, n .
Откуда
i
i
i i
i i i p
p
⋅ ⎥⎦
⎤
⎢⎣
⎡α + β
γ = α + β − ,
что и доказывает (3.37).
В случае умножения
i
i
i p
p
A B
B A ⋅ ⎥⎦
⎤
⎢⎣
⎡ ⋅ δ = ⋅ − , i = 1, 2, …, n .
Учитывая (3.39), получим
A⋅ B = ki li pi + (αili + βiki )ki + αiβi 2 ,
⎥⎦
⎤
⎢⎣
⎡α ⋅β
+ β + α + = ⎥⎦
⎤
⎢⎣
⎡ ⋅
i
i i
i i i i i i i
i p
k l p l k
p
A B
, i = 1, 2, …, n .
Следовательно,
i
i
i i
i i i p
p
⋅ ⎥⎦
⎤
⎢⎣
⎡α ⋅β
δ = α ⋅β − ,
что и доказывает (3.38).
Рассмотрим несколько примеров, иллюстрирующих приведенные выше
правила.
Глава 3. Арифметические основы ЭВМ 77
Пример 3.31
Выполним сложение чисел, представленных в СОК. Результат — на рис. 3.39.
17 = (2,2,3) 55 = (1,0,6) 55 = (1,0,6)
63 = (0,3,0) + 17 = (2,2,3) 63 = (0,3,0)
80 ⇐ (2, 0, 3) 11 = (2,1,4) 118 ⇐ (1,3,6) = 13 = 118 – P
83 ⇐ (2,3,6)
Рис. 3.39. Результат выполнения примера 3.31
Обратите внимание, если результат выходит за пределы допустимого диапа-
зона ( A + B ≥ P ), то в СОК он неотличим от A + B − P (путем весьма слож-
ных ухищрений можно обнаружить переполнение суммы в СОК [1]).
Пример 3.32
Выполним умножение чисел, представленных в СОК. Результат — на
рис. 3.40.
17 = (2, 2,3) 78 = (0,3,1) 18 = (0,3,4)
6 = (0,1,6) 1 = (1,1,1) 5 = (2,0,5)
102 ⇐ (0,2, 4) 78 ⇐ (0,3,1) 90⇐ (0,0,6)
Рис. 3.40. Результат выполнения примера 3.32
Операция вычитания в общем случае в СОК не определена, т. к. в СОК от-
сутствуют отрицательные числа. Однако в частных случаях, когда A, B ,
(A − B)∈[0, P), можно записать
( ) (mod ), 1, 2, .
,
p i n
p
p
i i i i
i
i
i i
i i i
λ = α − β = …
⋅ ⎥⎦
⎤
⎢⎣
⎡α − β
λ = α − β −
(3.40)
Операция вычитания в тех случаях, когда ее результат положителен, выпол-
няется вычитанием соответствующих цифр разрядов по модулю соответст-
вующего основания, т. е. если цифра уменьшаемого меньше соответствующей
цифры вычитаемого, то к цифре уменьшаемого добавляется соответствую-
щее основание.
78 Часть I. Принципы организации ЭВМ
Пример 3.33
Рассмотрим вычитание A − B для случаев A > B . Результат — на
рис. 3.41.
17 = (2,2,3) 78 = (0,3,1) 98 = (2,3,0)
6 = (0,1,6) 41 = (2,1,6) 55 = (1,0,6)
11 ⇐ (2,1,4) 37 ⇐ (1,2, 2) 43 ⇐ (1,3,1)
Рис. 3.41. Результат выполнения примера 3.33
3.12.3. Арифметические операции
с отрицательными числами
Если необходимо оперировать отрицательными числами, можно ввести так
называемые искусственные формы представления чисел в СОК. Выражение
(3.36) определяет диапазон представления чисел в СОК с основаниями p1 ,
p2 , ..., pn . Пусть одно из оснований системы равно 2, например, для опреде-
ленности p1 = 2 .
Обозначим через 􀀽 величину
(1, 0, 0, 0)
2 1 1 1
1
􀀽 = = = p ⋅ p ⋅…p = …
p
P P
.
Будем оперировать числами, лежащими в диапазоне 0 < N < 􀀽 .
Примем в качестве нуля число 􀀽 и будем представлять положительные числа
N = N в виде N′ = 􀀽 + N , а отрицательные числа N = − N в виде
N′ = 􀀽 − N . Тогда при алгебраическом суммировании получим следующий
вид представления положительных и отрицательных чисел:
N′ = 􀀽 + N .
Это означает, что в принятом представлении мы всегда будем иметь дело
с положительными числами, однако числа в искусственной форме N′ в ин-
тервале [0, 􀀽) будут отображать отрицательные числа, а в интервале [􀀽, P) —
положительные.
Глава 4
Организация устройств ЭВМ
4.1. Принцип
микропрограммного управления
Для выполнения операций над информацией используются операционные
устройства — арифметико-логические, управления, контроллеры ВУ и т. п.
Функцией операционного устройства является выполнение заданного множе-
ства операций F = {f1, f 2 , ..., fK } над входными словами из множества DI
с целью вычисления выходных слов из множества DO , представляющих ре-
зультаты операций DO = fk (DI ) , k = 1, ..., K .
Функциональная и структурная организация операционных устройств, опре-
деляющая порядок функционирования и структуру устройств, базируется на
принципе микропрограммного управления, который состоит в следующем [7]:
1. Любая операция fk , реализуемая устройством, рассматривается как
сложное действие, которое разделяется на последовательность элементар-
ных действий над словами информации, называемых микрооперациями.
2. Для управления порядком следования микроопераций используются логи-
ческие условия, которые, в зависимости от значений слов, преобразуемых
микрооперациями, принимают значения "истина" или "ложь" (1 или 0).
3. Процесс выполнения операций в устройстве описывается в форме алго-
ритма, представляемого в терминах микроопераций и логических условий
и называемого микропрограммой. Микропрограмма определяет порядок
проверки значений логических условий и следования микроопераций, не-
обходимый для получения требуемых результатов.
4. Микропрограмма используется как форма представления функции уст-
ройства, на основе которой определяются структура и порядок функцио-
нирования устройства во времени.
80 Часть I. Принципы организации ЭВМ
Сказанное можно рассматривать как содержательное описание принципа
микропрограммного управления, из которого следует, что структура и поря-
док функционирования операционного устройства предопределяются алго-
ритмами выполнения операций из F .
4.2. Концепция операционного
и управляющего автоматов
В функциональном и структурном отношении операционное устройство,
входящее в состав ЭВМ, удобно представить разделенным на две части: опе-
рационный и управляющий автоматы (рис. 4.1).
Рис. 4.1. Устройство как композиция автоматов
Операционный автомат (ОА) служит для хранения слов информации, вы-
полнения набора микроопераций и вычисления значений логических усло-
вий, т. е. операционный автомат является структурой, организованной для
выполнения действий над информацией. На вход ОА подаются входные дан-
ные DI , которые в соответствии с алгоритмом операции преобразуются
в выходные данные DO . Кроме того, ОА вырабатывает множество {x} осве-
домительных сигналов (логических условий) для управляющего автомата.
Управляющий автомат (УА) генерирует последовательность управляющих
сигналов { } y , обеспечивающую выполнение в операционном автомате за-
данной последовательности элементарных действий, которая реализует алго-
ритм выполняемой операции. Управляющая последовательность генерирует-
ся в соответствии с заданным алгоритмом и с учетом значений логических
условий x , формируемых ОА.
Часто операционное устройство может выполнять несколько различных опе-
раций (например, арифметико-логическое устройство может выполнять че-
тыре арифметических действия и несколько логических операций над вход-
ными словами). В этом случае на вход УА поступает команда C ,
Глава 4. Организация устройств ЭВМ 81
определяющая тип выполняемой операции. Кроме того, поскольку различные
операции над различными данными выполняются за разное время, УА фор-
мирует сигнал g , отмечающий окончание операции и готовность выходных
данных.
Таким образом, любое операционное устройство — процессор (который
обычно, в свою очередь, представляют состоящим из двух операционных
устройств: АЛУ — арифметико-логического устройства и ЦУУ — централь-
ного устройства управления), канал ввода/вывода, контроллер внешнего уст-
ройства — можно представить как композицию операционного и управляю-
щего автоматов. Операционный автомат, реализуя действия над словами
информации, является исполнительной частью устройства, работу которого
организует управляющий автомат, генерирующий необходимые последова-
тельности управляющих сигналов.
Такой подход позволяет разработать эффективные процедуры синтеза ОА
и УА, формализовать эти процедуры и, в некоторых случаях, автоматизиро-
вать процесс синтеза цифровых устройств.
4.3. Операционный автомат
Исходными для разработки структуры операционного автомата (ОА) являются:
􀂈 описание входных и выходных слов ОА (множеств DI и DO );
􀂈 список множества операций из F , которые должны выполняться над
словами.
Процесс разработки ОА, таким образом, следует начинать с определения
форматов входных и выходных слов и разработки алгоритмов выполнения
операций в терминах слов и стандартных действий над словами (сложение,
копирование, инверсия, сдвиг и т. д.). Разработанные алгоритмы удобно
представить в форме граф-схемы алгоритма (ГСА).
Далее необходимо разработать структуру ОА. Операционный автомат стро-
ится на базе операционных и логических элементов. Предложенные про-
цедуры формального синтеза ОА [7] не получили широкого распростране-
ния; обычно используют так называемый "содержательный" метод синтеза.
Разработать структуру — значит определить набор элементов, входящих
в нее, и установить связи между этими элементами. Структура реализуется,
исходя из разработанных на предыдущем этапе алгоритмов таким образом,
чтобы обеспечить реализацию всех действий, предусмотренных в оператор-
ных вершинах ГСА.
82 Часть I. Принципы организации ЭВМ
Действия в структуре ОА выполняются под управлением микроопераций,
поэтому при разработке ОА следует определить полный список микроопера-
ций, наличие которых обеспечит выполнение в разработанной структуре всех
предусмотренных в алгоритмах преобразований слов.
Наконец, формирование последовательности микроопераций в управляющем
автомате осуществляется с учетом значений логических условий, которые
формируются в ОА. Поэтому при разработке ОА следует сформировать
список логических условий, определяемый содержимым условных вершин
ГСА, и предусмотреть в структуре ОА (если это необходимо) специальные
элементы для формирования этих логических условий.
Итак, процесс разработки ОА можно представить состоящим из следующих
этапов:
1. Определение форматов входных и выходных данных (слов).
2. Разработка ГСА выполняемых операций.
3. Разработка структуры ОА — выбор элементов и организация связей.
4. Определения множества { } y микроопераций, выполняемых в ОА.
5. Определения множества {x} логических условий, формируемых в ОА.
4.3.1. Пример проектирования
операционного автомата АЛУ
В качестве примера рассмотрим разработку операционного автомата арифме-
тического устройства, реализующего операцию деления чисел с фиксирован-
ной запятой, представленных в прямом коде.
Определение форматов данных
Будем считать, что в арифметической операции деления участвуют операнды
A — делимое и B — делитель. Результат операции C — частное. Кроме
того, устройство должно формировать признаки результата — двоичные пе-
ременные:
􀂈 Z — признак нулевого результата;
􀂈 S — признак отрицательного результата;
􀂈 OV — признак переполнения.
Алгоритм операции алгебраического деления разрабатывается для 16-раз-
рядных двоичных чисел с фиксированной запятой, представленных в прямом
коде. Знак числа кодируется в старшем (нулевом) разряде числа, запятая
Глава 4. Организация устройств ЭВМ 83
фиксирована после знакового разряда, таким образом, все числа могут быть
только дробными (рис. 4.2).
Рис. 4.2. Представление числа в прямом коде
Итак, в операциях участвуют следующие переменные:
􀂈 A = a0a1a2...a15 — первый операнд (делимое);
􀂈 B = b0b1b2...b15 — второй операнд (делитель);
􀂈 C = c0c1c2...c15 — результат операции (частное), в процессе выполнения
алгоритма переменная C используется для хранения остатка;
􀂈 D = d0d1d2...d15 — переменная, в которой в процессе деления накаплива-
ются цифры частного;
􀂈 a0 , b0 , c0 — знаковые разряды.
Разработка алгоритма деления
В прямых кодах удобнее делить модули чисел. Знак результата не зависит от
соотношения модулей делимого и делителя и определяется по выраже-
нию (4.1).
c0 = a0b0 ∨ a0b0. (4.1)
Деление чисел с фиксированной запятой в заданном формате невозможно, если
модуль делимого не меньше модуля делителя. Поэтому сначала следует прове-
рить соотношение операндов путем вычитания делителя из делимого. Если
разность окажется положительной, то можно формировать признак переполне-
ния OV = 1 и завершать операцию. В противном случае модуль частного ока-
зывается меньше 1, т. е. переполнение отсутствует и деление возможно.
Алгоритмы деления с восстановлением остатка и без восстановления ос-
татка подробно рассмотрены в разд. 3.9. Учитывая приведенный там срав-
нительный анализ алгоритмов, выберем метод деления без восстановления
остатка.
ГСА деления без восстановления остатка представлена на рис. 4.3. Алго-
ритм предусматривает формирование знака результата согласно формуле
(4.1) и сохранение его временно в переменной s . После этого производится
деление модулей чисел (знаки операндов обнуляются).
84 Часть I. Принципы организации ЭВМ
Начало
a b 0 0 =
да нет
s := 0 s := 1
a 0 := 0
b 0 := 0
C := A – B
c0
1
0
OV := 0 OV := 1
n := 16
A := C
A := L1(A)
0 1
c0
C := A – B C := A + B
D[15] := 1 D[15] := 0
D := L1(D)
n := n – 1
n = 0
C := D
c s 0 :=
Конец
да
нет
Рис. 4.3. Граф-схема алгоритма деления
Глава 4. Организация устройств ЭВМ 85
Сначала производится пробное вычитание делителя из делимого. Поскольку
знаки операндов — 0, то появление 1 в знаковом разряде разности означает,
что A < B , и можно продолжать деление (целая часть частного равна 0).
При c0 = 0 деление невозможно — формируется признак переполнения.
В процессе получения цифр частного значение очередного остатка принима-
ет переменная C . Независимо от знака остатка она копируется в переменную
A, которая затем увеличивается вдвое путем сдвига влево на один разряд.
В зависимости от знака переменной C (знака остатка) формируется очеред-
ная цифра переменной D (частного) и принимается решение о действии на
следующем шаге — добавлять или вычитать делитель из сдвинутого остатка.
После арифметической операции выполняется сдвиг влево частного D (ос-
вобождается место для очередной цифры частного), изменяется счетчик
цифр частного и проверяется условие выхода из цикла — получение шестна-
дцати цифр частного, включая самую первую цифру — "0 целых", на место
которой копируется знак частного из переменной s .
Разработка структуры операционного автомата
Анализ алгоритма деления (см. рис. 4.3) позволяет разработать структуру
операционного автомата. Учитывая действия, которые требуется выполнить
для реализации алгоритма, включим в состав операционного автомата сле-
дующие элементы:
􀂈 два шестнадцатиразрядных регистра Рг А и Рг В для хранения входных
операндов и промежуточных результатов, причем регистр Рг А должен
обеспечить возможность сдвига своего содержимого влево;
􀂈 шестнадцатиразрядный регистр Рг С для размещения результата арифме-
тической операции сложения или вычитания (в нашем случае в этом реги-
стре формируется остаток): в конце операции в нем будет размещен ре-
зультат — частное;
􀂈 шестнадцатиразрядный регистр Рг D с возможностью левого сдвига кода
для размещения частного в процессе его формирования;
􀂈 шестнадцатиразрядный двоичный параллельный сумматор/вычитатель
Сум/Выч;
􀂈 четырехразрядный вычитающий счетчик Сч n по модулю 16 для подсчета
цифр частного;
􀂈 триггер переполнения Тг OV для хранения признака переполнения раз-
рядной сетки;
􀂈 триггер знака Тг s для временного хранения знака частного;
86 Часть I. Принципы организации ЭВМ
􀂈 схема сравнения на "равно" знаковых разрядов исходных операндов;
􀂈 дешифратор DC "0" нулевой комбинации в разрядах С[1 : 15], форми-
рующий признак нулевого результата Z .
Связи между перечисленными выше элементами, а также управляющие ими
микрооперации показаны на рис. 4.4, а в табл. 4.1 приведен полный список
микроопераций и логических условий.
Внимательно посмотрим на рис. 4.4. Очевидно, любые действия, обозначен-
ные в операторных вершинах алгоритма, приведенного на рис. 4.3, могут
быть реализованы на разработанной нами структуре (см. рис. 4.4).
Теперь определим, какая последовательность микроопераций должна быть
реализована в разработанной структуре, чтобы выполнилась операция деле-
ния, предусмотренная алгоритмом рис. 4.3. Простейшее решение — сохра-
нить топологию графа алгоритма и заменить содержимое его операторных
вершин на соответствующие микрооперации, а содержимое условных вер-
шин — на соответствующие логические условия.
Рис. 4.4. Операционный автомат АЛУ
Глава 4. Организация устройств ЭВМ 87
Таблица 4.1. Список микроопераций и логических условий
Микро-
операция Действие Микро-
операция Действие Логическое
условие Отношение
y1 s := 0 10 y A:= L1(A) 1 x a0 = b0
2 y s :=1 11 y D[15] :=1 2 x 0 c
3 y 0a := 0 12 y D[15] := 0 3 x Сч n = 0
4 y 0b := 0 13 y C := A + B
5 y C := R + S 14 y D:= L1(D)
6 y OV := 0 15 y Сч n := Сч − 1
7 y OV :=1 16 y C := D
8 y n :=16 17 y 0 c := s
9 y A:= C
Полученный таким образом граф принято называть микропрограммой и рас-
сматривать в качестве исходных данных при проектировании управляющего
(микропрограммного) автомата. При этом содержимое операторной верши-
ны графа соответствует действиям, выполняемым устройством в один такт
дискретного времени.
При проектировании цифровых устройств обычно стремятся достичь макси-
мальной скорости их работы. Один из путей достижения этой цели — парал-
лельное (во времени) выполнение некоторых операций. Поэтому при преоб-
разовании графа алгоритма в граф микропрограммы следует объединять в
одной операторной вершине те микрооперации, которые могут быть в данной
структуре выполнены одновременно с учетом реализуемого алгоритма. Со-
вокупность микроопераций, выполняемых одновременно в один такт дис-
кретного времени, называется микрокомандой.
Например, анализируя ГСА рис. 4.3, можно отметить, что операторы a0 := 0 ;
b0 := 0 можно выполнить в структуре, изображенной на рис. 4.4, одновре-
менно. То же можно сказать о паре операторов D := L1(D) ; n := n −1 и неко-
торых других. В то же время, операторы A:= C , A:= L1(A) нельзя выполнять
одновременно. (Для ускорения этой процедуры можно передавать информа-
цию из C в A со сдвигом: C := L1(A) , но это уже будет другая структу-
ра ОА.)
88 Часть I. Принципы организации ЭВМ
Рис. 4.5. Микропрограмма деления
Глава 4. Организация устройств ЭВМ 89
Проанализировав с этой точки зрения исходный алгоритм, получим микро-
программу, приведенную на рис. 4.5. Микропрограмма определяет, в какой
последовательности и в зависимости от каких условий должны выдаваться
микрокоманды, чтобы реализовалась операция деления на разработанной
структуре (см. рис. 4.4) операционного автомата.
Следующая задача — построить управляющий автомат, обеспечивающий
выдачу микрокоманд в заданной микропрограммой последовательности.
4.4. Управляющий автомат
Исходным для проектирования управляющего автомата (УА) является мик-
ропрограмма, представленная, например, в форме ГСА.
Различают два класса управляющих автоматов [2, 7]:
􀂈 с "жесткой" логикой:
• автомат Мура;
• автомат Мили;
• С-автомат;
􀂈 с программируемой логикой.
4.4.1. Управляющий автомат с "жесткой" логикой
Автоматы с "жесткой" логикой проектируются как обычные конечные струк-
турные автоматы [2, 7, 8, 12].
Сначала необходимо перейти от ГСА микропрограммы к графу автомата, для
чего следует:
1. Разметить исходную микропрограмму.
2. Построить по размеченной микропрограмме граф автомата.
Далее реализуются стандартные процедуры синтеза структурного автомата,
заданного графом:
􀂈 кодирование алфавита входных и выходных символов автомата двоичны-
ми кодами;
􀂈 кодирование внутренних состояний автомата;
􀂈 выбор элемента памяти (типа триггера);
􀂈 построение автоматной таблицы переходов;
􀂈 синтез комбинационной схемы, реализующей функцию переходов КСх 1;
􀂈 синтез комбинационной схемы, реализующей функцию выходов КСх 2.
90 Часть I. Принципы организации ЭВМ
Процедура разметки микропрограммы ставит в соответствие символам со-
стояний автомата ( a1 , a2 , ..., aM ) некоторые объекты микропрограммы.
Способы разметки микропрограмм различаются для автоматов различных
типов.
Для автомата Мура разметка выполняется по следующим правилам [2]:
􀂈 символом a1 отмечается начальная и конечная вершина ГСА;
􀂈 различные операторные вершины отмечаются разными символами со-
стояний;
􀂈 все операторные вершины должны быть отмечены.
Для автомата Мили разметка выполняется по следующим правилам [2]:
􀂈 символом a1 отмечается вход вершины, следующей за начальной, а также
вход конечной вершины;
􀂈 входы всех вершин, следующих за операторными, должны быть отмечены
символами состояний;
􀂈 если вход вершины отмечается, то лишь одним символом;
􀂈 входы различных вершин, за исключением конечной, отмечаются различ-
ными символами.
Пример проектирования УАЖЛ
Рассмотрим пример построения управляющего автомата Мура для устройст-
ва, реализующего операцию деления. Операционный автомат (см. рис. 4.4) и
ГСА микропрограммы (см. рис. 4.5) этого устройства были построены ранее.
Шаг 1. Выполним разметку микропрограммы. Для этого сопоставим каждой
операторной вершине ГСА в произвольном порядке (например, слева напра-
во и сверху вниз) символ состояния автомата из множества{ } a2 ,a3 , ..., a14 .
Начальную и конечную вершины сопоставим с начальным состоянием авто-
мата a1 . Такая разметка показана на рис. 4.5.
Шаг 2. Построим граф автомата, заданного размеченной микропрограм-
мой, которую получили на предыдущем шаге. Для этого вершины графа
сопоставим с состояниями автомата a1 , a2 , ..., a14 . Соединим ориентирован-
ными ребрами те пары вершин графа, между которыми на ГСА микропро-
граммы существуют переходы, причем пометим ребра графа соответствую-
щими условиями перехода. Если переход между двумя операторными
вершинами микропрограммы осуществляется безусловно, то условие перехо-
да на ребре графа — константа 1.
Глава 4. Организация устройств ЭВМ 91
Построив таким образом граф, мы фактически задаем алфавиты внутренних
состояний и входных символов и определяем функцию переходов. Для зада-
ния алфавита выходных символов и функции выходов (для автомата Мура
функция выходов зависит только от его состояний) следует сопоставить каж-
дой вершине автомата в качестве выходного символа содержимое соответст-
вующей операторной вершины ГСА микропрограммы. Таким образом, полу-
чим граф микропрограммного автомата, который приведен на рис. 4.6.
Рис. 4.6. Граф микропрограммного автомата Мура
Шаг 3. Кодирование алфавитов входных и выходных символов автомата дво-
ичными кодами. Алфавит входных символов составляет множество двоичных
переменных X = {x1, x2 , x3}, поэтому проблема кодирования входных симво-
лов двоичными переменными здесь не стоит. Что касается кодирования сим-
волов выходного алфавита, то отложим обсуждение этого вопроса до шага 8.
Шаг 4. В процессе кодирования внутренних состояний автомата могут ре-
шаться проблемы исключения гонок в автомате, проблемы минимизации
комбинационной схемы, обеспечивающей функцию переходов автомата. Для
решения этих задач разработаны достаточно сложные алгоритмы, которые
описаны в литературе, например, [2, 5]. Здесь мы не будем касаться этой сто-
роны процедуры синтеза автомата.
92 Часть I. Принципы организации ЭВМ
Следует отметить, что проблемы гонок могут быть полностью решены при
использовании в автомате двухтактных элементов памяти, причем способ
кодирования состояний в этом случае роли не играет. Правда, затраты обору-
дования при таком решении несколько возрастают, по сравнению с исполь-
зованием метода противогоночного кодирования, но во-первых, эффектив-
ность метода заметно проявится лишь при достаточно большом числе
состояний автомата (25—40), а во-вторых, большинство современных инте-
гральных элементов памяти (триггеров) выпускаются именно двухтактными.
Применение специальных методов кодирования "с учетом сложности комби-
национных схем" [2] так же обеспечивает заметный эффект лишь для доста-
точно громоздких автоматов.
В нашем примере воспользуемся простейшим методом кодирования состоя-
ний автомата, когда код состояния совпадает с двоичным числом, соответст-
вующим номеру состояния. В рассматриваемом автомате насчитывается
14 состояний (см. рис. 4.6), поэтому для их кодирования требуется четырех-
разрядный двоичный код ( 24 >14 ; 23 < 14 ) — табл. 4.2.
Таблица 4.2. Кодирование состояний автомата
Состояние автомата Код T1 T2 T3 T4 Состояние автомата Код T1 T2 T3 T4
a1 0001 a8 1000
a2 0010 a9 1001
a3 0011 a10 1010
a4 0100 a11 1011
a5 0101 a12 1100
a6 0110 a13 1101
a7 0111 a14 1110
Шаг 5. Выбор элемента памяти (типа триггера). При выборе элемента памя-
ти следует учитывать простоту управления им. С этой точки зрения удобнее
выбирать триггеры, управляемые по единственному информационному вхо-
ду — к таким относятся D- и Т-триггеры. В нашем примере в качестве эле-
мента памяти автомата выберем синхронный двухтактный D-триггер. Оче-
видно, для реализации нашего автомата понадобятся четыре D-триггера.
Шаг 6. Построение автоматной таблицы переходов (табл. 4.3).
Эта таблица практически описывает функцию переходов автомата, стро-
ится по графу автомата и определяет, какие значения необходимо подать
Глава 4. Организация устройств ЭВМ 93
на управляющие входы триггеров на каждом переходе автомата в новое со-
стояние. Строка таблицы соответствует одному переходу автомата. Таким
образом, автоматная таблица содержит столько строк, сколько ребер в графе
автомата (включая и петли, если они имеются в графе).
Таблица 4.3. Автоматная таблица переходов
Исходное
состояние
Условие
перехода
Состояние
перехода
Функции возбуждения
D1 D2 D3 D4
( 1 a ) 0001 1 x
1 x
( 2 a ) 0010
( 3 a ) 0011
0
0
0
0
1
1
0
1
( 2 a ) 0010 1 ( 4 a ) 0100 0 1 0 0
( 3 a ) 0011 1 ( 4 a ) 0100 0 1 0 0
( 4 a ) 0100 1 ( 5 a ) 0101 0 1 0 1
( 5 a ) 0101 2 x
2 x
( 6 a ) 0110
( 7 a ) 0111
0
0
1
1
1
1
0
1
( 6 a ) 0110 1 ( 8 a ) 1000 1 0 0 0
( 7 a ) 0111 1 ( 1 a ) 0001 0 0 0 1
( 8 a ) 1000 1 ( 9 a ) 1001 1 0 0 1
( 9 a ) 1001 2 x
2 x
( 11 a ) 1011
( 10 a ) 1010
1
1
0
0
1
1
1
0
( 10 a ) 1010 1 ( 12 a ) 1100 1 1 0 0
( 11 a ) 1011 1 ( 12 a ) 1100 1 1 0 0
( 12 a ) 1100 3 x
3 x
( 13 a ) 1101
( 8 a ) 1000
1
1
1
0
0
0
1
0
( 13 a ) 1101 1 ( 14 a ) 1110 1 1 1 0
( 14 a ) 1110 1 ( 1 a ) 0001 0 0 0 1
Шаг 7. Синтез комбинационной схемы, реализующей функцию переходов
автомата. Эта комбинационная схема в нашем случае реализует четыре буле-
94 Часть I. Принципы организации ЭВМ
вы функции D1 , D2 , D3 , D4 , зависящие от четырехразрядного двоичного
кода состояния автомата T1T2T3T4 и трехбитного вектора входных символов
x1x2 x3 . Комбинационная схема, описываемая системой четырех булевых
функций от семи переменных, должна обеспечивать переходы автомата
в соответствии с графом рис. 4.6.
Для построения этой схемы можно построить четыре карты Карно для D1 ,
D2 , D3 , D4 по таблицам истинности, заданным соответствующими столб-
цами автоматной таблицы переходов, и минимизировать эти функции. Менее
трудоемкий способ состоит в предварительной дешифрации состояний авто-
мата (булевы функции четырех переменных) и записи функций возбуждения
через значения ai и xk . Воспользуемся последним способом, тем более, что
дешифрированные состояния автомата пригодятся нам и на следующем шаге
при формировании функции выходов.
Итак, предусмотрим дешифратор, на входы которого поступает двоичный
код состояния автомата 1 2 3 4
~ ~ ~ ~
T T T T , а на выходах формируется унитарный код
a1...ai−1aiai+1...a14 . Кстати, поскольку на входах дешифратора не могут по-
явиться комбинации 0000 и 1111 (их мы не использовали при кодировании
состояний), то схему дешифратора можно минимизировать. (Как? Попробуй-
те построить такой дешифратор самостоятельно.) Рассмотрим столбец D1
автоматной таблицы переходов, отметив те наборы входных переменных
функции возбуждения (из {a} и {x}), на которых D1 принимает единичные
значения. Можно записать:
D1 = a6 ∨ a8 ∨ a9 ∨ a10 ∨ a11 ∨ a12 ∨ a13 . (4.2)
Обратите внимание, что функция D1 не зависит от входных переменных {x}
(частный случай!). Действительно, переход, например, из состояния a9 в за-
висимости от значения x2 может произойти в a10 или в a11 , но в обоих этих
состояниях значение старшего разряда кодов одинаково. То же для D1 мож-
но сказать и обо всех остальных переходах, зависящих от входных символов
(из a1 , a5 , a12 ).
Теперь запишем булевы выражения для остальных функций возбуждения.
D2 = a2 ∨ a3 ∨ a4 ∨ a5 ∨ a10 ∨ a11 ∨ a12 x3 ∨ a13 . (4.3)
D3 = a1 ∨ a5 ∨ a9 ∨ a13 . (4.4)
D4 = a1x1 ∨ a4 ∨ a5x2 ∨ a7 ∨ a8 ∨ a9 x2 ∨ a12 x3 ∨ a14 . (4.5)
Глава 4. Организация устройств ЭВМ 95
Шаг 8. Синтез комбинационной схемы, реализующей функцию выходов.
Функция выходов автомата Мура зависит только от его внутреннего состоя-
ния и задана непосредственно на графе автомата (см. рис. 4.6). Выходами мик-
ропрограммного автомата являются микрооперации, поступающие в точки
управления операционного автомата. Поэтому выходные символы микро-
программного автомата обычно не кодируют, а формируют на выходе значе-
ние вектора микроопераций. При большом числе микроопераций с целью
уменьшения связности между ОА и УА на вход ОА передают не вектор мик-
роопераций, а номер активной в данном такте микрооперации. Подробнее об
этом — в следующем разделе.
Из графа автомата (см. рис. 4.6) видно, что микрооперация y1 должна выра-
батываться автоматом, когда он находится в состоянии a2 , микрооперация
y2 — в состоянии a3 и т. д. Микрооперация y5 должна вырабатываться ав-
томатом, находящимся в состоянии a5 и a10 . Запишем функцию выходов
автомата в виде системы булевых функций1:
, , .
, , , , , , ,
, , , , , , ,
15 12 16 13 17 14
8 6 9 8 10 9 11 10 12 11 13 11 14 12
1 2 2 3 3 4 4 4 5 5 10 6 6 7 7
y a y a y a
y a y a y a y a y a y a y a
y a y a y a y a y a a y a y a
= = =
= = = = = = =
= = = = = ∨ = =
(4.6)
Шаг 9. Теперь изобразим функциональную схему управляющего автомата,
используя выражения (4.2)—(4.6) с учетом выбранного типа элемента памяти.
Управляющий микропрограммный автомат с жесткой логикой (автомат
Мура), изображенный на рис. 4.7, имеет три двоичных входа x1 , x2 , x3 , вход
тактового сигнала CLK и семнадцать двоичных выходов — микрооперации
y1 , y2 , ..., y17 .
Память автомата представлена четырьмя двухтактными синхронными D-триг-
герами, объединенными общей цепью синхронизации (CLK). Выходы триг-
геров поступают на вход дешифратора DC "4 → 16", на выходах которого
формируется унитарный код текущего состояния автомата. Поскольку проек-
тируемый автомат является автоматом Мура, выходы дешифратора фактиче-
ски являются выходами управляющего автомата (значениями микроопера-
ций). Исключение составляет микрооперация y5 , которая формируется как
дизъюнкция двух различных состояний автомата, поскольку эта микроопера-
ция присутствует в двух различных операторных вершинах исходной микро-
программы (см. рис. 4.5).
1 Напомним, что переменные а1, а2, …, а14 являются булевыми, принимающими единичное
значение, когда автомат находится в соответствующем состоянии, и нулевое значение — во
всех остальных случаях.
96 Часть I. Принципы организации ЭВМ
Рис. 4.7. Микропрограммный автомат Мура — функциональная схема
Глава 4. Организация устройств ЭВМ 97
Функции возбуждения триггеров формируют значения Di , i∈{1, 2, 3, 4} на
выходах одно- или двухуровневых схем, построенных согласно выражениям
(4.2)—(4.5). Обратите внимание, что в выражениях (4.3) и (4.5) имеется оди-
наковый терм — a12x3 . На функциональной схеме выход конъюнктора, реа-
лизующего этот терм, поступает на два входа различных дизъюнкторов,
"обеспечивая" одновременно две функции возбуждения — D2 и D4 .
Схемы, реализующие функции возбуждения, можно построить иначе. Для
примера рассмотрим выражение (4.4). Состояния автомата, входящие в это
выражение, если выразить их через значения состояний триггеров, окажутся
соседними и склеиваются. Действительно:
1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 3 4.
3 1 5 9 13
T T T T T T T T T T T T T T T T T T
D a a a a
= ∨ ∨ ∨ =
= ∨ ∨ ∨ =
(4.7)
Очевидно, схема, реализованная по выражению (4.7), будет проще, чем схема
(4.4). Проверьте, можно ли подобным образом минимизировать выражения
остальных функций возбуждения.
Итак, мы построили микропрограммный автомат с "жесткой" логикой. Да-
вайте представим, что нам понадобилось незначительно изменить исходную
микропрограмму, например, добавить еще одну операторную вершину.
Практически это приведет к необходимости полного перепроектирования
всей схемы автомата. Эта особенность автоматов с "жесткой" логикой явля-
ется их серьезным недостатком.
Для того чтобы уменьшить зависимость структуры автомата от реализуемых
им микропрограмм, используют управляющие автоматы с программируемой
логикой.
4.4.2. Управляющий автомат
с программируемой логикой
Принципы организации
Заметим, что функция любого управляющего автомата — генерирование по-
следовательности управляющих слов (микрокоманд), определенной реали-
зуемым алгоритмом с учетом значений осведомительных сигналов.
Если заранее разместить в запоминающем устройстве все необходимые для
реализации заданного алгоритма (группы алгоритмов) микрокоманды, а по-
том выбирать их из памяти в порядке, предусмотренном алгоритмом (с уче-
том значения осведомительных сигналов), то получим управляющий автомат,
98 Часть I. Принципы организации ЭВМ
структура которого слабо зависит от реализуемых алгоритмов, а поведение
в основном определяется содержимым запоминающего устройства.
При изменениях реализуемого алгоритма в достаточно широких пределах
структура такого автомата не меняется, достаточно лишь изменить содержи-
мое ячеек запоминающего устройства. Управляющий микропрограммный
автомат, построенный по таким принципам, называется управляющим авто-
матом с программируемой логикой.
Структурная схема такого автомата в самом общем виде приведена на
рис. 4.8. Автомат включает в себя запоминающее устройство микрокоманд
(обычно реализуемое как ПЗУ), регистр микрокоманд и устройство форми-
рования адреса микрокоманды.
В каждом такте дискретного времени из памяти микрокоманд считывается
одна микрокоманда, которая помещается в регистр микрокоманд. Микроко-
манда содержит два поля (две группы полей), одно из которых определяет
набор микроопераций, которые в данном такте поступают в операционный
автомат, а другое содержит информацию для определения адреса следующей
микрокоманды.
При проектировании управляющего автомата с программируемой логикой
(УАПЛ) необходимо выбрать формат (форматы) микрокоманд (микрокоман-
ды), способы кодирования микроопераций и адресации микрокоманд.
Рис. 4.8. Микропрограммный автомат с программируемой логикой
Глава 4. Организация устройств ЭВМ 99
Адресация микрокоманд
Исходными данными для проектирования УАПЛ является, как и для УАЖЛ
(управляющий автомат с "жесткой" логикой), микропрограмма, представлен-
ная, например, в форме ГСА. Каждая операторная вершина должна реализо-
ваться в один такт машинного времени, причем после операторной вершины
в ГСА может следовать:
􀂈 операторная вершина;
􀂈 условная вершина, оба выхода которой или один из них соединены с опе-
раторными вершинами, например, как показано на рис. 4.9, а;
􀂈 цепочка из двух или более условных вершин, выходы которых соединены
с условными вершинами (рис. 4.9, б).
а б
Рис. 4.9. Фрагменты ГСА-микропрограмм
В первом случае осуществляется безусловный переход к следующей микро-
команде, и адрес этой единственной микрокоманды (А1) должен размещать-
ся в поле адреса выполняемой микрокоманды.
Во втором случае необходимо сделать выбор одного из двух возможных сле-
дующих адресов. В поле адреса микрокоманды надо разместить:
􀂈 номер x логического условия, по значению которого осуществляется выбор;
􀂈 адрес A1 микрокоманды, которая будет выполняться, если указанное
условие истинно;
􀂈 адрес А0 микрокоманды, которая будет выполняться, если указанное
условие ложно.
100 Часть I. Принципы организации ЭВМ
В третьем случае количество проверяемых в микрокоманде условий и адре-
сов переходов может быть произвольным, в т. ч. и достаточно большим.
В этом случае длина микрокоманды может быть весьма велика.
При выборе формата микрокоманды нужно учитывать следующие обстоя-
тельства:
􀂈 надо эффективно использовать разряды поля, обеспечив по возможности
его минимальную длину;
􀂈 желательно ограничиться единственным форматом микрокоманды, в край-
нем случае, выбирать минимально возможное разнообразие форматов.
Справедливость первого требования очевидна. Относительно второй предпо-
сылки можно заметить, что при большом числе форматов соответственно
усложняется схема декодирования микрокоманды.
Значит, если в рамках одного формата микрокоманды обеспечить реализа-
цию всех возможных вариантов следования вершин, то в третьем случае по-
требуется предусмотреть в микрокоманде несколько полей номеров логиче-
ских условий и столько же плюс одно поле адресов микрокоманд. Учитывая,
что в большинстве алгоритмов длинные цепочки логических вершин встре-
чаются довольно редко, организация подобного формата микрокоманды бу-
дет весьма неэффективна — ведь для второго случая будут использоваться
только одно поле логического условия и два поля адреса, а для первого слу-
чая — только одно поле адреса.
Чаще всего в быстродействующих УАПЛ используется формат микрокоман-
ды, приведенный на рис. 4.10. Такой способ адресации микрокоманд принято
называть принудительным, здесь явно указываются оба возможных адреса
перехода, причем расположение микрокоманд в ячейках памяти может быть
произвольным.
Рис. 4.10. Формат микрокоманды при принудительной адресации
Если в ГСА встречаются цепочки из k последовательных условных вершин,
последняя из которых связана с операторной вершиной, то для их реализации
в рамках формата микрокоманды, представленной на рис. 4.10, потребуется
k микрокоманд (а следовательно, k тактов), в каждой из которых, кроме
последней, поле микроопераций будет пустым. При выполнении таких мик-
рокоманд в операционном автомате никаких действий не выполняется
Глава 4. Организация устройств ЭВМ 101
(он "простаивает"!), а управляющий автомат тратит k −1 тактов на определе-
ние следующего адреса.
Когда в ГСА встречается большое число таких цепочек, снижение произво-
дительности системы становится существенным. В этом случае используют
другие подходы к формированию следующего адреса микрокоманды. На-
пример, на рис. 4.11 представлен фрагмент ГСА, при реализации которого
необходимо последовательно проверить три логических условия. Для быст-
рой реализации этого фрагмента достаточно выбрать некоторый базовый ад-
рес (в данном случае он должен быть кратным 8), начиная с которого в ПЗУ
микропрограмм расположить последовательно блок микрокоманд y13...y20 .
Для определения адреса очередной микрокоманды достаточно к базовому
адресу прибавить (приписать справа) значение вектора логических условий
1 2 3
~x ~x ~x . Адрес следующей микрокоманды определяется, таким образом, за
один такт, но разработчик лишается возможности произвольного размещения
микрокоманд в памяти.
Рис. 4.11. Фрагмент ГСА микропрограммы
Если в ГСА имеется большое число линейных участков и, следовательно,
безусловных переходов, то применение принудительной адресации ведет
к неэффективному использованию памяти. Действительно, при безусловном
переходе информативным является только поле адреса перехода A1, а поля x
и А0 — не используются.
В целях уменьшения длины поля адреса микрокоманды можно использовать
так называемую естественную адресацию (рис. 4.12), напоминающую меха-
низм адресации команд в программе. В этом случае в состав устройства фор-
мирования адреса микрокоманды включают регистр-счетчик адреса микро-
команд, а в адресном поле микрокоманды — два поля: x и А1. Если заданное
102 Часть I. Принципы организации ЭВМ
полем x условие истинно, то выполняется микрокоманда по адресу А1, ина-
че — микрокоманда по текущему значению счетчика адреса микрокоманд,
предварительно увеличенному на единицу.
Таким образом, УАПЛ с естественной адресацией работает с той же скоро-
стью, что и УАПЛ с принудительной адресацией, при этом длина микроко-
манды уменьшается на длину одного адресного поля, зато в структуре
УФАМК необходимо дополнительно предусмотреть регистр-счетчик.
а
б
Рис. 4.12. Различные форматы микрокоманд при естественной адресации
Структурная схема микропрограммного автомата с естественной адресацией
приведена на рис. 4.13. Считанные из ПЗУ микрокоманд слова помещаются в
регистр микрокоманд (Рг МК), причем часть микрокомандного слова де-
шифрируется для выработки микроопераций, а поле адресации, естественно,
используется для формирования адреса следующей микрокоманды. Мульти-
плексор выбирает из множества логических условий переменную, заданную
полем x , а поле i позволяет при необходимости проинвертировать значение
выбранного логического условия:
⎩ ⎨ ⎧
=
=
⊕ =
при 1.
при 0;
x i
x i
x i
k
k
k
Если значение выбранного логического условия истинно, то осуществляется
переход по микропрограмме: при единичном значении на выходе сумматора
по модулю два в регистр-счетчика адреса микрокоманды (Рг Сч А МК) за-
гружается значение поля А1 микрокоманды, содержащее адрес перехода. Ес-
ли условие не выполняется (ложно), то загрузки нового адреса в Рг Сч А МК
Глава 4. Организация устройств ЭВМ 103
не производится, зато его прежнее значение увеличивается на единицу.
В случае безусловного перехода (после операторной вновь следует оператор-
ная вершина) так же следует просто увеличить на единицу содержимое
Рг Сч А МК. Для этого достаточно среди множества логических условий
иметь константу 0 (тождественно ложное логическое условие) и именно ее
номер указывать в поле x в случае безусловного перехода.
Рис. 4.13. Микропрограммный автомат с естественной адресацией
Итак, для реализации формата микрокоманды с естественной адресацией
(рис. 4.12, а) можно использовать структуру УА, показанную на рис. 4.13.
Однако не всегда такой формат обеспечит оптимальные характеристики
управляющего автомата.
Действительно, на практике часто встречаются алгоритмы, содержащие в ос-
новном линейные участки и лишь изредка — условные вершины. Тогда для
большинства микрокоманд (для тех, за которыми в ГСА следует операторная
вершина) поля переадресации формата рис. 4.12, а использоваться не будут.
104 Часть I. Принципы организации ЭВМ
В этом случае имеет смысл введение двух различных форматов микроко-
манд, показанных на рис. 4.12, б. Один формат содержит только информацию
о микрооперациях и после выполнения такой микрокоманды всегда добавля-
ется единица к Рг Сч А МК — таким образом реализуется линейный участок.
Команды другого формата применяются только в случае реализации услов-
ной вершины. Как обычно, проверяется значение заданного логического ус-
ловия (или его инверсии), и если оно истинно — в Рг Сч А МК загружается
значение поля A1 микрокоманды, иначе к Рг Сч А МК добавляется единица.
При этом никаких микроопераций УА в этом такте не выдает и никаких дей-
ствий в ОА не выполняется.
Задание
Попробуйте изменить структурную схему рис. 4.13 для работы с микрокоман-
дами форматов рис. 4.12, б.
Такое решение позволяет значительно эффективней использовать ЗУ МК,
однако производительность устройства несколько снижается. Естественно,
если количество условных вершин велико, то велико будет и число "пустых"
(для ОА) тактов дискретного времени. Если это окажется неприемлемым по
соображениям быстродействия, придется возвращаться к формату микроко-
манды рис. 4.12, а.
Кодирование микроопераций
Теперь рассмотрим, как можно использовать разряды поля микроопераций
(МО). Различают [2] три способа кодирования поля микроопераций:
􀂈 горизонтальный;
􀂈 вертикальный;
􀂈 смешанный.
Ранее мы говорили, что управляющий автомат проектируется для выдачи
в заданной последовательности наборов микроопераций из некоторого напе-
ред определенного множества микроопераций { }Y = y1, y2 , ..., yn .
При горизонтальном способе кодирования каждой микрооперации
{ }yi ∈ y1, ..., yn ставится в соответствие разряд поля микроопераций микро-
командного слова. В этом случае количество разрядов поля микроопераций
N равно числу n различных микроопераций, вырабатываемых УА.
Достоинствами горизонтального способа кодирования являются:
􀂈 возможность формирования произвольных микрокоманд из заданного на-
бора микроопераций;
Глава 4. Организация устройств ЭВМ 105
􀂈 простота реализации схем формирования микроопераций, фактически —
их отсутствие, т. к. выход каждого разряда поля микроопераций регистра
микрокоманд является выходной линией УА — соответствующей микро-
операцией.
Недостаток — чаще всего неэффективно используется память микроко-
манд. Действительно, если число микроопераций УА составляет 80, а коли-
чество выполняемых в микрокоманде микроопераций — не более 6 (типич-
ные характеристики для УА АЛУ), то в восьмидесятиразрядном поле
микроопераций каждого микрокомандного слова будет не более 6 единиц.
При вертикальном способе кодирования в поле микроопераций помещается
номер выполняемой микрооперации. При этом количество разрядов N , ко-
торое следует предусмотреть в поле микроопераций, определяется выраже-
нием: N = k ≥ log2 n . Достоинство способа в экономном использовании
памяти микрокоманд. Недостаток — в невозможности реализовать в микро-
команде более одной микрооперации.
Если реализуемые алгоритмы и структура ОА таковы, что в каждом такте
дискретного времени выполняется не более одной микрооперации, то верти-
кальный способ кодирования — оптимальное решение. В иных случаях мож-
но попытаться преобразовать исходную микропрограмму к такому виду, что-
бы в каждом такте выполнялось не более одной микрооперации. Например,
если в микропрограмме (представленной в форме ГСА) имеется операторная
вершина, в которой устанавливаются в исходное состояние несколько ячеек
(элементов) памяти (и, следовательно, она включает несколько микроопера-
ций), то ее можно заменить на несколько вершин, в каждой из которых уста-
навливается только один элемент с помощью одной микрооперации. Теперь
можно применить вертикальный способ кодирования, правда, при этом уве-
личивается время реализации алгоритма.
Однако во многих случаях структура операционного автомата не допускает
возможности разнесения во времени некоторых действий, управляемых раз-
личными микрооперациями. Тогда вертикальный способ кодирования поля
микроопераций не применим.
Вертикальный и горизонтальный способы кодирования — две крайности.
Истина обычно лежит "посередине". Рассмотрим смешанный способ кодиро-
вания, идея которого состоит в следующем. Если во всех микропрограммах,
реализуемых УА, нет микрокоманды с большим, чем s , числом микроопера-
ций, то в поле микроопераций можно предусмотреть s подполей разрядно-
стью k , в каждом из которых помещать номер нужной микрооперации.
Такой способ позволяет в любой микрокоманде реализовать произвольную
s-ку микроопераций, т. е. сохранить гибкость горизонтального кодирования,
106 Часть I. Принципы организации ЭВМ
при возможном значительном сокращении разрядности поля микроопераций:
N = s ⋅ k = s log2 n . Так, для приведенного выше примера ( n = 80 , s = 6 ) оп-
ределим k = 7 ≥ log2 80 , N = 7 ⋅6 = 42 (тоже, конечно, немало), что позволит
почти вдвое сократить разрядность поля микроопераций по сравнению с го-
ризонтальным способом кодирования.
Эффективность применения смешанного кодирования существенно зависит
от значения s , которое может лежать в диапазоне 1 ≤ s ≤ n . При s = 1 имеем
случай вертикального кодирования, при s = n — горизонтального.
Канонический способ смешанного кодирования, идея которого представлена
выше, предполагает, что каждое из s подполей микроопераций содержит
k разрядов, следовательно, в любом подполе можно закодировать любую
микрооперацию y∈Y . Возможно, например, построение микрокоманды, со-
держащей s одинаковых микроопераций yi yi ...yi , что является явно бес-
смысленным.
С целью сокращения разрядности полей микроопераций множество микро-
операций Y разбивается на подмножества Y1 , Y2 , ..., Yp , такие, что
; ( )
1
= ∀ =∅
=
i j
p
i
∪Yi Y Y ∩Y при i ≠ j . (4.8)
Каждое подполе поля микроопераций кодирует микрооперации только одного
подмножества Yi ⊂ Y . Поскольку ∀Yi < Y , разрядность ki каждого из под-
полей может быть меньше k . Очевидно, при "удачном" (пока скажем так)
распределении микроопераций по подмножествам можно будет реализовать
любую операторную вершину ГСА микропрограммы с помощью одной мик-
рокоманды (т. е. достигнуть быстродействия, характерного для горизонталь-
ного способа кодирования), при этом значительно уменьшить разрядность
поля микроопераций даже по сравнению с каноническим способом смешан-
ного кодирования.
"Удачное" разбиение исходного множества микроопераций связано с поняти-
ем совместимости (несовместимости) микроопераций [7]. Некоторые из
используемых в микропрограмме микроопераций могут выполняться парал-
лельно во времени, в то время как другие — только последовательно. Свой-
ство совокупности микроопераций, гарантирующее возможность их одно-
временного выполнения, называется совместимостью. Микрооперации, не
обладающие указанным свойством, называются несовместимыми.
Рассматриваются два аспекта совместимости. Совместимость, обусловленная
содержанием операторов, реализуемых под действием микроопераций, назы-
вается функциональной. Примером двух функционально несовместимых
Глава 4. Организация устройств ЭВМ 107
микроопераций могут служить следующая пара: ( y8 : Сч n := 0) и
( y15 : Сч n := Сч n −1) и вообще любые микрооперации, присваивающие
различные значения одной и той же переменной.
Если невозможность одновременного выполнения микроопераций свя-
зана с ограничениями возможностей структуры операционного автомата,
то такая несовместимость называется структурной. Например, операторы
(Рг С := Рг А) и (Рг D := Рг В) функционально совместимы, но если в кон-
кретной структуре ОА связь между этими регистрами осуществляется через
общую магистраль (шину), то они структурно несовместимы.
Вернемся к способам разбиения исходного множества микроопераций на
подмножества. Очевидно, в каждое подмножество следует включать только
взаимно несовместимые микрооперации. При проектировании УА возникает
вопрос: какой тип совместимости микроопераций учитывать при разбиении
исходного множества Y на подмножества?
Если несовместимыми считать только те микрооперации, которые принципи-
ально нельзя реализовать на заданной (спроектированной) структуре ОА, то
таких пар окажется немного, большинство микроопераций будут попарно
совместимыми, следовательно, их необходимо включать в разные подмноже-
ства. При этом число подмножеств p может превысить значение s и при-
ближаться к n .
Если рассматривать в качестве совместимых только те микрооперации, кото-
рые размещаются в одной операторной вершине реализуемых алгоритмов,
а все остальные считать несовместимыми, даже если их можно выполнить
одновременно в структуре ОА (но не требуется при реализации данных алго-
ритмов), то p→ s , эффективность кодирования будет значительно выше.
Правда, если потребуется модифицировать реализуемый алгоритм или доба-
вить еще группу алгоритмов для реализации, и в одной операторной вершине
окажутся микрооперации, включенные ранее в одно подмножество, придется
заново перепроектировать УА.
Разработано несколько формальных методов [7] разбиения множества мик-
роопераций на подмножества. В простейшем случае можно воспользоваться
методом "прямого включения". Рассмотрим пример проектирования УАПЛ
по заданной микропрограмме.
Пример проектирования УАПЛ
Мы уже говорили, что исходным для проектирования УА является микро-
программа, представленная, например, в форме ГСА. На рис. 4.14 изображе-
на некоторая микропрограмма, которую мы будем считать исходной для про-
ектирования нашего автомата.
108 Часть I. Принципы организации ЭВМ
Заметим, что на этапе проектирования управляющего автомата семантика
ГСА не рассматривается: сейчас нас уже не интересует "правильность" мик-
ропрограммы относительно реализуемого алгоритма. Просто имеется син-
таксически правильно построенная ГСА и требуется разработать устройство,
реализующее это поведение.
В качестве управляющего устройства будем проектировать управляющий
микропрограммный автомат с программируемой логикой.
Общая структура такого устройства представлена на рис. 4.8. Исходя из опи-
санных выше вариантов организации адресации и способов кодирования по-
ля микроопераций, выберем естественную адресацию и смешанный способ
кодирования микроопераций. Ограничимся единственным форматом микро-
команды.
Рис. 4.14. Исходная микропрограмма для проектирования автомата
Îïðåäåëåíèå ôîðìàòà ìèêðîêîìàíäû
На разрядность полей микрокоманды влияют следующие параметры:
􀂈 количество различных микроопераций, формируемых УА, в конечном
итоге определяет (с учетом выбранного способа кодирования) длину поля
микроопераций;
Глава 4. Организация устройств ЭВМ 109
􀂈 количество различных логических условий определяет длину поля x ;
􀂈 количество вершин ГСА связано с общим числом микрокоманд, а следо-
вательно, с объемом памяти микропрограмм и разрядностью поля адреса
микрокоманды.
Множество микроопераций Y , используемых в заданной ГСА —
Y = {y1, y2 , ..., y13}, мощность множества Y =13. При горизонтальном ко-
дировании поле микроопераций будет занимать 13 разрядов. Вертикальный
способ кодирования микроопераций к заданной ГСА неприменим, поскольку
ГСА содержит вершины с двумя и тремя микрооперациями. Попробуем реа-
лизовать разбиение множества Y на подмножества несовместимых микро-
операций. Воспользуемся методом прямого включения, учитывая, что отно-
шение совместимости задано на самой ГСА. Строго говоря, следовало бы
построить матрицу совместимости микроопераций, но в рассматриваемом
примере небольшой размер алгоритма позволяет определять отношение со-
вместимости непосредственно по ГСА.
На сколько подмножеств следует разбивать исходное множество? По мень-
шей мере, на s = 3 в нашем случае. Образуем три подмножества — Y1 , Y2 ,
Y3 и разместим в них микрооперации операторной вершины, имеющей s
микроопераций. Если в ГСА таких вершин несколько — выберем любую
из них.
Y1 = {y1}, Y2 = {y4}, Y3 = {y7}.
Теперь разместим по множествам микрооперации следующей вершины, со-
держащей (в нашем случае) три микрооперации:
Y1 = {y1}, Y2 = {y4 , y5}, Y3 = {y7 , y8}.
Заметим, что первая микрооперация второй рассматриваемой вершины сов-
падает с первой микрооперацией первой вершины. Она уже присутствует
в множестве Y1 ( y1 ∈Y1 ), поэтому не включается вторично. Наконец, размес-
тим микрооперации третьей "тройной" вершины:
Y1 = {y1, y11}, Y2 = {y4 , y5 , y12}, Y3 = {y7 , y8 , y13}.
Теперь нераспределенными остались микрооперации (некоторые) "двойных"
и "одинарных" вершин. Вершина ( y2 , y6 ) — обе микрооперации несовмес-
тимы с уже распределенными, поэтому могут располагаться произвольно,
лишь бы они находились в разных подмножествах:
Y1 = {y1, y11, y2}, Y2 = {y4 , y5 , y12 , y6}, Y3 = {y7 , y8 , y13}.
110 Часть I. Принципы организации ЭВМ
Вершина ( y2 , y9 ) — y9 нельзя помещать в Y1 , поскольку совместимая с ней
y2 ∈Y1 . Подмножества лучше заполнять равномерно, поэтому разместим y9
в Y3 :
Y1 = {y1, y11, y2}, Y2 = {y4 , y5 , y12 , y6}, Y3 = {y7 , y8 , y13, y9}.
Остались две нераспределенные микрооперации — y3 и y10 , первая из кото-
рых совместима с y5 , поэтому ее нельзя помещать в Y2 , а вторая несовмес-
тима ни с какими другими и может размещаться произвольно. Поместим их
в множество, имеющее пока наименьшую мощность — Y1 :
Y1 = {y1, y11, y2 , y3 , y10}, Y2 = {y4 , y5 , y12 , y6}, Y3 = {y7 , y8 , y13, y9}.
Все 13 микроопераций распределились по трем подмножествам, при этом
выполняются условия (4.8) (т. е. имеет место разбиение исходного множест-
ва Y ), однако УА обычно должен вырабатывать еще одну микрооперацию,
свидетельствующую об окончании выполнения алгоритма и предназначен-
ную для использования не в ОА, а в управляющем автомате верхнего уровня
иерархии. Назовем эту микрооперацию yk и включим в произвольное мно-
жество (например, в Y2 ), поскольку она, естественно, несовместима ни с од-
ной микрооперацией. Итак, имеем следующее распределение:
Y1 = {y1, y11, y2 , y3, y10}, Y2 = {y4 , y5 , y12 , y6 , yk }, Y3 = {y7 , y8 , y13, y9}.
Для кодирования элементов каждого из трех подмножеств потребуется по
три двоичных разряда. Может показаться, что для Y3 хватит и двух, ведь
3
Y = 4 = 22 , однако следует учесть, что в каждом подмножестве необходимо
предусмотреть один код для случая отсутствия микрооперации из этого под-
множества в микрокоманде. Оптимальным разбиением исходного множества
будет такое, когда ∀Yi = 2r −1, где r — натуральное число.
В подмножестве Y3 всего одна "лишняя" микрооперация, а среди кодов Y1 и Y2
есть свободные. Попробуем перенести одну из микроопераций из Y3 в другое
подмножество, сохраняя, естественно, требование к попарной несовместимости
всех микроопераций одного подмножества. Очевидно, первые три элемента под-
множества Y3 нельзя перенести в другое, т. к. они являются микрооперациями из
"тройных" вершин. Зато микрооперация y9 совместима только с y2 ∈Y1 , поэто-
му y9 можно перенести в Y2 . Окончательно получим, предварительно упорядо-
чив элементы подмножеств в порядке возрастания индексов:
Y1 = {y1, y2 , y3, y10 , y11}, Y2 ={y4 , y5 , y6 , y9 , y12 , yk }, Y3 = {y7 , y8 , y13}.
Глава 4. Организация устройств ЭВМ 111
Теперь мы можем определить размеры полей микрокоманды. Поле микро-
операций будет состоять из трех подполей — Y1 , Y2 , Y3 (назовем их по име-
нам соответствующих подмножеств), размером в 3, 3 и 2 двоичных разрядов
соответственно.
Поле номера условия x должно содержать номер одного из двух логических
условий — x1 , x2 (один разряд?), однако для повышения гибкости процесса
микропрограммирования удобно иметь возможность выбирать еще и тож-
дественно истинное и тождественно ложное условия. Итак, поле x зани-
мает два разряда.
Наконец, поле адреса определяется объемом памяти микропрограмм. Если
в нашем примере мы будем считать, что разрабатываем УА только для реали-
зации микропрограммы рис. 4.14, а она содержит 8 вершин, не считая на-
чальной, конечной и условных, количество микрокоманд (каждая микроко-
манда — ячейка памяти, имеющая свой адрес), выдаваемых УА, будет никак
не менее 8, а реально — (1,2, ..., 1,3) × 8, то для поля адреса в микрокоманде
следует отвести 4 разряда ( 24 = 16 > 1,3×8 ≈ 11).
В поле адреса будет располагаться адрес памяти — двоичный номер ячейки,
а в полях Yi и x — коды микроопераций и логических условий. Окончатель-
но формат микрокоманды будет иметь вид, приведенный на рис. 4.15.
Рис. 4.15. Формат микрокоманды
Êîäèðîâêà ìèêðîîïåðàöèé è ëîãè÷åñêèõ óñëîâèé
Здесь может осуществляться произвольно, например так, как показано
в табл. 4.4.
Выбрав кодировку, можно начинать писать микропрограмму в машинных
микрокодах. Фактически мы формируем содержимое ПЗУ микропрограмм
(табл. 4.5).
Анализируя ГСА микропрограммы (см. рис. 4.14), увидим, что в первом так-
те работы автомата должны быть выданы микрооперации y2 и y6 . Учиты-
вая, что в начальном состоянии автомата Рг Сч А МК удобно установить в 0,
микрокоманда, расположенная по нулевому адресу, должна сформировать
микрооперации y2 и y6 . Из табл. 4.4 следует, что y2 ∈Y1 и имеет код 010,
112 Часть I. Принципы организации ЭВМ
а y6 ∈Y2 (код 011). Микрооперации, включенные в множество Y3 , в этой
микрокоманде отсутствуют. Тогда поле микроопераций микрокоманды
должно содержать следующий код: 010 011 00.
После первой операторной вершины ГСА следует условная вершина, со-
держащая логическую переменную x1 . Следовательно, в микрокоманде
должна анализироваться переменная x1 . При x1 = 0 следующей должна вы-
полняться микрокоманда ( y1 , y4 , y7 ) по адресу 1, иначе — микрокоманда
( y1 , y5 , y8 ) по неизвестному пока адресу. Заполним строку таблицы для ну-
левой ячейки памяти следующим кодом: 010 011 00 01 ????. К этой строке
нам еще придется вернуться для заполнения поля адреса перехода.
По адресу 1 должна располагаться микрокоманда, формирующая микроопе-
рации ( y1 , y4 , y7 ) и безусловно передающая управление следующей микро-
команде ( y3 , y5 ). Заполняем строку таблицы для первой ячейки памяти:
001 001 01 00 хххх. В поле х этой микрокоманды код 00 указывает на тожде-
ственно ложное условие (константу 0) — к Рг Сч А МК будет добавлена 1,
а содержимое поля адреса перехода не используется.
Таблица 4.4. Таблицы кодирования микроопераций и логических условий
Код Y1 Y2 Y3 Код x
000 ∅ ∅ ∅ 00 Константа
0
001 1 y 4 y 7 y 01 1 x
010 2 y 5 y 8 y 10 2 x
011 3 y 6 y 13 y 11 Константа
1
100 10 y 9 y
101 11 y 12 y
110 — k y
111 — —
Действуя аналогичным образом, заполняем строки табл. 4.5, соответствую-
щие адресам ПЗУ 3, 4, 5, 6 (на рис. 4.14 рядом с операторными вершинами
Глава 4. Организация устройств ЭВМ 113
обозначены адреса соответствующих микрокоманд). В микрокоманде по ад-
ресу 4 выполняется условный переход по переменной x2 , причем адрес пе-
рехода при x2 = 1 пока также неизвестен. По адресу 6 размещается микроко-
манда, соответствующая конечной вершине ГСА, завершающая работу
микропрограммы микрооперацией yk . Таким образом, завершено микропро-
граммирование участка ГСА от начальной до конечной вершины, соответст-
вующего нулевым значениям логических переменных.
Теперь можно вернуться к логической вершине, размещенной после первой
операторной. Микрокоманду, следующую за ее единичным выходом ( y1 , y5 ,
y8 ), можно разместить по следующему свободному (7) адресу. Поэтому в
поле адреса перехода ячейки 0 теперь можно поместить код 0111. Сама мик-
рокоманда по адресу 7 формирует три микрооперации и переходит к микро-
команде по адресу 8: 001 010 10 00 хххх.
Микрокоманда по адресу 8 не связана с логической вершиной, но она должна
передавать управление уже существующей (по адресу 3) микрокоманде. По-
этому ее поле x = 11 адресует тождественно истинное условие, а в поле
переадресации указан адрес 3.
Таблица 4.5. Содержимое ПЗУ микропрограмм
Адрес Y1 Y2 Y3 x A1
0 010 011 00 01 0111 (7)
1 001 001 01 00 xxxx
2 011 010 00 00 xxxx
3 000 001 00 00 xxxx
4 101 101 11 10 1001 (9)
5 100 000 00 00 xxxx
6 000 110 00 00 xxxx
7 001 010 10 00 xxxx
8 010 100 00 11 0011 (3)
9 000 000 00 01 0111 (7)
10 000 000 00 11 0001 (1)
114 Часть I. Принципы организации ЭВМ
Наконец, остался неопределенным адрес перехода в микрокоманде по адре-
су 4. Сейчас уже всем операторным вершинам ГСА (включая конечную) со-
ответствуют микрокоманды в ячейках ПЗУ. На какую из них следует пере-
дать управление после проверки условия x2 , если оно окажется истинным?
Рис. 4.16. Структурная схема управляющего автомата
Глава 4. Организация устройств ЭВМ 115
Из ГСА видно, что тогда следует проверить условие x1 — случай двух под-
ряд расположенных условных вершин. Передать управление на адрес 0, где
проверяется это условие? Но тогда выполнятся и микрооперации y1 , y4 , y7 ,
а это микропрограммой не предусмотрено. Очевидно, в микропрограмму
следует включить дополнительно микрокоманды (в нашем случае — по ад-
ресам 9 и 10), которые не формируют никаких микроопераций, а обеспечи-
вают только передачу управления. Первая осуществляет условный переход
по переменной x1 на адрес 7, вторая (которая будет выполняться только при
x1 = 0 ) — безусловно на адрес 1. Теперь код микропрограммы полностью
сформирован.
Осталось изобразить структурную схему разработанного управляющего ав-
томата (рис. 4.16).
Глава 5
Организация памяти в ЭВМ
ЭВМ, реализованная по классической фон-неймановской архитектуре, вклю-
чает в себя:
􀂈 процессор, содержащий арифметико-логическое устройство (АЛУ) и цен-
тральное устройство управления (ЦУУ);
􀂈 память, которая в современных ЭВМ подразделяется на оперативную (ОП
или ОЗУ) и сверхоперативную (СОЗУ);
􀂈 внешние устройства, к которым относят внешнюю память (ВЗУ) и устрой-
ства ввода/вывода (УВВ).
В этой главе рассмотрим организацию устройств памяти. Принципы взаимо-
действия других устройств ЭВМ с процессором рассмотрены в разд. 6.3.
5.1. Концепция многоуровневой памяти
Известно, что память ЭВМ предназначена для хранения программ и данных,
причем эффективность работы ЭВМ во многом определяется характеристи-
ками ее памяти. Во все времена к памяти предъявлялись три основных требо-
вания: большой объем, высокое быстродействие и низкая (умеренная)
стоимость.
Все перечисленные выше требования к памяти являются взаимно-противо-
речивыми, поэтому пока невозможно реализовать один тип ЗУ, отвечающий
всем названным требованиям. В современных ЭВМ организуют комплекс
разнотипных ЗУ, взаимодействующих между собой и обеспечивающих при-
емлемые характеристики памяти ЭВМ для каждого конкретного применения.
В основе большинства ЭВМ лежит трехуровневая организация памяти: сверх-
оперативная (СОЗУ) — оперативная (ОЗУ) — внешняя (ВЗУ). СОЗУ и ОЗУ
Глава 5. Организация памяти в ЭВМ 117
могут непосредственно взаимодействовать с процессором, ВЗУ взаимодейст-
вует только с ОЗУ.
СОЗУ обладает максимальным быстродействием (равным процессорному),
небольшим объемом (101—105 байтов) и располагается, как правило, на кри-
сталле процессорной БИС. Для обращения к СОЗУ не требуются магистраль-
ные (машинные) циклы. В СОЗУ размещаются наиболее часто используемые
на этом участке программы данные, а иногда — и фрагменты программы.
Быстродействие ОЗУ может быть ниже процессорного (не более чем на по-
рядок), а объем составляет 106—109 байтов. В ОЗУ располагаются подлежа-
щие выполнению программы и обрабатываемые данные. Связь между про-
цессором и ОЗУ осуществляется по системному или специализированному
интерфейсу и требует для своего осуществления машинных циклов.
Информация, находящаяся в ВЗУ, не может быть непосредственно использо-
вана процессором. Для использования программ и данных, расположенных
в ВЗУ, их необходимо предварительно переписать в ОЗУ. Процесс обмена
информацией между ВЗУ и ОЗУ осуществляется средствами специального
канала или (реже) — непосредственно под управлением процессора. Объем
ВЗУ практически неограничен, а быстродействие на 3—6 порядков ниже
процессорного.
Схематически взаимодействие между процессором и уровнями памяти пред-
ставлено на рис. 5.1.
Рис. 5.1. Взаимодействие ЗУ различных уровней в составе ЭВМ
Следует помнить, что положение ЗУ в иерархии памяти ЭВМ определяется
не элементной базой запоминающих ячеек (известны случаи реализации ВЗУ
на БИС — "электронный диск" и, наоборот, организация оперативной памяти
на электромеханических ЗУ — магнитных барабанах), а возможностью дос-
тупа процессора к данным, расположенным в этом ЗУ.
При организации памяти современных ЭВМ (МПС) особое внимание уделя-
ется сверхоперативной памяти и принципам обмена информацией между
ОЗУ и ВЗУ.
118 Часть I. Принципы организации ЭВМ
5.2. Сверхоперативная память
Применение СОЗУ в иерархической памяти ЭВМ может обеспечить повы-
шение производительности ЭВМ за счет снижения среднего времени об-
ращения к памяти T при условии, что время цикла СОЗУ TС будет (значи-
тельно) меньше времени цикла ОЗУ T0 . Очевидно:
T = pС ⋅TС + (1− pС ) ⋅T0 , (5.1)
где pС — вероятности обращения к СОЗУ. Обозначим так же: pО — веро-
ятности обращения к ОЗУ.
Из (5.1) следует, что повышение производительности ЭВМ может осуществ-
ляться двумя путями:
􀂈 уменьшением отношения
0
С
T
T
;
􀂈 увеличением вероятности pС обращения в СОЗУ.
Первый путь связан, прежде всего, с технологическими особенностями про-
изводства БИС и здесь не рассматривается.
Если считать, что информация размещается в СОЗУ и ОЗУ случайным обра-
зом, то вероятности pС и pО пропорциональны объемам соответствующих
ЗУ. В этом случае pС << pО и наличие в ЭВМ СОЗУ практически не влияет
на ее производительность.
То же можно было бы сказать и о ситуации, когда отношение 1
0
С ≈
T
T
, но не
следует забывать, что наличие в ЭВМ СОЗУ с прямой адресацией (РОН) по-
зволяет включать в систему команд короткие команды, использовать косвен-
но-регистровую адресацию и, в конечном итоге, увеличивать производитель-
ность ЭВМ даже при TС = T0 .
Итак, для эффективного применения СОЗУ следует таким образом распреде-
лять информацию по уровням памяти ЭВМ, чтобы в СОЗУ всегда располага-
лись наиболее часто используемые в данный момент коды.
Принято различать СОЗУ по способу доступа к хранимой в нем информации.
Известны два основных класса СОЗУ по этому признаку:
􀂈 с прямым доступом;
􀂈 с ассоциативным доступом.
Глава 5. Организация памяти в ЭВМ 119
5.2.1. СОЗУ с прямым доступом
СОЗУ с прямым доступом (РОН — регистры общего назначения) получило
широкое распространение в большинстве современных ЭВМ. Фактически
РОН — это небольшая регистровая намять, доступ к которой осуществляется
специальными командами. Стратегия размещения данных в РОН целиком
определяется программистом (компилятором). Обычно в РОН размещают
многократно используемые адреса (базы, индексы), счетчики циклов, данные
активного фрагмента задачи, что повышает вероятность обращения в ячейки
РОН по сравнению с ячейками ОЗУ.
5.2.2. СОЗУ с ассоциативным доступом
Применение СОЗУ с ассоциативным доступом позволяет автоматизировать
процесс размещения данных в СОЗУ, обеспечивая "подмену" активных
в данный момент ячеек ОЗУ ячейками СОЗУ. Эффективность такого подхода
существенно зависит от выбранной стратегии замены информации в СОЗУ,
причем использование ассоциативного СОЗУ имеет смысл только при условии
TС << T0 .
Принцип ассоциативного доступа состоит в следующем. Накопитель ассо-
циативного запоминающего устройства (АЗУ) разбит на два поля — ин-
формационное и признаков. Структура информационного поля накопителя
соответствует структуре обычного ОЗУ, а запоминающий элемент поля при-
знаков, помимо функции записи, чтения и хранения бита, обеспечивает срав-
нение хранимой информации с поступающей и выдачу признака равенства.
Признаки равенства всех элементов одной ячейки поля признаков объединя-
ются по "И" и устанавливают в 1 индикатор совпадения ИС, если информа-
ция, хранимая в поле признака ячейки, совпадает с информацией, подаваемой
в качестве признака на вход Р накопителя.
Во второй фазе обращения (при чтении) на выход данных D последовательно
поступает содержимое информационных полей тех ячеек, индикаторы совпа-
дения которых установлены в 1 (если таковые найдутся).
Способ использования АЗУ в качестве сверхоперативного иллюстрирует
рис. 5.2. В информационном поле ячеек АСОЗУ — копия информации неко-
торых ячеек ОЗУ, а в поле признаков — адреса этих ячеек ОЗУ. Когда про-
цессор генерирует обращение к ОЗУ, он одновременно (или прежде) ини-
циирует процедуру опроса АСОЗУ, выдавая в качестве признака адрес ОЗУ.
Если имеет место совпадение признака ячейки с запрашиваемым адресом (не
более одного раза, алгоритм загрузки АСОЗУ не предусматривает возможно-
120 Часть I. Принципы организации ЭВМ
сти появления одинаковых признаков), то процессор обращается (по чтению
или по записи) в информационное поле этой ячейки АСОЗУ, при этом блоки-
руется обращение к ОЗУ. Если требуемый адрес не найден в АСОЗУ, ини-
циируется (или продолжается) обращение к ОЗУ, причем в АСОЗУ создается
копия ячейки ОЗУ, к которой обратился процессор. Повторное обращение
процессора по этому адресу будет реализовано в АСОЗУ (на порядок быст-
рее, чем в ОЗУ).
Рис. 5.2. СОЗУ с ассоциативным доступом
Таким образом, в АСОЗУ создаются копии тех ячеек ОЗУ, к которым в данный
момент обращается процессор в надежде, что "в ближайшее время" произойдет
новое обращение по этому адресу. (Существуют и другие стратегии загрузки
АСОЗУ, например, если процессор обращается в ОЗУ по определенному адре-
су, то в АСОЗУ перемещается содержимое целого блока соседних ячеек.)
При необходимости записи в АСОЗУ новой информации требуется отыскать
свободную ячейку, а при ее отсутствии (что чаще всего и бывает) — оты-
скать ячейку, содержимое которой можно удалить из АСОЗУ. При этом
следует помнить, что если во время пребывания ячейки в АСОЗУ в нее про-
изводилась запись, то требуется не просто очистить содержимое ячейки,
а записать его в ОЗУ по адресу, хранящемуся в поле признаков, т. к. процес-
сор, отыскав адрес в АСОЗУ, производит запись только туда, оставляя в ОЗУ
старое значение (так называемое "АСОЗУ с обратной записью"). Возможен и
другой режим работы СОЗУ — со сквозной записью, при котором всякая за-
пись осуществляется и СОЗУ, и в ОЗУ.
При поиске очищаемой ячейки чаще всего используют метод случайного вы-
бора. Иногда отмечают ячейки, в которые не проводилась запись, и поиск
"кандидата на удаление" проводят из них.
Глава 5. Организация памяти в ЭВМ 121
Более сложная процедура замещения предполагает учет длительности пре-
бывания ячеек в АСОЗУ, или частоты обращения по этому адресу, или вре-
мени с момента последнего обращения. Однако все эти методы требуют до-
полнительных аппаратных и временных затрат.
Одним из наиболее дешевых способов, позволяющих учитывать поток обра-
щений к ячейкам, является следующий. Каждой ячейке АСОЗУ ставится
в соответствие бит (триггер) обращения, который устанавливается при обра-
щении к этой ячейке. Когда биты обращения всех ячеек АСОЗУ установятся
в 1, все они одновременно сбрасываются в 0. Поиск очищаемой ячейки осу-
ществляется среди ячеек, биты обращения которых нулевые, причем если
таких ячеек несколько, то среди них осуществляется случайная выборка.
Наличие АСОЗУ в ЭВМ позволяет (при достаточном его объеме и правильно
выбранной стратегии загрузки) значительно увеличить производительность
системы. При этом наличие или отсутствие АСОЗУ никак не отражается на
построении программы. АСОЗУ не является программно-доступным объек-
том, оно скрыто от пользователя. Недаром в литературе для обозначения
АСОЗУ часто используется термин "кэш-память" (cache — тайник).
Кэш-память, структура которой приведена на рис. 5.2, носит название пол-
ностью ассоциативной. Здесь каждая ячейка кэш может подменять любую
ячейку ОЗУ. Достоинство такой памяти — максимальная вероятность кэш-
попадания (при прочих равных условиях), по сравнению с другими способа-
ми организации кэш. К недостаткам можно отнести сложность ее структуры
(а следовательно, и высокую стоимость). Действительно, в каждом разряде
поля признаков необходимо реализовать, наряду с возможностями записи и
хранения, функцию сравнения хранимого бита с соответствующим битом
признака, а потом конъюнкцию результатов сравнения разрядов в каждой
ячейке.
Кэш-память с прямым отображением требует минимальных затрат оборудо-
вания (по сравнению с другими вариантами организации кэш), но имеет ми-
нимальную вероятность кэш-попаданий. Суть организации (рис. 5.3) состоит
в следующем. Физическая оперативная намять разбивается на блоки (множе-
ства) одинакового размера, количество которых (блоков) соответствует числу
ячеек кэш, причем каждой строке ставится в соответствие определенное
множество ячеек памяти, не пересекающееся с другими. Все ячейки множе-
ства претендуют на одну строку кэш.
Такая организация кэш исключает собственно ассоциативный поиск, а следо-
вательно, значительно упрощается схема ячейки поля признаков. Действитель-
но, здесь копия требуемой ячейки оперативной памяти может располагаться
в единственной строке кэш. Часть физического адреса (на рис. 5.3 — старшая)
122 Часть I. Принципы организации ЭВМ
определяет номер множества и, следовательно, строку кэш. Содержимое этой
строки выбирается по обычному адресному принципу, и поле тега сравнивает-
ся с младшей частью физического адреса. Таким образом, для всей кэш-памяти
(любого размера) достаточно единственной схемы сравнения.
Рис. 5.3. Кэш с прямым отображением
Однако предложенная выше структура имеет существенный недостаток.
Если проводить разбиение памяти на множества, как показано на рис. 5.3,
то в большинстве случаев кэш будет использоваться крайне неэффективно.
Во-первых, хотя адресное пространство физической памяти 32-разрядных
микропроцессоров составляет 232 байтов, в современных ПЭВМ обычно ис-
пользуют намять объемом 225—229 байтов. Следовательно, строки кэш,
отображаемые на старшие (физически отсутствующие) множества памяти,
никогда не будут использованы.
Во-вторых, если в множества включать следующие подряд ячейки ОЗУ, то
копии никаких двух последовательных ячеек ОЗУ нельзя одновременно
иметь в кэш (кроме случая последней и первой ячеек двух соседних мно-
жеств), что противоречит одной из основополагающих стратегий загрузки
кэш — целесообразности копирования в кэш группы последовательных
ячеек ОЗУ.
Глава 5. Организация памяти в ЭВМ 123
Для исключения отмеченных недостатков разбиение ячеек памяти на множе-
ства осуществляется таким образом, чтобы соседние ячейки относились
к разным множествам, что достигается размещением поля номера множества
не в старших, а в младших разрядах физического адреса.
Для дальнейшего увеличения вероятности кэш-попаданий можно реализо-
вать вариант кэш-памяти, ассоциативной по множеству, которая отличается
от кэш с прямым отображением наличием нескольких строк кэш на одно
множество ячеек памяти.
Например, внутренняя кэш-память процессоров i80486 и Pentium — ассоциа-
тивная по множеству. Вся физическая память разбивается на 128 множеств,
а каждому множеству соответствуют 4 строки кэш. Рассмотрим подробнее
организацию внутренней кэш-памяти процессора 80486 [3].
Внутренняя кэш 80486 (рис. 5.4) имеет объем 8 Кбайт и предназначена для
хранения как команд, так и данных — копий информации ОЗУ. Информация
перемещается из ОЗУ в кэш выровненными 16-байтовыми блоками (4 млад-
шие бита физического адреса — нули). Кэш имеет четырехнаправленную
(или четырехканальную) ассоциативную по множеству организацию, что яв-
ляется компромиссом между быстродействием и экономичностью кэш-
памяти с прямым отображением и большим коэффициентом попаданий пол-
ностью ассоциативной кэш-памяти.
Блок информации из ОЗУ может располагаться в кэш только в одном из
128 множеств, причем в каждом множестве возможно хранение четырех блоков.
Адресация кэш осуществляется путем разделения физического адреса на три поля:
􀂈 7 битов поля индекса (А4—А10) определяют номер множества, в котором
проводится поиск;
􀂈 старшие 21 бит адреса являются полем тега (признака), по которому осу-
ществляется ассоциативный поиск (внутри множества из четырех блоков);
􀂈 четыре младшие бита адреса определяют позицию байта в блоке.
Когда при чтении возникает промах, в кэш копируется из ОЗУ 16-байтовый
блок (строка), содержащий запрошенную информацию.
4-битовое поле достоверности показывает, являются ли в данный момент кэ-
шированные данные достоверными (для каждого блока (строки) множест-
ва — свой бит). При очистке кэш-памяти или сбросе процессора все биты
достоверности сбрасываются в 0. Когда производится заполнение строки
кэш, место для заполнения выбирается просто нахождением любой недосто-
верной строки (из четырех строк "своего" множества).
Если недостоверных строк нет, то реализуется алгоритм замещения строк
"псевдоLRU" ("наиболее давно используемый"). Для каждого множества в
блоке отведено три бита LRU, которые обновляются при каждом кэш-
124 Часть I. Принципы организации ЭВМ
Рис. 5.4. Внутренняя кэш-память 80486
Глава 5. Организация памяти в ЭВМ 125
попадании или заполнении строки. Они используются для реализации алго-
ритма замещения строки следующим образом.
Обозначим строки в множестве как L0, LI, L2, L3. Каждому множеству
в блоке LRU соответствуют три бита В0, B1, B2, которые модифицируются
при каждом кэш-попадании или заполнении строки множества следующим
образом:
􀂈 если последнее обращение было к строке L0 или L1, то бит В0 устанавли-
вается в 1, иначе — сбрасывается в 0;
􀂈 если последнее обращение в паре L0—L1 было к строке L0, то бит В1 ус-
танавливается в 1, иначе — сбрасывается в 0;
􀂈 если последнее обращение в паре L2—L3 было к строке L2, то бит В2 ус-
танавливается в 1, иначе — сбрасывается в 0.
Выбор заменяемой строки (когда все строки множества достоверны) опреде-
ляет содержимое битов В0, B1, B2 (табл. 5.1).
Таблица 5.1. Содержимое битов В0, B1, B2
В0 В1 В2 Действие
0 0 х Заменяется строка L0
0 1 х Заменяется строка L1
1 х 0 Заменяется строка L2
1 х 1 Заменяется строка L3
Цикл записи при наличии кэш-памяти может реализоваться по-разному. Раз-
личают кэш со сквозной записью и кэш с обратной записью.
В первом случае в цикле записи всегда осуществляется запись как в кэш, так
и в ОЗУ. Этот способ записи не приводит к сокращению цикла записи даже
при кэш-попадании, но гарантирует идентичность данных по адресам ОЗУ
и кэш.
При обратной записи в случае кэш-попадания запись осуществляется только
в кэш, при этом в соответствующей ячейке ОЗУ сохраняется прежнее (уже
неверное) значение. Запись в ОЗУ происходит при очистке (замещении)
строки кэш, если ее содержимое изменялось в процессе пребывания в кэш.
Ситуация временного несоответствия содержимого ячеек кэш и ОЗУ может
быть допустима в одних случаях и недопустима в других (например, когда
несколько процессоров со своими кэш общаются через общее поле ОЗУ). По-
этому в большинстве случаев пользователю предоставляется возможность
126 Часть I. Принципы организации ЭВМ
выбора способа записи в кэш — за счет модификации некоторых программ-
но-доступных флагов в регистре управления.
В 80486 строки кэш-памяти можно по отдельности объявить недостоверны-
ми, задавая операцию недостоверности кэш-памяти на шине процессора. При
инициализации такой операции кэш сравнивает объявленный недостоверным
адрес с тегом строк, находящихся в кэш, и сбрасывает бит достоверности при
обнаружении соответствия тегов. Предусмотрена также операция очистки,
которая превращает в недостоверное все содержимое кэш.
Конфигурацией кэш-памяти управляют два бита регистра CR0 состояния
машины:
􀂈 CD (Cache Disable) — запрещение кэш-памяти;
􀂈 NW (Not Write-through) — несквозная (обратная) запись.
При CD = 1 и NW = 1 запрещено заполнение строк, сквозная запись и объ-
явление кэш-памяти недостоверной. Такая конфигурация позволяет исполь-
зовать внутреннюю кэш-память как быстродействующее ЗУПВ.
При CD = 1 и NW = 0 заполнение строк запрещено, а сквозная запись и объ-
явление кэш-памяти недостоверной разрешено. Эта конфигурация позволяет
программе запрещать кэш-память на короткое время, а затем разрешать без
очистки содержимого.
При С0 = 0 и NW = 0 заполнение строк, сквозная запись и объявление кэш-
памяти недостоверной разрешены. Такая конфигурация является обычной
рабочей для кэш-памяти.
При С0 = 0 и NW = 1 осуществляется работа кэш в режиме обратной записи.
Когда кэширование разрешено, кэшируются считывания данных из ОЗУ
и предвыборка команд, если внешняя схема подает входной сигнал разреше-
ния кэш-памяти в данном цикле шины или текущий элемент таблицы стра-
ниц разрешает кэширование. В тех циклах, где кэширование запрещено при
промахе, заполнение строки кэш-памяти не производится. Однако кэш-
память продолжает действовать, несмотря на то, что она запрещена для за-
полнения. Уже находящиеся в кэш-памяти данные используются, если, ко-
нечно, они являются достоверными. (Фактически реализуется режим быстро-
действующего ОЗУ.) Только когда все данные в кэш-памяти отмечены как
недостоверные, что происходит при ее очистке, все внутренние запросы счи-
тывания приводят к формированию внешних циклов шины.
Когда разрешена сквозная запись, все записи, в том числе и при кэш-
попадании, инициируют запись в память. Когда сквозная запись запрещена,
внутренний запрос записи, вызвавший попадание, не приводит к производст-
ву записи в ОЗУ, а операции недостоверности запрещены.
Глава 5. Организация памяти в ЭВМ 127
Когда запрещены кэширование и сквозная запись, кэш-память можно ис-
пользовать как быстродействующее статическое ОЗУ. В такой конфигурации
на шину процессора передаются только записи, вызвавшие промах, а операции
недостоверности игнорируются. Если предполагается использовать этот ре-
жим (CD = 1 и NW = 1), следует предварительно загрузить достоверные
строки, используя операции чтения из памяти или регистров.
5.3. Виртуальная память
Ранее были рассмотрены способы организации сверхоперативной памяти
и ее взаимодействия с оперативной. Не менее, а порой и более важной про-
блемой является организация взаимодействия в паре ОЗУ — ВЗУ.
Известно, что в современных ЭВМ (кроме простейших) реализовано динами-
ческое распределение памяти между несколькими задачами, существующими
в ЭВМ в процессе решения. Даже для однозадачных конфигураций проблема
динамического распределения памяти не теряет актуальности, т. к. в памяти,
помимо задачи пользователя, всегда присутствует операционная система или
ее фрагмент.
Наличие динамического распределения памяти предполагает, что программа
компилируется в так называемых "логических" адресах, а в процессе работы
происходит автоматическое преобразование логических адресов в физические.
Наибольшее распространение в ЭВМ получил метод динамического распреде-
ления памяти, называемый страничной организацией виртуальной памяти.
При использовании этого метода вся память ЭВМ (ОЗУ и ВЗУ) рассматрива-
ется как единая виртуальная память. Адрес в этой памяти называется вир-
туальным или логическим. Вся виртуальная память делится на фрагменты
одинакового размера, называемые виртуальными страницами. Размер стра-
ницы обычно составляет 0,5—4 Кбайт. Виртуальный адрес представляется
состоящим из двух частей — номера страницы и номера слова на странице
(смещения).
Физическая память ЭВМ (ОЗУ и ВЗУ) так же делится на страницы, причем
размер физической страницы выбирается равным размеру виртуальной. Таким
образом, одна физическая страница может хранить одну виртуальную, причем
порядок следования виртуальных страниц в программе совсем не обязательно
сохранять на физических страницах. Достаточно лишь установить однозначное
соответствие между номерами виртуальных и физических страниц.
Соответствие между номерами виртуальных и физических страниц устанавли-
вается с помощью специальной страничной таблицы (СТ), которую поддер-
128 Часть I. Принципы организации ЭВМ
живает операционная система. Размер физической страницы равен размеру
виртуальной, поэтому преобразования смещений на странице не производятся.
Поскольку размер СТ достаточно велик, она хранится целиком в ОЗУ и мо-
дифицируется операционной системой всякий раз, когда в распределении
памяти происходят изменения.
Для увеличения скорости обращения к памяти активная часть СТ обычно
хранится в специальной быстродействующей памяти, организованной, как
правило, по ассоциативному принципу. При этом в поле признаков АЗУ СТ
хранятся виртуальные адреса страниц (иногда вместе с номером програм-
мы — в мультипрограммных системах), а в информационной части — соот-
ветствующие им номера физических страниц.
Если в результате преобразования виртуального адреса в физический оказы-
вается, что требуемая физическая страница располагается в ВЗУ, то выпол-
нение программы становится невозможным, пока не произойдет "подкачка"
требуемой страницы в ОЗУ. Такая ситуация называется страничным сбоем
и должна формировать внутреннее прерывание, по которому запускается
подпрограмма чтения страницы из ВЗУ в ОЗУ.
При этом возникает серьезная проблема поиска той страницы, которую мож-
но удалить из ОЗУ, чтобы на освободившееся место записать требуемую
страницу. Серьезность проблемы обусловлена тем, что неудачный выбор
удаляемой страницы (в ближайшее время она вновь понадобится) связан со
значительной потерей времени на передачу страниц между ОЗУ и ВЗУ.
5.3.1. Алгоритмы замещения
Правило, по которому при возникновении страничного сбоя выбирается
страница для удаления из ОЗУ, называется алгоритмом замещения.
Для данной программы, порождающей некоторый поток обращений к памя-
ти, существует, по крайней мере, одна такая последовательность замещений
страниц, которая дает для этой программы минимальное количество стра-
ничных сбоев.
Теоретически доказано, что минимальное число страничных сбоев будет по-
лучено, если в алгоритме замещения использовать информацию о потоке об-
ращений к страницам в будущем (алгоритм Минховского — Шора) или, по
крайней мере, о вероятности обращений к страницам в будущем.
Алгоритмы замещения, использующие "информацию о будущем", называют-
ся физически нереализуемыми, их обычно применяют для оценки качества
эвристических алгоритмов замещения.
Глава 5. Организация памяти в ЭВМ 129
Эвристические алгоритмы замещения используют информацию о потоке
обращений к страницам в прошлом (историю процесса) для экстраполяции
характеристик потока обращений в будущем. Как правило, используют три
типа информации о прошлом: время пребывания страницы в ОЗУ (или, что
то же — очередность поступления страниц), число обращений к страницам за
определенный промежуток времени или отрезки времени с момента послед-
него обращения к страницам.
Эффективность эвристического алгоритма можно характеризовать отноше-
нием:
e
0
N
N
k = ,
где N0 — число страничных сбоев при решении данной задачи с применени-
ем физически нереализуемого алгоритма; Ne — то же с применением иссле-
дуемого эвристического алгоритма.
Эвристический алгоритм можно считать выбранным удачно (для данного
класса задач), если коэффициент k близок к 1. Значение N0 может быть по-
лучено путем моделирования решения задачи (повторное) с предварительно
зафиксированным потоком обращений к страницам.
При выборе подходящего алгоритма замещения следует учитывать не только
его эффективность k, но и аппаратные затраты и затраты времени на его
реализацию.
Например, для реализации т. н. НДИ-алгоритма (наиболее давно используе-
мая) каждой странице, находящейся в ОЗУ, ставится в соответствие таймер,
который сбрасывается при обращении к странице. При страничном сбое не-
обходимо осуществить поиск максимального элемента массива таймеров
страниц. Для некоторых задач выигрыш времени за счет увеличения k при
применении НДИ-алгоритма, по сравнению с алгоритмом случайного заме-
щения, может быть сравним с потерей времени на поиск максимальных зна-
чений таймеров.
Некоторые алгоритмы замещения учитывают одновременно несколько пара-
метров прошлого потока обращений.
Алгоритм "Карабкающаяся страница" (КС-алгоритм) поддерживает после-
довательность номеров страниц, находящихся в ОЗУ. При любом обращении
к странице ее номер в последовательности перемещается на одну позицию
в направлении начала, меняясь местами с предыдущим в последовательности
номером (исключение — обращение к странице, номер которой стоит в нача-
ле последовательности). При возникновении страничного сбоя из ОЗУ уда-
ляется страница, номер которой расположен в конце последовательности,
130 Часть I. Принципы организации ЭВМ
а номер вновь поступившей страницы помещается в конец последовательно-
сти. КС-алгоритм учитывает как время пребывания страницы в ОЗУ, так
и интенсивность обращения к странице, причем не требует значительных ап-
паратных затрат, а при страничном сбое — времени на поиск.
Алгоритм "Рабочий комплект" (РК-алгоритм) более сложен в реализации, но
позволяет адаптировать свои параметры под конкретный класс задач. Все
страницы ОЗУ, к которым было обращение в течение отрезка времени T ,
образуют т. н. рабочий комплект и не подлежат удалению из ОЗУ. Осталь-
ные страницы (не вошедшие в рабочий комплект) образуют две очереди кан-
дидатов на замещение, причем в первую очередь попадают страницы, на ко-
торые не было записи во время пребывания их в ОЗУ. При страничном сбое
удаляется страница из первой очереди (FIFO — первый пришел из рабочего
комплекта — первый ушел из ОЗУ), а если первая очередь пуста, то — из
второй. Из очереди страница может опять попасть в рабочий комплект, если
к ней будет обращение. Для реализации РК-алгоритма каждой странице ста-
вится в соответствие таймер на T , причем каждое обращение к странице
сбрасывает таймер (и переводит страницу в рабочий комплект, если она там
отсутствовала), а переполнение таймера выводит страницу из рабочего ком-
плекта. Подбором величины T можно оптимизировать РК-алгоритм под
конкретный класс задач.
5.3.2. Сегментная организация памяти
До сих пор предполагалось, что виртуальная память, которой располагает
программист, представляет собой непрерывный массив с единой нумерацией
слов. Однако при написании программы удобно располагать несколькими
независимыми сегментами (кода, данных, подпрограмм, стека и др.), причем
размеры сегментов, как правило, заранее не известны. В каждом сегменте
слова нумеруются с нуля независимо от других сегментов. В этом случае
виртуальный адрес представляется состоящим из трех частей: <номер сег-
мента> <номер страницы> <номер слова>. В машине к виртуальному адресу
может добавиться слева еще <номер задачи>. Таким образом, возникает
определенная иерархия полей виртуального адреса, которой соответствует
иерархия таблиц, с помощью которых виртуальный адрес переводится в фи-
зический. В конкретных системах может отсутствовать тот или иной элемент
иерархии.
Виртуальная память была первоначально реализована на "больших" ЭВМ,
однако по мере развития микропроцессоров в них так же использовались
идеи страничной и сегментной организации памяти.
ЧАСТЬ II
Архитектура
микропроцессорных систем
Глава 6. Базовая архитектура
микропроцессорной системы
Глава 7. Эволюция архитектур
микропроцессоров и микроЭВМ
132 Часть II. Архитектура микропроцессорных систем
Интегральная технология (ИТ) за первые 20—30 лет своего развития достигла
таких относительных темпов роста характеристик качества, которых не знала
ни одна область человеческой деятельности (включая и такие бурно растущие,
как авиация и космонавтика). Действительно, рассмотрим динамику изменений
основных параметров ИТ за первые 20 лет ее развития (1960—1980 гг.):
􀂈 степень интеграции N увеличилась на 5—6 порядков;
􀂈 площадь транзистора S уменьшилась на 3 порядка;
􀂈 рабочая частота f увеличилась на 1—3 порядка;
􀂈 факторы добротности:
• f × N увеличился на 5—7 порядков;
• P×t уменьшился на 4 порядка, где t — задержка на элементе, P —
мощность, рассеиваемая элементом;
􀂈 надежность (при сопоставлении элементо-часов) увеличилась на 4—8 по-
рядков;
􀂈 производительность технологии (в транзисторах) увеличилась на 4—6 по-
рядков;
􀂈 цена на транзистор в составе ИС уменьшилась на 2—4 порядка.
Американцы подсчитали, что если бы авиапромышленность в те же годы
имела аналогичные темпы роста соответствующих показателей качества
(стоимость — скорость — расход топлива = стоимость — быстродействие —
рассеиваемая мощность), то "Боинг 767" стоил бы $500, облетал земной шар
за 20 мин и расходовал на этот полет 10 л горючего.
Успехи ИТ в области элементной базы позволяли "поглощать" кристаллом все
более высокие уровни ЭВМ: сначала — логические элементы, потом — опера-
ционные элементы (регистры, счетчики, дешифраторы и т. д.), далее — операци-
онные устройства. Степень функциональной сложности, достигнутой в ИС, оп-
ределяется особенностью технологии, разрешающей способностью инструмента,
а также структурными особенностями схемы: регулярностью, связностью.
Под регулярностью схемы здесь будем понимать степень повторяемости
элементов и связей по одной или двум координатам (при размещении струк-
туры на плоскости). Связность — число внешних выводов схемы.
Кроме того, следует иметь в виду, что выпуск ИС был экономически оправ-
дан лишь для функционально универсальных схем, обеспечивающих их дос-
таточно большой тираж.
С этой точки зрения интересно взглянуть на соотношение ИС логики и памя-
ти в процессе эволюции ИС — СИС — БИС — СБИС. Первые ИС (сте-
пень интеграции N ~ 101 ) были исключительно логическими элементами.
Часть II. Архитектура микропроцессорных систем 133
При достижении N примерно 102 стали появляться, наряду с операционны-
ми элементами, первые элементы памяти объемом в 16 — 64 — 128 битов.
По мере дальнейшего роста степени интеграции память стала быстро опере-
жать "логику", т. к. по всем трем параметрам (регулярность, связность, ти-
раж) имела перед логическими схемами преимущество. Действительно,
структура накопителя ЗУ существенно регулярна (повторяемость элементов
и связей по двум координатам), связность ее растет пропорционально лога-
рифму объема (при увеличении объема памяти вдвое и сохранении без изме-
нения способа доступа в БИС достаточно добавить лишь один вывод). Нако-
нец, память "нужна всем" и "чем больше, тем лучше", особенно если
"больше, но за ту же (почти) цену".
Что касается ИС логики, то на уровне N ~ 103 на кристалле можно уже раз-
мещать устройство ЦВМ (например, АЛУ, ЦУУ), но схемы логики (особенно
управление) существенно нерегулярны, их связность (сильно зависящая от
конкретной схемы) растет примерно пропорционально N , причем такие
схемы, как правило, не являлись универсальными и не могли выпускаться
большими тиражами (исключения в то время — БИС часов и калькуляторов).
Разработка первого микропроцессора (МП) — попытка создать универсаль-
ную логическую БИС, которая настраивается на выполнение конкретной
функции после изготовления средствами программирования. На подобную
БИС — МП первоначально предполагалось возложить лишь достаточно про-
извольные управляющие функции, однако позже МП стал использоваться как
элементная база ЦВМ четвертого и последующих поколений. Появление МП
вызвало необходимость разработки целого спектра универсальных логиче-
ских БИС, обслуживающих МП: контроллеры прерываний и прямого доступа
в память (ПДП), шинные формирователи, порты ввода/вывода и др.
Первый МП был разработан фирмой Intel и выпущен в 1971 г. на основе
р-МОП-технологии (i4004). В 1972 и 1973 годах этой же фирмой были вы-
пущены модели i4040, i8008. Эти микропроцессоры относились к т. н. перво-
му поколению, обладали весьма ограниченными функциональными возмож-
ностями и очень быстро были вытеснены вторым поколением, которое было
реализовано на основе n-МОП-технологии, что позволило, прежде всего,
поднять тактовую частоту примерно на порядок относительно микропроцес-
соров первого поколения. Кроме того, прогресс интегральной технологии
позволил повысить степень интеграции транзисторов на кристалле, а следо-
вательно, увеличить сложность схемы.
Микропроцессоры второго поколения, самым распространенным из которого
был выпущенный в 1974 г. i8080 (отечественный аналог — К580ВМ80), от-
личались достаточно развитой системой команд, наличием подсистем преры-
134 Часть II. Архитектура микропроцессорных систем
вания, прямого доступа в память, снабжались достаточным числом вспомога-
тельных БИС, обеспечивающих управление памятью, параллельный и после-
довательный обмен с внешними устройствами, реализацию векторных пре-
рываний, ПДП и др.
Многие идеи, заложенные в архитектуру систем на базе 8-разрядного микро-
процессора i8080, неизменными используются и в современных мощных
микропроцессорах.
Постоянное стремление к увеличению быстродействия ЭВМ привело разра-
ботчиков микропроцессоров "на поле" биполярной интегральной техноло-
гии, прежде всего — ТТЛ, где были выпущены микропроцессоры, отнесен-
ные к третьему поколению, причем архитектура этих микропроцессоров су-
щественно отличалась от их предшественников.
Известно, что для любого электронного прибора справедливо соотношение:
ΔP⋅Δt = const ,
где ΔP — энергия переключения, Δt — время переключения.
ТТЛ-транзисторы в составе ИС обладали (в то время) на порядок большим
(по сравнению с n-МОП) быстродействием и соответственно на порядок
большим потреблением мощности. Технологические трудности в то время не
позволяли широко использовать активные способы отвода тепла от кристал-
ла, поэтому единственный способ сохранения работоспособности кристалла
в этих условиях — снижение степени интеграции.
Первый из выпущенных микропроцессоров третьего поколения — i3000 был
двухразрядным! Очевидно, сохранение в этом случае традиционной архитек-
туры, характерной для микропроцессоров второго поколения, не привело бы
к увеличению производительности системы, несмотря на то, что тактовая
частота кристалла увеличивалась значительно (на порядок).
Решение этой проблемы повлекло значительные структурные изменения
в микропроцессорах третьего поколения по сравнению со вторым:
􀂈 микропроцессоры выпускались в виде секций со средствами межразряд-
ных связей, позволяющими объединять в одну систему произвольное чис-
ло секций для достижения заданной разрядности. В состав секций вклю-
чалось АЛУ, РОН и некоторые элементы устройства управления;
􀂈 устройство управления выносилось на отдельный кристалл (группу кри-
сталлов), общий для всех процессорных секций;
􀂈 за счет резерва внешних выводов (малая разрядность) предусматривались
отдельные шины адреса, ввода и вывода данных, причем данные от раз-
ных источников вводились по различным шинам;
Часть II. Архитектура микропроцессорных систем 135
􀂈 кристаллы управления представляли собой управляющий автомат с программи-
руемой логикой, что позволяло достаточно легко реализовать практически лю-
бую систему команд на фиксированной структуре операционного устройства.
Таким образом, разработчики систем на базе микропроцессоров третьего по-
коления получали две "дополнительные степени свободы" — возможность
выбрать произвольную разрядность процессора (кратную разрядности сек-
ции) и самостоятельно реализовать практически произвольную систему
команд, оптимизированную для решения задач конкретного класса.
Поскольку микропроцессор в такой архитектуре размещался на нескольких
кристаллах БИС: арифметико-логические секции, схемы управления вместе с
БИС памяти микрокоманд, вспомогательные БИС (например, схемы уско-
ренного распространения переноса для АЛС) и др., то подобные микропро-
цессоры стали называть многокристальными, в отличие от однокристальных
микропроцессоров второго поколения.
Очевидно и то, что разработка систем на многокристальных микропроцессо-
рах требовала значительно больших усилий, времени и квалификации разра-
ботчиков, по сравнению с разработкой системы на "готовых" микропроцес-
сорах второго поколения с фиксированной структурой и системой команд.
В конце 70-х и начале 80-х годов прошлого века значительное число отечест-
венных и зарубежных фирм разрабатывали и выпускали серии БИС много-
кристальных микропроцессоров, причем разрядность секций постепенно уве-
личивалась до 4, 8 и даже 16 битов.
К тому времени технология уже не являлась решающим фактором классификации
МП, ибо появились разновидности технологий одного типа, обеспечивающие
очень широкий спектр характеристик МП, широкое распространение получили
комбинированные технологии (например, И2Л + ТТЛШ). Поэтому многокристаль-
ные МП выпускались как по биполярной, так и по МДП-технологиям.
Одной из наиболее удачных разработок этого направления можно считать
комплект БИС серии Am2900 фирмы AMD и близкую ему по архитектуре
отечественную серию К1804 [13].
Параллельно интенсивно развивалась архитектура однокристальных микро-
процессоров, наиболее характерным представителем которой можно считать
семейство х86 фирмы Intel. Развитие этого направления отличал безудерж-
ный рост производительности процессоров, обусловленный увеличением
разрядности процессоров, тактовой частоты, реализацией параллелизма на
всех уровнях работы процессора и применением других архитектурных ре-
шений, характерных ранее для "больших" ЭВМ.
Быстро возрастающие возможности микропроцессоров позволяли "захваты-
вать" в область цифровой обработки информации все новые сферы человече-
136 Часть II. Архитектура микропроцессорных систем
ской деятельности (достаточно вспомнить появление и распространение пер-
сональных ЭВМ).
Однако в сфере применения микропроцессоров всегда существовали задачи,
для решения которых не требовалась высокая производительность процессо-
ра (например, управление несложным инерционным технологическим обору-
дованием, бытовыми приборами). В этих случаях на первый план выступали
такие параметры, как надежность, простота реализации (стоимость). Для ре-
шения таких задач использование мощных однокристальных микропроцес-
соров становилось существенно избыточным.
Возрастающие возможности технологии в этом случае использовались не для
увеличения производительности процессора, а для размещения на кристалле,
наряду с относительно простым процессором, тех устройств, которые в тради-
ционной архитектуре располагались на плате рядом с микропроцессором в ви-
де отдельных БИС (СИС): тактовый генератор, ПЗУ, ОЗУ, порты параллельно-
го и последовательного обмена, контроллер прерываний, таймеры и др.
Таким образом, были получены полностью "самодостаточные" однокри-
стальные микроЭВМ (ОМЭВМ). Это направление стало интенсивно разви-
ваться, вначале на базе 8-разрядной архитектуры. Наиболее популярными из
них можно считать ОМЭВМ семейств MCS-51 фирмы Intel, MC68HC11 фир-
мы Motorola, PIC16 и PIC18 фирмы Microchip.
По мере развития на кристаллах ОМЭВМ стали, помимо перечисленных вы-
ше устройств, размещать аналого-цифровые и цифроаналоговые преобразо-
ватели, блоки энергонезависимой памяти (EEPROM), сложные таймерные
системы, схемы управления специализированными ВУ (например, семисег-
ментной индикацией) и др.
Дальнейшее развитие технологии привело к появлению 16- и даже 32-раз-
рядных однокристальных микроЭВМ (наиболее известные — от фирмы
Motorola), включающих, наряду с мощным центральным процессором, спе-
циализированные процессоры — таймерный и ввода/вывода, работающие
независимо от центрального, широкий набор блоков памяти и внешних уст-
ройств. Модульность архитектуры кристалла ОМЭВМ позволяет в рамках
одного семейства варьировать в широких пределах набор параметров кри-
сталла: состав и объем блоков памяти, набор внешних устройств и даже тип
помещаемого на кристалл центрального процессора.
Таким образом, пользователю предоставляется возможность выбора в очень
широких пределах архитектуры и параметров ОМЭВМ. При этом он получает
"готовую" ЭВМ, не требующую схемотехнических и архитектурных дорабо-
ток. В итоге современные ОМЭВМ практически полностью заняли ту нишу,
в которой долгое время существовали многокристальные микропроцессоры.
Глава 6
Базовая архитектура
микропроцессорной системы
Пожалуй, наиболее популярными в мире (и в нашей стране) являлись и яв-
ляются однокристальные микропроцессоры семейства х86 фирмы Intel. Се-
мейство берет свое начало от первого 8-разрядного микропроцессора i8080
(отечественный аналог — К580ВМ80) и включает 16- и 32-разрядные микро-
процессоры i8086, i80286, i80386, i80486, Pentium, ..., Pentium 4.
Схемотехнические решения систем на i8080 можно было бы считать базовы-
ми, но его система команд значительно отличается от языка старших моделей
микропроцессоров семейства. Поэтому "родоначальником" семейства приня-
то считать первый 16-разрядный микропроцессор — i8086 (отечественный
аналог — К1810ВМ86), на котором, кстати, были реализованы персональные
ЭВМ IBM PC XT.
Анализ архитектуры микропроцессорных систем (МПС) целесообразно на-
чинать с рассмотрения простейшей (базовой) модели, отражающей основные
принципы организации процессора, его системы команд, функционирование
основных подсистем. Большинство принципиальных решений, реализован-
ных в МПС на базе младших моделей семейства, сохранились и в старших
моделях.
Рассмотрим кратко организацию МПС на базе микропроцессора i8086. При
этом выделим для рассмотрения следующие подсистемы:
􀂈 процессорный модуль;
􀂈 память;
􀂈 ввод/вывод;
􀂈 прерывания;
􀂈 прямой доступ в память со стороны ВУ.
138 Часть II. Архитектура микропроцессорных систем
6.1. Процессорный модуль
Процессорный модуль — основная часть любой МПС. Помимо собственно
микропроцессора, он включает ряд вспомогательных схем, без которых
МПС не может функционировать (тактовый генератор, интерфейсные схемы
и др.).
6.1.1. Внутренняя структура микропроцессора
Структурная схема микропроцессора i8086 представлена на рис. 6.1. Микро-
процессор включает в себя три основных устройства:
􀂈 УОД — устройство обработки данных;
􀂈 УСМ — устройство связи с магистралью;
􀂈 УУС — устройство управления и синхронизации.
УОД предназначено для выполнения команд и включает в себя 16-разрядное
АЛУ, системные регистры и другие вспомогательные схемы; блок регистров
(РОН, базовые и индексные) и блок микропрограммного управления.
УСМ обеспечивает формирование 20-разрядного физического адреса памяти
и 16-разрядного адреса ВУ, выбор команд из памяти, обмен данными с ЗУ,
ВУ, другими процессорами по магистрали. УСМ включает в себя сумматор
адреса, блок регистров очереди команд и блок сегментных регистров.
УУС обеспечивает синхронизацию работы устройств МП, выработку управ-
ляющих сигналов и сигналов состояния для обмена с другими устройствами,
анализ и соответствующую реакцию на сигналы других устройств МПС.
Микропроцессор i8086 может работать в одном из двух режимов — мини-
мальном и максимальном. Минимальный режим предназначен для реализа-
ции однопроцессорной конфигурации МПС с организацией, подобной МПС
на базе i8080, но с увеличенным адресным пространством, более высоким
быстродействием и значительно расширенной системой команд. Максималь-
ный режим предполагает наличие в системе нескольких микропроцессоров,
работающих на общую системную шину. МПС на базе i8086 с использовани-
ем максимального режима не получили широкого распространения. Более
того, в последующих моделях своих микропроцессоров (80286, 80386, 80486)
фирма Intel отказалась от поддержки мультипроцессорной архитектуры. По-
этому мы здесь не будем рассматривать особенности организации макси-
мального режима.
На внешних выводах МП i8086 широко используется принцип мультиплек-
сирования сигналов — передача разных сигналов по общим линиям с разде-
Глава 6. Базовая архитектура микропроцессорной системы 139
лением во времени. Кроме того, одни и те же выводы могут использоваться
для передачи разных сигналов в зависимости от режима (min — max).
В табл. 6.1 приведено описание внешних выводов МП i8086. При описании
выводов косой чертой (/) разделены сигналы, появляющиеся на выводе в раз-
ные моменты машинного цикла. В круглых скобках указаны сигналы, харак-
терные только для максимального режима. Символ * после имени сигнала —
знак его инверсии.
Рис. 6.1. Структура микропроцессора i8086
140 Часть II. Архитектура микропроцессорных систем
Таблица 6.1. Внешние выводы МП i8086
Внешний вывод Описание
A/D[15:0] Младшие 0—15 разряды адреса/данные
A[19:16]/ST[6:3] Старшие 16—19 разряды адреса/сигналы состояния
ВНЕ* /ST[7] Разрешение передачи старшего байта данных/сигнал состояния
STB(QSO) Строб адреса (состояние очереди команд)
R* Чтение
W* /(LOCK*) Запись (блокировка канала)
M-IO*(ST2*) Память — внешнее устройство (состояние цикла)
OP-IP*(ST1*) Выдача/прием (состояние цикла)
DE*(STO*) Разрешение передачи данных (состояние цикла)
TEST* Проверка
RDY Готовность
CLR Сброс
CLC Тактовый сигнал
INT Запрос внешнего прерывания
INTA*(QS1) Подтверждение прерывания (состояние очереди команд)
NMI Запрос немаскируемого прерывания
HLD(RQ*/EO) Запрос ПДП (запрос/подтверждение доступа к магистрали)
NLDA(RQ* /El) Подтверждение ПДП (запрос/подтверждение доступа к магистра-
ли)
MIN/MAX* Потенциал задания режима (min = 1, max = 0)
6.1.2. Командный и машинный циклы
микропроцессора
Микропроцессор i8086 работает в составе МПС, обмениваясь с памятью
и ВУ словами длиной 2 байта, т. к. разрядность шины данных составляет
16 битов. В основе работы микропроцессора лежит командный цикл — дей-
ствия по выбору из памяти и выполнению одной команды.
Любой командный цикл (КЦ) начинается с извлечения из памяти первого
слова команды по адресу, хранящемуся в счетчике команд (PC). Команды
i8086 могут иметь длину от 1 до 6 байтов, причем в первом слове содержится
Глава 6. Базовая архитектура микропроцессорной системы 141
информация о длине команды. Таким образом, для извлечения из памяти од-
ной команды может потребоваться одно или несколько обращений к ОЗУ.
В зависимости от типа и формата команды, способов адресации и числа опе-
рандов командный цикл может включать в себя различное число обращений
к памяти и ВУ, поскольку кроме чтения самой команды в КЦ может потребо-
ваться чтение операндов и размещение результата.
Хотя обращения к ЗУ/ВУ располагаются в разных частях КЦ, выполняются
они по единым правилам, соответствующим интерфейсу МПС, и реализова-
ны на общем оборудовании управляющего автомата. Действия МПС по пере-
даче в (из) МП одного слова команды (данных) называются машинным цик-
лом. КЦ состоит из одного или нескольких машинных циклов (МЦ).
Машинный цикл включает выдачу процессором адреса памяти или внешнего
устройства, по которому производится обращение, выдачу управляющих
сигналов, характеризующих тип машинного цикла и направление передачи
данных (М-IO, OP-IP), выдачу синхронизирующих (стробирующих) сигналов
(STB, R, W) и собственно передачу данных. В i8086 реализована мультип-
лексированная шина адреса/данных. Это объясняется дефицитом внешних
выводов кристалла и требует дополнительного такта для выдачи адреса и до-
полнительного управляющего сигнала STB, идентифицирующего наличие
адреса на общей шине A/D.
По большому счету разнообразие МЦ сводится к двум разновидностям —
чтению (данные или команды принимаются в процессор) и записи (данные
выдаются из процессора). Временные диаграммы соответствующих МЦ при-
ведены на рис. 6.2.
а б
Рис. 6.2. Машинные циклы микропроцессора i8086:
а — цикл ЧТЕНИЕ; б — цикл ЗАПИСЬ
142 Часть II. Архитектура микропроцессорных систем
Цикл начинается с формирования в такте Т1 сигнала M-IO, определяющего
тип устройства — память или ВУ, с которым осуществляется обмен данны-
ми. Длительность сигнала M-IO равна длительности машинного цикла, и он
используется для селекции адреса устройств. В Т1 и в начале Т2 МП выдает
адреса А[19:16] и А[15:0] и сигнал ВНЕ, который вместе с А0 определяет
выбор передачи либо всего слова, либо одного из его байтов. По спаду стро-
ба ALE адрес фиксируется во внешних регистрах-защелках. В такте Т2 про-
исходит переключение шин: на выводы А[19:16]/ST[6:3] поступают сигналы
состояния; а выводы A/D[15:0] используются для приема/передачи данных.
Описанные выше машинные циклы являются синхронными; их длительность
определяется только процессором. Однако такой обмен возможен лишь
с устройствами, быстродействие которых не уступает процессорному. В про-
тивном случае микропроцессор должен реализовать асинхронный способ об-
мена, включающий анализ сигнала от устройства о готовности к обмену или
о завершении процедуры обмена.
Роль такого сигнала в i8086 (и всех процессорах старших моделей семейства
х86) играет вход RDY (от англ. ready — готовность), который всегда должен
быть активным при синхронном обмене (с "быстрыми" устройствами). При
обмене с "медленными" устройствами значение RDY должно оставаться не-
активным (в разных процессорах активным для RDY может быть уровень
логической 1 или логического 0) до тех пор, пока устройство, с которым свя-
зывается процессор, не завершит процедуру обмена, сообразуясь со своим
быстродействием.
Время ожидания процессором готовности устройства может быть сколь
угодно большим. Для этого в такте Т3 процессор проверяет значение сигнала
RDY, и если он неактивен, после такта Т3 в машинный цикл вставляется про-
извольное количество тактов ожидания Tw, в каждом из которых анализирует-
ся значение RDY. При появлении активного значения RDY микропроцессор
переходит к такту Т4 и завершает МЦ. Таким образом, удается согласовывать
работу микропроцессора с устройствами различного быстродействия.
6.1.3. Реализация процессорных модулей
и состав линий системного интерфейса
Большинство микропроцессоров не могут работать в составе МПС без неко-
торых дополнительных схем, составляющих вместе с микропроцессором т. н.
процессорный модуль. Прежде всего, на вход CLK микропроцессора необхо-
димо подать прямоугольные импульсы тактовой частоты от специального
внешнего тактового генератора.
Глава 6. Базовая архитектура микропроцессорной системы 143
Для микропроцессора i8086 частота тактовых импульсов может лежать
в диапазоне 2—6 МГц.
На рис. 6.3 приведен один из вариантов упрощенной функциональной схемы
процессорного модуля на базе i8086. На схеме не показаны некоторые эле-
менты и связи (например, схема начального сброса и др.).
Рис. 6.3. Структура процессорного модуля на базе микропроцессора i8086
Микропроцессор i8086 реализован по n-МДП-технологии, и его выходные
каскады не обеспечивают достаточной нагрузочной способности для линий
системного интерфейса. Поэтому к выходным линиям микропроцессора
обычно подключают буферные схемы BD, реализованные по технологии ТТЛ.
Кроме того, шины адреса и данных в i8086 мультиплексированы. Адрес
удерживается на выводах микропроцессора только в течение одного такта
машинного цикла, а использоваться должен весь МЦ. Поэтому адрес необхо-
димо запомнить в специальных внешних регистрах-защелках RG (которые,
кстати, играют и роль буферной схемы шины адреса).
Наконец, часто требуется преобразовать управляющие сигналы, выдаваемые
микропроцессором, в стандартные сигналы системного интерфейса. Так,
144 Часть II. Архитектура микропроцессорных систем
i8086 формирует выходные сигналы, идентифицирующие тип машинного
цикла, и сигналы стробирования: М-IO, OP-IP, R, W. Системная шина ис-
пользует сигналы записи и чтения памяти — RDM, WRM и записи и чтения
внешнего устройства — RDIO, WRIO. Преобразования процессорных сигна-
лов в шинные осуществляет простая логическая схема L.
6.2. Машина пользователя и система команд
Программная модель микропроцессора (рис. 6.4) включает в себя программ-
но-доступные объекты МПС, т. е. те объекты, состояние которых можно про-
анализировать и/или изменить при помощи команд микропроцессора. К та-
ким объектам относятся внутренние регистры микропроцессора, ячейки
памяти и порты ввода/вывода.
Рис. 6.4. Микропроцессор i8086 — машина пользователя
Глава 6. Базовая архитектура микропроцессорной системы 145
Рассмотрим машину пользователя i8086. Кроме показанных на рис. 6.4 реги-
стров процессора, в машину пользователя i8086 включатся адресное про-
странство памяти объемом 1 Мбайт и два пространства портов ввода и выво-
да по 64 Кбайт каждое.
Помимо операций с 16-разрядными регистрами общего назначения (РОН)
AX — DX, допускается обращение к каждому байту этих регистров: AL — DL,
АН — DH. В процессорах семейства х86 система команд построена таким об-
разом, что в некоторых командах РОН выполняют определенные по умолча-
нию функции счетчиков, индексных регистров, источников адреса и др.
Рис. 6.5. Формат регистра признаков i8086
16-разрядные регистры ВР, SI, DI используются для образования исполни-
тельных адресов памяти, SP — указатель стека, IP — программный счетчик
(СчК), Flags — регистр флагов, формат которого приведен на рис. 6.5, где:
􀂈 CF — перенос/заем из старшего разряда;
􀂈 PF — паритет (четность числа единиц в результате);
􀂈 AF — дополнительный перенос (из 3-го разряда);
􀂈 ZF — нулевой результат;
􀂈 SF — отрицательный результат (знак);
􀂈 OF — признак арифметического переполнения;
􀂈 DF — направление, определяет направление модификации адресов масси-
вов в командах цепочек (увеличение или уменьшение адреса);
􀂈 IF — маскирует внешнее прерывание по входу INT (при IF = 1 прерывание
разрешено);
􀂈 TF — управляет пошаговым режимом работы микропроцессора.
При TF = 1 после выполнения каждой команды автоматически формируется
прерывание с вектором 1.
6.2.1. Распределение адресного пространства
Адресное пространство МП определяется в i8086 разрядностью шины адре-
са/данных и адреса и составляет 220 байтов = 1 Мбайт. В этом адресном про-
странстве микропроцессору одновременно доступны лишь четыре сегмента,
146 Часть II. Архитектура микропроцессорных систем
два из которых (DS и ES) предназначены для размещения данных, CS — сег-
мент кода (для размещения программы) и SS — сегмент стека.
Размеры сегментов определяются разрядностью логических адресов команд,
данных и стека. Логические адреса команд и стека (верхушки) хранятся
в 16-разрядных регистрах IP и SS соответственно, а логический адрес данных
вычисляется в команде одним из многочисленных, предусмотренных систе-
мой команд, способов и также составляет 16 битов.
Таким образом, размер каждого сегмента в i8086 составляет 216 байтов =
= 64 Кбайт. Положение сегмента в адресном пространстве (его начальный
адрес) определяется содержимым одноименного сегментного регистра.
Формирование физического адреса иллюстрируется на рис. 6.6, из которого
видно, что граница сегмента в адресном пространстве может быть установ-
лена не произвольно, а таким образом, чтобы начальный адрес сегмента
был кратен 16.
Рис. 6.6. Формирование физического адреса в i8086
По умолчанию сегментные регистры выбираются для образования физиче-
ского адреса следующим образом: при считывании команды по адресу IP ис-
пользуется CS, при обращении к данным — DS или ES, при обращении
к стеку — SS. С помощью специальных приставок к команде (префиксов)
можно назначить для использования произвольный сегментный регистр
(кроме пары CS:IP, которая не подлежит модификации). Границы сегментов
могут быть выбраны таким образом, что сегменты будут изолированы друг
от друга, пересекаться или даже полностью совпадать. Например, если загру-
зить CS = SS = DS = ES = 0, то все сегменты будут совпадать друг с другом
и начинаться с нулевого адреса — вариант организации адресного простран-
ства i8080.
Глава 6. Базовая архитектура микропроцессорной системы 147
6.2.2. Система команд i8086
Система команд i8086 и, вообще, всего семейства х86 подробно описана
в многочисленных справочниках и руководствах, например [3, 11, 13, 14],
поэтому далее мы кратко остановимся только на особенностях системы ко-
манд i8086, не вдаваясь в излишние подробности.
i8086 отличается разнообразием форматов команд и способов адресации.
Длина команды может составлять от 1 до 6 байтов, причем в первых двух
байтах (иногда — в первом) определяется код операций, количество и длина
операндов и способ их адресации. В остальных байтах команды могут раз-
мещаться непосредственный операнд, прямой адрес или смещение.
Большинство команд i8086 являются двухадресными, причем один адрес оп-
ределяет регистр процессора, а другой — ячейку памяти или регистр.
Операнд в памяти может адресоваться прямо или косвенно посредством со-
держимого базовых (BP, BX) или индексных (SI, DI) регистров, а также их
суммы. Предусмотрены многочисленные варианты относительной адреса-
ции, при которых логический адрес образуется как сумма двух или трех сла-
гаемых — одного или двух регистров процессора и 8- или 16-разрядного
смещения, размещаемого в команде.
Режимы адресации спроектированы с учетом эффективной реализации язы-
ков высокого уровня. Например, к простой переменной можно обратиться
в режиме прямой адресации, а к элементу массива — в режиме косвенной
адресации посредством BX, SI. Режим адресации через ВР предназначен для
доступа к данным из сегмента стека, что удобно при реализации рекурсивных
процедур и компиляторов языков высокого уровня.
Система команд насчитывает 113 базовых команд, объединенных в следую-
щие группы:
􀂈 команды передачи данных:
• между регистрами и памятью (включая стек), обмен содержимым ис-
точника и приемника;
• ввод, вывод, табличное преобразование;
• загрузка исполнительного адреса в РОН, загрузка 4-байтового адресно-
го объекта в регистры-указатели (начальный адрес сегмента и смеще-
ние в сегменте);
• передача содержимого регистра F флагов в память, в стек и из стека;
􀂈 арифметические команды:
• сложение, вычитание, умножение и деление двоичных чисел со знаком
и без знака (произведение и делимое представляются числами двойной
длины);
148 Часть II. Архитектура микропроцессорных систем
• десятичная коррекция сложения и вычитания упакованных двоично-
десятичных чисел;
• десятичная коррекция сложения, вычитания, умножения и деления
распакованных двоично-десятичных чисел;
􀂈 логические команды и сдвиги:
• инверсия, конъюнкция, дизъюнкция, неравнозначность;
• TEST — поразрядная конъюнкция операндов с установкой флагов, но
без занесения результатов;
• сдвиги на 1 или заданное число разрядов (константа сдвига располага-
ется в CL);
􀂈 команды передачи управления: переходы, вызовы, возвраты имеют две
разновидности — внутрисегментные ("близкие") и межсегментные
("дальние"). При близких передачах загружается только IP, при даль-
них — IP и CS. Передачи управления могут быть прямыми (целевой ад-
рес — в команде) или косвенными (целевой адрес вычисляется с исполь-
зованием стандартных режимов адресации). В 16 командах условных
переходов проверяются отношения знаковых и беззнаковых чисел. Име-
ются 4 команды управления циклами, которые рассчитаны на размещение
числа повторений цикла в регистре СХ;
􀂈 команды обработки цепочек данных манипулируют последовательностя-
ми байтов или слов в памяти. Время обработки цепочек этими командами
гораздо меньше, чем соответствующей программной реализацией.
6.3. Функционирование
основных подсистем МПС
Теперь можно рассмотреть функционирование основных подсистем базовой
МПС с интерфейсом типа "общая шина". Этот термин используется в двух
смыслах: во-первых, как обозначение принципа организации связи процессо-
ра с другими устройствами в составе ЭВМ, во-вторых, как обозначение
(в русском переводе) конкретного интерфейса Unibus мини-ЭВМ семейства
PDP-11 фирмы DEC.
Unibus явился, пожалуй, первым интерфейсом, в котором были полностью
реализованы принципы "общей шины":
􀂈 все линии интерфейса делятся на три группы: адрес, данные, управление;
􀂈 все устройства, в т. ч. процессор, подключаются к линиям интерфейса
одинаковым образом;
Глава 6. Базовая архитектура микропроцессорной системы 149
􀂈 идентификация объектов на шине (ячеек памяти, регистров внешних уст-
ройств) осуществляется с помощью уникального для каждого объекта
адреса;
􀂈 в каждый момент времени по шине могут взаимодействовать только два
устройства, одно из которых является активным, а другое — пассивным.
Активное устройство формирует адрес обмена, управляющие сигналы
и может выдавать (в цикле записи) или принимать (в цикле чтения) дан-
ные, которые принимает или выдает пассивное устройство;
􀂈 обмен между устройствами может осуществляться в синхронном или
асинхронном режиме. При синхронном обмене все временные характери-
стики обмена определяются только активным устройством, которое не
анализирует ни готовность пассивного к обмену, ни факт завершения об-
мена. Синхронный обмен допустим лишь с быстродействующими пассив-
ными устройствами (их быстродействие должно быть не ниже быстродей-
ствия активного устройства), которые всегда готовы к обмену (например,
регистр двоичной индикации). При асинхронном обмене пассивное уст-
ройство формирует сигнал готовности к обмену и/или сигнал завершения
обмена, которые анализирует активное устройство.
Интерфейсы, реализующие принципы "общей шины", широко распространи-
лись в мини- и микроЭВМ, МПС различного назначения. Многие из них,
правда, нарушали некоторые принципы "канонической общей шины", на-
пример, за счет появления отдельных адресных пространств регистров про-
цессора и портов ввода и вывода. Однако основные принципы, изложенные
выше, сохраняются в многочисленных разновидностях таких интерфейсов.
К достоинствам интерфейсов типа "общая шина" можно отнести его относи-
тельную простоту, гибкость системы и возможность ее модификации в ши-
роких пределах.
К недостаткам — невозможность распараллеливания процессов обмена (од-
новременно осуществляется связь только пары устройств). Кроме того, нали-
чие на общей шине устройств с существенно различным быстродействием
затрудняет достижение оптимальных характеристик системы.
В разд. 6.1.3 мы подробно рассмотрели организацию процессорного модуля
на базе процессора i8086. Состав внешних выводов процессорного модуля
(см. рис. 6.3) позволяет подключить его к интерфейсу, реализованному по
принципу общей шины:
􀂈 линии адреса AB[19:0];
􀂈 линии данных DB[15:0];
􀂈 линии управления RDM, WRM, RDIO, WRIO.
150 Часть II. Архитектура микропроцессорных систем
Другие линии управления, входящие в состав интерфейса, будут добавлены
при рассмотрении соответствующих подсистем.
6.3.1. Оперативная память
Объем адресного пространства МПС с интерфейсом "общая шина" определя-
ется главным образом разрядностью шины адреса и, кроме того, номенклату-
рой управляющих сигналов интерфейса. Управляющие сигналы могут опре-
делять тип объекта, к которому производится обращение (ОЗУ, ВУ, стек,
специализированные ПЗУ и др.). В случае, если МП не выдает сигналов,
идентифицирующих тип пассивного устройства (или они не используются
в МПС) — для селекции берутся только адресные линии. Число адресуемых
объектов составляет в этом случае 2k , где k — разрядность шины адреса.
Будем называть такое адресное пространство единым. Иногда говорят, что
ВУ в едином адресном пространстве "отображены на память", т. е. адре-
са ВУ занимают адреса ячеек памяти.
При использовании информации о типе устройства, к которому идет обраще-
ние, одни и те же адреса можно назначать для устройств разных типов, осу-
ществляя селекцию с помощью управляющих сигналов.
Так, большинство МП выдают в той или иной форме информацию о типе об-
ращения. В результате в большинстве интерфейсов присутствуют отдельные
управляющие линии для обращения к памяти и вводу/выводу, реже — к сте-
ку или специализированному ПЗУ. В результате суммарный объем адресного
пространства МПС может превышать величину 2k .
Например, системная шина МПС на базе микропроцессора i8086 включает
20-разрядную шину адреса и управляющие сигналы, идентифицирующие об-
ращение к памяти (RDM, WRM) и вводу/выводу (RDIO, WRIO). Поэтому
в системе доступны 1 Мбайт ячеек памяти (адреса 00000 — FFFFF) + 64 Кбайт
адресов ввода + 64 Кбайт адресов вывода (0000 — FFFF). Последняя величи-
на определяется тем, что в командах ввода/вывода процессоров семейства
х86 адрес внешнего устройства имеет разрядность 16 битов.
Диспетчер памяти
При необходимости расширить объем памяти за пределы адресного про-
странства можно воспользоваться так называемым диспетчером памяти.
В простейшем случае он представляет собой программно-доступный регистр,
который должен располагаться в пространстве ввода/вывода. В него заносит-
ся номер активного в данный момент банка памяти, причем объем банка мо-
жет равняться объему адресного пространства МП.
Глава 6. Базовая архитектура микропроцессорной системы 151
Очевидно, в каждый момент времени процессору доступен только один банк.
При необходимости перехода в другой банк памяти МП должен предвари-
тельно выполнить программную процедуру (часто всего одну команду) пере-
загрузки содержимого регистра номера банка.
К развитию этой идеи можно отнести механизм сегментации памяти в 16-
и 32-разрядных МП фирмы Intel.
6.3.2. Ввод/вывод
Подсистема ввода/вывода (ПВВ) обеспечивает связь МП с внешними уст-
ройствами, к которым будем относить:
􀂈 устройства ввода/вывода (УВВ): клавиатура, дисплей, принтер, датчики
и исполнительные механизмы, АЦП, ЦАП, таймеры и т. п.;
􀂈 внешние запоминающие устройства (ВЗУ): накопители на магнитных
дисках, "электронные диски", CD и др.
В рамках рассмотрения ПВВ будем полагать термины "УВВ" и "ВУ" сино-
нимами, т. к. обращение к ним со стороны процессора осуществляется по од-
ним законам.
ПВВ в общем случае должна обеспечивать выполнение следующих функций:
􀂈 согласование форматов данных, поскольку процессор всегда выдает/при-
нимает данные в параллельной форме, а некоторые ВУ — в последова-
тельной. С этой точки зрения различают устройства параллельного и по-
следовательного обмена. В рамках параллельного обмена не производится
преобразование форматов передаваемых слов, в то время как при после-
довательном обмене осуществляется преобразование параллельного кода
в последовательный и наоборот. Все варианты, при которых длина слова
ВУ (больше 1 бита) не совпадает с длиной слова МП, сводятся к разно-
видностям параллельного обмена;
􀂈 организация режима обмена — формирование и прием управляющих сиг-
налов, идентифицирующих наличие информации на различных шинах, ее
тип, состояние ВУ (Готово, Занято, Авария), регламентирующих времен-
ные параметры обмена. По способу связи процессора и ВУ (активного и
пассивного) различают синхронный и асинхронный обмены, различия ме-
жду которыми мы обсудили в начале настоящей главы.
Параллельный обмен
Простейшая подсистема параллельного обмена должна обеспечить лишь де-
шифрацию адреса ВУ и электрическое подключение данных ВУ к системной
шине данных DB по соответствующим управляющим сигналам. На рис. 6.7
152 Часть II. Архитектура микропроцессорных систем
показаны устройства параллельного ввода и вывода информации в составе
МПС на базе буферных регистров К580ИР82.
Очевидно, при обращении процессора (он в подобных циклах играет роль
активного устройства) к устройству ввода, адрес соответствующего регистра
помещается процессором на шину адреса и формируется управляющий сиг-
нал RDIO. Дешифратор адреса, включающий и линию RDIO, при совпадении
адреса и управляющего сигнала активизирует выходные линии регистра
и его содержимое поступает по шине данных в процессор.
Рис. 6.7. Параллельный обмен на базе буферных регистров
Аналогично идет обращение к устройству вывода. Совпадение адреса уст-
ройства на шине адреса с активным уровнем сигнала WRIO обеспечивает
"защелкивание" состояния шины данных в регистре вывода.
Характерно, что при таком способе обмена процессор не анализирует готов-
ность ВУ к обмену, а длительность существования адреса, данных и управ-
ляющего сигнала целиком определяется тактовой системой процессора
и принятым алгоритмом командного цикла. Напомним, что такой способ об-
мена называется синхронным. Синхронный обмен реализуется наиболее про-
сто, но он возможен только с устройствами, всегда готовыми к обмену, либо
Глава 6. Базовая архитектура микропроцессорной системы 153
процессор должен перед выполнением команды ввода/вывода программными
средствами убедиться в готовности ВУ к обмену (обычно в этом случае пред-
варительно анализируется состояние флага готовности, формируемого ВУ).
Кроме того, быстродействие ВУ, взаимодействующее с процессором в син-
хронном режиме, должно гарантировать прием/выдачу данных за фиксиро-
ванное время, выделенное процессором на цикл обмена.
Во многих микропроцессорных комплектах выпускают специальные интер-
фейсные БИС, существенно расширяющие (по сравнению с использованием
регистров) возможности разработчиков при организации параллельного обме-
на в МПС. Такие БИС обычно имеют несколько каналов передачи информа-
ции, позволяют программировать направление передачи (ввод или вывод) по
каждому каналу и выбирать способ обмена — синхронный или асинхронный.
Типичным примером такой БИС может служить программируемый контрол-
лер параллельного обмена (далее "контроллер") 8255А (отечественный ана-
лог — К580ВВ55).
Контроллер параллельного обмена К580ВВ55 [14] представляет собой трех-
канальный байтовый интерфейс и позволяет организовать обмен байтами
с периферийным оборудованием в различных режимах. Он включает в себя
три 8-разрядные канала ввода/вывода А, В и С, буфер шины данных,
8-разрядный регистр управления Y и блок управления.
Подключение контроллера к системной шине показано на рис. 6.8. Каналы
адресуются двумя линиями адреса А1, А0. В МПС контроллер размещают,
как правило, в пространстве адресов ввода/вывода. Поэтому в качестве стро-
бов чтения и записи используются сигналы RDIO, WRIO, для селекции кон-
троллера по CS дешифрируются старшие разряды адреса, а для выбора адре-
суемого объекта внутри контроллера — два младших.
Каналы контроллера программируются для работы в одном из трех режимов:
􀂈 режим "0" — синхронный однонаправленный ввод/вывод;
􀂈 режим "1" — асинхронный однонаправленный ввод/вывод;
􀂈 режим "2" — асинхронный двунаправленный ввод/вывод.
Режим работы контроллера устанавливается кодом управляющего слова, ко-
торое предварительно записывается в регистр управления Y.
В режиме "0" контроллер может работать как четыре порта ввода/вывода:
А[7:0]. В[7:0], С[7:4], С[3:0], причем каждый порт может быть независимо
запрограммирован на ввод или на вывод. При этом к порту, определенному
как выходной, нельзя обращаться по чтению, а на входной порт нельзя выво-
дить информацию.
154 Часть II. Архитектура микропроцессорных систем
Рис. 6.8. Подключение контроллера 8255 к системной шине
В асинхронном однонаправленном режиме "1" могут работать только кана-
лы А и В, причем соответствующие линии канала С придаются каналам А и
В для передачи управляющих сигналов. Как и в режиме "0", каналы А и В
программируются на ввод или вывод (независимо).
В режиме "2" может работать только канал А, к которому в этом случае
можно обращаться как по записи, так и по чтению (двунаправленный асин-
хронный обмен). При этом канал В может быть запрограммирован как на ра-
боту в режиме "1", так и в режиме "0".
Выбор режимов каналов и направления передачи данных в них осуществляется
загрузкой во внутренний управляющий регистр Y соответствующего кода.
Линии канала С могут работать только в режиме "0", причем независимо
можно запрограммировать направление передачи старшей и младшей тетра-
ды канала С. Если для каналов А и/или В выбраны режимы "2" и/или "1", то
соответствующие линии канала С перестают работать в режиме "0" и исполь-
зуются для передачи управляющих сигналов. Линии канала С, которые
не используются при выбранной комбинации режимов каналов А и В, можно
использовать как линии ввода или вывода канала С, работающего в
"0"-режиме. Кроме того, всегда имеется возможность программного сбро-
са/установки произвольного разряда канала С.
Режим "0" является синхронным и во многом напоминает рассмотренный
выше механизм обмена с использованием регистров. Рассмотрим подробнее
процесс асинхронного обмена в режиме "1".
Глава 6. Базовая архитектура микропроцессорной системы 155
Режим "1" обеспечивает однонаправленную асинхронную передачу инфор-
мации между процессором и ВУ. При этом каналы А и В используются как
регистры данных, а канал С — для приема и формирования управляющих
сигналов, сопровождающих асинхронный обмен, причем каждый разряд ка-
нала С имеет строго определенное функциональное назначение [14].
Например, если канал запрограммирован на ввод в режиме "1", то процессор
может вводить данные этого канала только "будучи уверенным" в их готов-
ности. Об этой готовности ему должен сообщить контроллер путем установ-
ки специального признака — флага в определенном разряде регистра С и,
может быть, формированием запроса на прерывание с соответствующим век-
тором (о прерываниях подробнее см. в разд. 6.3.3). С другой стороны, внеш-
нее устройство, подключенное к каналу, не должно выдавать новую порцию
информации, пока прежняя не будет прочитана процессором.
Для обеспечения синхронизации ввода в режиме "1" каналу придаются три
линии канала С для передачи управляющих сигналов:
􀂈 STB (строб записи) — сигнал, формируемый ВУ для записи очередного
байта данных в регистр канала:
􀂈 IBF (подтверждение приема) — сигнал, формируемый контроллером для
ВУ в тот момент, когда процессор прочитал содержимое регистра канала.
Пока сигнал IBF неактивен, ВУ запрещается вырабатывать новый строб
записи;
􀂈 INT (запрос прерывания) — вырабатывается контроллером для процессора
после того, как очередной байт данных запишется в регистр канала. Это же
событие устанавливает флаг готовности канала в разряде регистра С.
Обмен начинается с подачи ВУ сигнала STB, по которому данные помеща-
ются в регистр канала. Контроллер, во-первых, сбрасывает сигнал IBF, за-
прещая ВУ выработку нового строба, и, во-вторых, устанавливает флаг го-
товности и (может быть) формирует сигнал запроса на прерывание INT
процессору. Процессор может достаточно долго не реагировать на сообще-
ние о готовности канала, занятый более приоритетными процедурами. Все
это время установлены готовность и INT и сброшен IBF, новая порция ин-
формации не может поступить в канал.
Когда процессор обратится по адресу канала и введет хранящуюся в регистре
информацию, контроллер сбрасывает флаг готовности и запрос на прерыва-
ние INT и устанавливает сигнал IBF, разрешая ВУ записывать следующий
байт в регистр канала. Однако ВУ может быть достаточно инерционным и
довольно долго подготавливает следующую порцию информации, но пока
ВУ не сформирует новый сигнал STB, контроллер не выработает сигнал го-
товности и, следовательно, процессор не будет обращаться по адресу канала.
156 Часть II. Архитектура микропроцессорных систем
Подобный режим обмена позволяет исключить как потерю информации
в контроллере, так и повторный ввод в процессор прежней информации.
Аналогично реализуется и асинхронный режим вывода. Каналу, запрограм-
мированному на вывод в режиме "1", придаются три линии управления ка-
нала С:
􀂈 OBF (выходной буфер заполнен) — сигнал формируется контроллером
для ВУ после того, как процессор записал в регистр канала новую порцию
информации;
􀂈 ACK (подтверждение записи) — сигнал от ВУ контроллеру, подтвер-
ждающий прием очередного байта;
􀂈 INT (запрос прерывания) — запрос прерывания от контроллера процессо-
ру для выдачи процессором в канал следующего байта информации.
Процедуры ввода и вывода в режиме "2" осуществляются аналогично соот-
ветствующим процедурам в режиме "1".
Последовательный обмен
При организации последовательного обмена ключевыми могут считаться две
проблемы:
􀂈 синхронизация битов передатчика и приемника;
􀂈 фиксация начала сеанса передачи.
Различают два способа передачи последовательного кода: синхронный
и асинхронный.
При синхронном методе передатчик генерирует две последовательности —
информационную TxD и синхроимпульсы CLK, которые передаются на при-
емник по разным линиям. Синхроимпульсы обеспечивают синхронизацию
передаваемых битов, а начало передачи отмечается по-разному. При органи-
зации внешней синхронизации (рис. 6.9) сигнал начала передачи BD генери-
руется передатчиком и передается на приемник по специальной линии.
Рис. 6.9. Последовательный синхронный обмен
Глава 6. Базовая архитектура микропроцессорной системы 157
Системы с внутренней синхронизацией генерируют на линию данных специ-
альные коды длиной 1—2 байта — символы синхронизации. Для каждого
приемника предварительно определяются конкретные синхросимволы, таким
образом можно осуществлять адресацию конкретного абонента из несколь-
ких, работающих на одной линии. Каждый приемник постоянно принимает
биты с линии RxD, формирует символы и сравнивает с собственными син-
хросимволами. При совпадении принятых символов с заданными для этого
приемника синхросимволами последующие биты поступают в канал данных
приемника. В случае реализации внутренней синхронизации между приемни-
ком и передатчиком "прокладывают" только две линии — данных и синхро-
импульсов.
Наконец, при асинхронном способе обмена можно ограничиться одной ли-
нией — данных. Для надежной синхронизации обмена в асинхронном режиме:
􀂈 передатчик и приемник настраивают на работу с одинаковой частотой;
􀂈 передатчик формирует стартовый и стоповый биты, отмечающие начало
и конец посылки;
􀂈 передача ведется короткими посылками (5—9 битов), а частоты передачи
выбираются сравнительно низкими.
Принцип последовательного асинхронного обмена по единственной линии
показан на рис. 6.10. Пока передачи нет, на линии передатчик удерживает
высокий уровень (H). Передача начинается с выдачи в линию стартового би-
та низкого уровня (длительности всех битов τ одинаковы и определяются
частотой передатчика fT = 1 τ ).
Рис. 6.10. Последовательный асинхронный обмен
Частота приемника fR устанавливается равной 16× fT . Когда приемник об-
наруживает на линии перепад Н → L, он включает счетчик тактов до 16,
причем еще дважды за период τ проверяет состояние линии. Если низкий
уровень (L) подтверждается, приемник считает, что принял старт-бит,
158 Часть II. Архитектура микропроцессорных систем
и включает счетчик принимаемых битов. Если во второй и третьей проверке
на линии определяется Н-уровень, то перепад считается помехой и старт-бит
не фиксируется.
Каждый последующий (информационный) бит принимается таким образом,
что за период τ трижды проверяется состояние линии (например, в 3, 8 и
11 тактах приемника) и значение принимаемого бита определяется по мажо-
ритарному принципу. Принятый бит помещается слева в сдвиговый регистр
приемника. После принятия последнего информационного бита (количество
битов в посылке определяется протоколом обмена и составляет обычно от 5
до 9) обязательно должен последовать стоповый бит Н-уровня. Во время по-
ступления стоп-бита содержимое сдвигового регистра приемника передается
в память, а в регистр передатчика может загружаться новая порция информа-
ции для передачи. Отсутствие стопового бита воспринимается приемником
как ошибка передачи посылки.
После стопового бита можно формировать стартовый бит новой посылки или
"держать паузу" произвольной длительности, при которой на линии присут-
ствует Н-уровень.
Наличие стартового бита позволяет в начале каждой посылки синхронизиро-
вать фазы приемника и передатчика, компенсировав неизбежный уход фаз
передатчика и приемника. Короткие посылки и относительно низкая частота
передачи позволяют надеяться, что неизбежное рассогласование частот пере-
датчика и приемника не приведет к ошибкам при передаче посылки.
6.3.3. Прерывания
Подсистема прерываний — совокупность аппаратных и программных средств,
обеспечивающих реакцию программы на события, происходящие вне про-
граммы. Такие события возникают, как правило, случайно и асинхронно по
отношению к программе и требуют прекращения (чаще временного) выпол-
нения текущей программы и переход на выполнение другой программы
(подпрограммы), соответствующей возникшему событию.
Различают внутренние и внешние (по отношению к процессору) события,
требующие реакции подсистемы прерываний. К внутренним событиям отно-
сятся переполнение разрядной сетки при выполнении арифметических опе-
раций, попытка деления на 0, извлечение корня четной степени из отрица-
тельного числа, появление несуществующего кода команды, обращение
программы в область памяти, для нее не предназначенную, сбой при выпол-
нении передачи данных или операции в АЛУ и многое другое. Внутренние
прерывания должны обеспечиваться развитой системой аппаратного контро-
Глава 6. Базовая архитектура микропроцессорной системы 159
ля процессора, поэтому они не получили широкого распространения в про-
стых 8- и 16-разрядных МП.
Внешние прерывания могут возникать во внешней по отношению к процес-
сору среде и отмечать как аварийные ситуации (кончилась бумага на принте-
ре, температура в реакторе превысила допустимый уровень, исполнительный
орган робота дошел до предельного положения и т. п.), так и нормальные ра-
бочие события, которые происходят в случайные моменты времени (нажата
клавиша, исчерпан буфер принтера или ВЗУ и т. п.). Во всех этих случаях
требуется прервать выполнение текущей программы и перейти на выполне-
ние другой программы (подпрограммы), обслуживающей данное событие.
С точки зрения реализации внутренние и внешние прерывания функцио-
нируют одинаковым образом, хотя при работе подсистемы с внешними
прерываниями возникают дополнительные проблемы идентификации ис-
точника прерывания. Поэтому далее остановимся на рассмотрении внеш-
них прерываний.
Анализ состояния внешней среды можно осуществлять путем программного
сканирования — считывания через определенные промежутки времени слов
состояния всех возможных источников прерываний, выделения признаков
отслеживаемых событий и переход (при необходимости) на прерывающую
подпрограмму (часто ее называют обработчиком прерывания).
Однако такой способ не обеспечивает для большинства применений прием-
лемого времени реакции системы на события, особенно при необходимости
отслеживания большого числа событий. К тому же при коротком цикле ска-
нирования большой процент процессорного времени тратится на проверку
(чаще безрезультатную) состояния внешней среды.
Гораздо эффективней организовать взаимодействие с внешней средой таким
образом, чтобы всякое изменение состояния среды, требующее реакции
МПС, вызывало появление на специальном входе МП сигнала прерывания
текущей программы. Организация прерываний должна быть обеспечена оп-
ределенными аппаратными и программными средствами, которые мы и на-
зываем подсистемой прерываний.
Подсистема прерываний должна обеспечивать выполнение следующих
функций:
􀂈 обнаружение изменения состояния внешней среды (запрос на прерыва-
ние);
􀂈 идентификация источника прерывания;
􀂈 разрешение конфликтной ситуации в случае одновременного возникнове-
ния нескольких запросов (приоритет запросов);
160 Часть II. Архитектура микропроцессорных систем
􀂈 определение возможности прерывания текущей программы (приоритет
программ);
􀂈 фиксация состояния прерываемой (текущей) программы;
􀂈 переход к программе, соответствующей обслуживаемому прерыванию;
􀂈 возврат к прерванной программе после окончания работы прерывающей
программы.
Рассмотрим варианты реализации в МПС перечисленных выше функций.
Обнаружение изменения состояния внешней среды
Фиксация изменения состояния внешней среды может осуществляться раз-
личными схемами: двоичными датчиками, компараторами, схемами формиро-
вания состояний и др. Будем полагать, что все эти схемы формируют в ко-
нечном итоге логические сигналы запроса на прерывание z , причем для
определенности будем считать, что активное состояние этого сигнала переда-
ется уровнем логической единицы (Н-уровень).
Количество источников запросов в МПС может быть различно, в т. ч.
и довольно велико. Дефицит внешних выводов МП в общем случае исклю-
чает возможность передачи каждого запроса от ВУ по "собственной" линии
интерфейса. Обычно на одну линию запроса подключается несколько ис-
точников прерываний (по функции ИЛИ), а иногда и все источники запро-
сов — на единственный вход.
Управляющий автомат процессора должен периодически анализировать со-
стояние линии (линий) запросов на прерывания. Каким образом выбирается
период проверки? С одной стороны, этот период должен быть коротким, что-
бы обеспечить быструю реакцию системы на события. С другой стороны,
при переходе на обслуживание прерывания требуется сохранить текущее со-
стояние процессора на момент прерывания, с тем, чтобы, завершив програм-
му-обработчик, продолжить выполнение прерванной программы "с того же
места", на котором произошло прерывание.
Напомним, что в основе работы процессора лежит командный цикл
(см. разд. 2.1), состоящий, в свою очередь, из машинных циклов, каждый из
которых длится несколько тактов. Осуществлять прерывание в произволь-
ном такте невозможно, т. к. при этом пришлось бы сохранять в качестве кон-
текста прерванной программы состояние всех элементов памяти процессора.
Прерывание по завершении текущего машинного цикла требует сохранение
текущего состояния незавершенной команды. Например, при возникновении
прерывания в том месте командного цикла, когда из памяти выбраны код
команды и первый операнд, а для второго операнда только сформирован ис-
полнительный адрес, следует сохранить: содержимое программного счетчика
Глава 6. Базовая архитектура микропроцессорной системы 161
PC, код команды, первый операнд и адрес второго операнда. Сохранение
этой информации требует как дополнительных аппаратных, так и временных
затрат. Очевидно, при возврате к прерванной программе проще начать вы-
полнение текущей команды заново. В этом случае сохранять при прерывании
достаточно лишь значение PC. Поэтому в большинстве случаев процессоры
анализируют состояние линий запросов в конце каждого командного цикла.
Идентификация источника прерывания
Различают два типа входов запросов на прерывания — радиальные и вектор-
ные. Получив запрос на прерывание, процессор должен идентифицировать
его источник, т. е. в конечном счете определить начальный адрес обслужи-
вающей это прерывание программы. Способ идентификации зависит от типа
входа, на который поступил запрос.
Каждый радиальный вход связан с определенным адресом памяти, по кото-
рому размещается указатель на обслуживающую программу или сама про-
грамма. Если радиальный вход связан с несколькими источниками запросов,
то необходимо осуществить программную идентификацию путем последова-
тельного (в порядке убывания приоритетов) опроса всех связанных с этим
входом источников прерывания. Этот способ не требует дополнительных ап-
паратных затрат и одновременно решает проблему приоритета запросов, од-
нако время реакции системы на запрос может оказаться недопустимо боль-
шим, особенно при большом числе источников прерываний.
Гораздо чаще в современных МПС используется так называемая векторная
подсистема прерываний. В такой системе микропроцессор, получив запрос
на векторном входе INT, выдает на свою выходную линию сигнал подтвер-
ждения прерывания INTA, поступающий на все возможные источники пре-
рывания. Источник, не выставивший запроса, никак не реагирует на сигнал
INTA. Источник, выставивший запрос, получая сигнал INTA, выдает на сис-
темную шину данных "вектор прерывания" — свой номер или адрес обслу-
живающей программы или, чаще, адрес памяти, по которому расположен
указатель на обслуживающую программу. Время реакции МПС на запрос
векторного прерывания минимально (1—3 машинных цикла) и не зависит от
числа источников.
Приоритет запросов
Для исключения конфликтов при одновременном возникновении нескольких
запросов на векторном входе ответный сигнал INTA подается на источники
запросов не параллельно, а последовательно — в порядке убывания приори-
тетов запросов. Источник, не выставлявший запроса, транслирует сигнал
INTA со своего входа на выход, а источник, выставивший запрос, блокирует
162 Часть II. Архитектура микропроцессорных систем
дальнейшее распространение сигнала INTA. Таким образом, только один ис-
точник, выставивший запрос, получит от процессора сигнал INTA и выдаст
по нему свой вектор на шину данных.
Более гибко решается проблема организации приоритетов запросов при ис-
пользовании в МПС специальных контроллеров прерываний.
Конфликты на радиальном входе исключаются самим порядком программно-
го опроса источников.
Приоритет программ
Прерывание в общем случае может возникать не только при решении "фоно-
вой" задачи, но и в момент работы другой прерывающей программы, причем
не всякую прерывающую программу допустимо прерывать любым запросом.
В фоновой задаче также могут встречаться участки, при работе которых пре-
рывания (все или некоторые) недопустимы. В общем случае в каждый мо-
мент времени работы процессора должно быть выделено подмножество за-
просов, которым разрешено прерывать текущую программу.
В МПС эта задача решается на нескольких уровнях. В процессоре обычно
предусматривается программно-доступный флаг разрешения/запрещения
прерывания, значение которого определяет возможность или невозможность
всех прерываний. Для создания более гибкой системы приоритетов программ
на каждом источнике прерываний может быть предусмотрен специальный
программно-доступный триггер разрешения формирования запроса. В таком
случае возможно формирование произвольного подмножества разрешенных
в данный момент источников прерываний.
При использовании контроллера внешних прерываний, в нем обычно преду-
сматривают специальный программно-доступный регистр, разряды которого
маскируют соответствующие линии запросов на прерывание, запрещая кон-
троллеру вырабатывать сигнал прерывания процессору, если запросы от ВУ
поступают по замаскированным линиям. Однако замаскированные запросы
сохраняются в контроллере и в дальнейшем, при изменении состояния реги-
стра маски, могут быть переданы на обслуживание.
Обработка прерывания
К обработке прерывания отнесем фиксацию состояния прерываемой про-
граммы, переход к программе, соответствующей обслуживаемому прерыва-
нию, и возврат к прерванной программе после окончания работы прерываю-
щей программы.
Ранее мы определили, что большинство процессоров может прервать выпол-
нение текущей программы и переключиться на реализацию обработчика пре-
Глава 6. Базовая архитектура микропроцессорной системы 163
рывания только после завершения очередной команды. При этом в качестве
контекста прерванной программы необходимо сохранить текущее состояние
счетчика команд PC, а в PC загрузить новое значение — адрес программы-
обработчика прерывания. Очевидно, адрес возврата в прерванную программу
(содержимое PC на момент прерывания) следует размещать в стеке, что по-
зволит при необходимости осуществлять вложенные прерывания (когда
в процессе обслуживания одного прерывания получен запрос на обслужива-
ние другого).
Можно вспомнить, что подобный механизм реализован в системах команд
многих процессоров для выполнения команд вызовов подпрограммы (CALL,
JSR). В этих командах адрес вызываемой подпрограммы содержится в коде
команды.
В случае вызова обработчика прерывания его адрес необходимо связать либо
со входом, на который поступил запрос (радиальные прерывания), либо с
номером источника прерываний, сформировавшего запрос (векторные пре-
рывания). В первом случае не требуется никаких внешних процедур для
идентификации источника, сразу можно запускать связанный со входом об-
работчик. Понятно, здесь идет речь об отсутствии необходимости в аппарат-
ных процедурах идентификации источника запроса. Если на радиальный
вход "работают" несколько источников, то выбор осуществляется программ-
ными способами.
В случае векторных прерываний адрес перехода связывают с информацией,
поступающей от источника запроса по шине данных в машинном цикле об-
служивания прерывания — вектором прерывания.
Напомним, что любой командный цикл процессора начинается с чтения
команды из памяти. В первом машинном цикле командного цикла процессор
выдает на шину адреса содержимое PC, формирует управляющий сигнал
RDM и помещенное памятью на шину данных слово интерпретирует как
команду (или ее начальную часть, если длина команды превышает длину
машинного слова).
Если в конце очередного командного цикла процессор обнаруживает (не-
замаскированный) запрос на векторном входе, он начинает следующий
командный цикл с небольшими изменениями: содержимое PC по-прежнему
выдается на шину адреса (чтобы не нарушать общности цикла), но вместо
сигнала RDM формирует сигнал INTA. Источник запроса (чаще — контрол-
лер прерываний) в ответ на сигнал INTA формирует на шину данных код ко-
манды вызова подпрограммы, в адресной части которой размещается адрес
обработчика соответствующего прерывания.
164 Часть II. Архитектура микропроцессорных систем
Такой простой способ реализации векторных прерываний, с использованием
уже существующего механизма вызова подпрограмм, был реализован, на-
пример, в микропроцессоре i8080 с контроллером прерываний i8259. Однако
этот механизм, как, впрочем, и все остальное, допускает дальнейшее совер-
шенствование.
Прежде всего, желание иметь возможность располагать подпрограммы
в произвольной области памяти приводит к необходимости размещать в поле
адреса команды вызова полноразрядный адрес (16 — 20 — 32 бита). В этом
случае длина команды превышает длину машинного слова и ее ввод требует
нескольких машинных циклов (например, в i8080 — трех), что увеличивает
время реакции системы на запрос прерывания.
Для преодоления этого недостатка в систему команд процессора включают до-
полнительно "укороченные" команды вызова длиной в одно машинное слово.
Эти команды в процессорах 8080 и х86 имеют мнемокод INT. В микропроцес-
соре i8080 имеется 8 таких команд длиной в 1 байт, адресующих подпрограм-
мы по фиксированным адресам памяти: 0000h, 0008h, 0010h, ..., 0038h.
В процессорах х86 имеется 256 вариантов двухбайтовых команд INT 00h, ...,
INT FFh, байт поля адреса которых (называемый вектором) после умножения
на 4 указывает на четырехбайтовую структуру, определяющую произволь-
ный адрес в адресном пространстве памяти.
Напомним, что доступ в память процессоров х86 (в реальном режиме) осу-
ществляется только в рамках сегментов размером в 64 Кбайт. Положение на-
чала сегмента в адресном пространстве памяти определяется содержимым
16-разрядного сегментного регистра, а положение адресуемого байта внутри
сегмента — 16-разрядным смещением. Среди команд передачи управления
различают короткие и длинные переходы (вызовы). При коротком вызове
подпрограмма должна располагаться в текущем сегменте кода, и ее вызов
сопровождается только изменением счетчика команд (в х86 он обозначается,
как IP). При длинном вызове новое значение загружается как в IP, так и в
сегментный регистр кода CS. Таким образом, для осуществления длинного
вызова (перехода) в адресном поле команды необходимо разместить 4 байта.
Механизм векторных прерываний в процессорах х86 в реальном режиме реа-
лизован следующим образом. В начальных адресах 00000h, ..., 003FFh про-
странства памяти размещается таблица векторов прерываний объемом
1 Кбайт, включающая 256 строк таблицы — четырехбайтовых структур
CS:IP, которые определяют адреса соответствующих обработчиков прерыва-
ний. В цикле обработки векторного прерывания (запрос по входу INT), про-
цессор получает от источника байт — номер строки таблицы векторов пре-
рываний, из которой и загружаются новые значения CS и IP. Старые
значения CS:IP (адрес возврата) размещаются в стеке.
Глава 6. Базовая архитектура микропроцессорной системы 165
Запросу по радиальному входу NMI соответствует вектор 2, поэтому появле-
ние активного значения не вызывает машинного цикла обслуживания преры-
вания, а сразу вызывается обработчик по адресу из ячеек памяти 00008h, ...,
0000Bh. Кстати, любой обработчик прерывания (независимо от значения
маскирующих флагов) можно вызвать программно с помощью команды INT
nn, где nn — номер строки таблицы векторов прерываний.
Таким образом, команда INT отличается от команды CALL, во-первых, спосо-
бом адресации вызываемой подпрограммы (прямой адрес — в команде CALL,
косвенный — в INT), во-вторых, при реализации INT в стек, помимо CS и IP,
помещается содержимое регистра признаков процессора — FLAGS. Соответ-
ственно, завершаться подпрограмма, вызываемая командой INT, должна ко-
мандой IRET ("возврат из прерывания"). Действие IRET отличается от дейст-
вия RET извлечением из стека дополнительного слова в регистр FLAGS.
6.3.4. Прямой доступ в память
В процессе работы МПС с интерфейсом типа "общая шина" часто возникает
необходимость передачи достаточно больших массивов данных между па-
мятью и ВУ (например, копирование сектора диска, загрузка видеопамяти
и т. п.). При наличии в системе единственного активного устройства — про-
цессора возможен единственный путь решения этой задачи — программно-
управляемый обмен "Память → Процессор → ВУ" (или "ВУ → Процессор →
Память").
Рассмотрим вариант программно-управляемого обмена между памятью
и внешним устройством в МПС на базе МП i8080 [14]. Пусть необходимо
передать массив данных длиной L , начиная с адреса ADR на ВУ с адресом
AIO. Положим, что начальный адрес массива загружен в регистровую пару
HL, а длина массива — в регистр С. Тогда фрагмент программы обмена мо-
жет иметь вид, представленный в табл. 6.2.
Таблица 6.2. Фрагмент программы обмена
Мнемокод Комментарий Количество МЦ
LM: MOV А,М Чтение байта в Акк 2
OUT AIO Выдача байта на ВУ 3
INX H Модификация адреса 1
DCRC Модификация счетчика 1
JNZ LM Переход, если массив не исчерпан 3
Всего машинных циклов: 10
166 Часть II. Архитектура микропроцессорных систем
Таким образом, для того чтобы в рамках процедуры копирования массива
данных переслать из памяти в ВУ один байт данных, потребуется десять ма-
шинных циклов. Процессоры с более совершенной системой команд (напри-
мер, х86) могут использовать для этой цели меньшее число МЦ, но все равно
их будет более одного.
Управляя обменом, микропроцессор "ведет" два счетчика — адресов массива
и количества переданных байтов и формирует на магистраль сигналы управ-
ления. Если снабдить ВУ аппаратными счетчиками и схемой формирования
управляющих сигналов (так называемый "канал прямого доступа в па-
мять" — ПДП), то передачу одного байта (слова) можно осуществить за один
МЦ без участия процессора. Необходимо лишь на время передачи данных
под управлением канала ПДП блокировать работу процессора, отключив его
от системной шины. Для этого служит вход захвата шины HLD. Если подать
на него активный уровень, то МП по окончании текущего МЦ, безусловно,
перейдет в режим ожидания, переведя все свои выходные линии, кроме
HLDA, в высокоимпедансное состояние, а выход HLDA — в состояние логи-
ческой 1. Выходной сигнал HLDA используется для отключения процессор-
ного модуля от системной шины — перевода шинных формирователей,
включенных между локальной и системной шиной, в высокоимпедансное
состояние.
Если в МПС используется несколько ВУ, снабженных каналом ПДП, то це-
лесообразно использовать специальный контроллер ПДП, который обеспечи-
вает программирование каналов ПДП, подключение их к системной шине
и дисциплину обслуживания.
Глава 7
Эволюция архитектур
микропроцессоров и микроЭВМ
В главе 6 была рассмотрена архитектура 16-разрядного микропроцессо-
ра i8086 и систем на его основе. Эту архитектуру мы (условно) будем считать
базовой. Уже в ней по сравнению с первыми 8-разрядными системами (на
базе i8080) реализован ряд новых архитектурных решений:
􀂈 расширена система команд (по набору операций и способам адресации);
􀂈 архитектура микропроцессора ориентирована на мультипроцессорную
работу. Разработана группа вспомогательных БИС (контроллеров и спе-
циализированных процессоров) для организации мультимикропроцессор-
ных систем различной конфигурации;
􀂈 начато движение в сторону совмещения во времени выполнения различ-
ных операций. Микропроцессор включает два параллельно работающих
устройства: обработки данных и связи с магистралью, что позволяет со-
вместить во времени процессы обработки информации и передачи ее по
магистрали;
􀂈 введена новая (по сравнению с i8080) организация памяти, которая далее
использовалась во всех старших моделях семейства Intel — сегментация
памяти.
Можно сказать, что основная цель совершенствования микропроцессоров —
это увеличение их производительности. Достигается эта цель различными
путями: повышением тактовой частоты работы кристалла, совершенствова-
нием операционных устройств (например, применение параллельного умно-
жителя), организацией параллельной во времени работы нескольких уст-
ройств, совершенствованием системы команд (с ориентацией под конкретный
класс задач), эффективной организацией иерархии памяти, опережающим
выполнением ряда процедур командных циклов, организацией мультизадач-
ных и мультипроцессорных систем и другими способами.
168 Часть II. Архитектура микропроцессорных систем
На примере микропроцессоров Intel линии 8080 → 8086 → 80286 → 80386 →
80486 → Pentium → ... → Pentium 4 (это семейство принято обозначать как
х86) можно проследить реализацию многих из перечисленных выше путей.
Рассмотрим некоторые из них, не придерживаясь хронологической последо-
вательности нововведений. Более подробные сведения о рассматриваемых
в этой главе вопросах можно найти в [3, 11, 13, 15].
7.1. Защищенный режим
и организация памяти
Первый шаг для увеличения производительности систем на базе процессоров
х86 был сделан в направлении мультипроцессорной конфигурации. В 8086
предусмотрены два режима работы — минимальный и максимальный (см.
разд. 6.1.1), причем последний ориентирован на организацию мультипроцес-
сорных систем. Часть выводов микропроцессора в максимальном режиме
вместо сигналов управления шиной передает коды внутренних состояний
управляющего автомата; кроме того, в составе серии выпускались специали-
зированные модули, которые обеспечивали доступ микропроцессора к сис-
темной шине — арбитраж шины.
Однако широкого распространения подобная архитектура не получила, по-
скольку при отсутствии на кристалле микропроцессора достаточно "вмести-
тельной" внутренней памяти процессоры постоянно ожидают в очереди на
доступ к шине. Характерно, что в последующих моделях семейства — 80286,
80386, 80486 поддерживалась только однопроцессорная конфигурация,
и лишь в Pentium вновь вернулись к возможности организации многопроцес-
сорных систем.
7.1.1. Сегментная организация памяти
Как вы, очевидно, помните, в микропроцессоре 8086 в рамках адресного про-
странства объемом 1 Мбайт одновременно было доступно четыре сегмента
по 64 Кбайт каждый.
В следующих моделях микропроцессоров семейства х861 в рамках так назы-
ваемого защищенного режима (protect mode, P-режим) организовано линей-
ное адресное пространство объемом 232 байтов, в котором допускается соз-
дание практически любого числа сегментов.
1 В рамках этой главы будем понимать под обозначением х86 микропроцессоры i80386
и старше.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 169
Если в 8086 единственным атрибутом сегмента был его начальный адрес, то
в P-режиме старших моделей семейства х86 для описания многочисленных
атрибутов предусмотрена специальная структура — дескриптор.
Дескриптор — это 8-байтовый блок, содержащий атрибуты области линей-
ных адресов — сегмента. Дескриптор включает в себя информацию о поло-
жении сегмента в линейном адресном пространстве, размере сегмента, типе
информации, хранящемся в сегменте и правах доступа к ней, а также другие
атрибуты сегмента. Формат дескриптора представлен на рис. 7.1.
Рис. 7.1. Формат дескриптора
Назначение полей дескриптора:
􀂈 базовый адрес2 [31:0] определяет место сегмента (начальный адрес) внут-
ри 4-гигабайтного адресного пространства;
􀂈 предел [19:0] определяет размер сегмента с учетом бита гранулярности
(см. далее).
Поле атрибутов включает следующие признаки:
􀂈 G — бит гранулярности. При значении G = 0 размер сегмента задается
в байтах, а при G = 1 — в страницах по 4 Кбайт. В первом случае макси-
мальный размер сегмента может достигать 1 Мбайт, во втором — 4 Гбайт;
2 Из рис. 7.1 видно, что дескриптор содержит ряд полей, имеющих название и размер.
Например, 32-разрядный адрес "базовый адрес [31:0]"; но в формате данного деск-
риптора он расположен в разрядах [63:56] и [39:16]. То же относится и к полю "пре-
дел". Это связано с желанием фирмы Intel сохранить преемственность форматов
младших моделей.
170 Часть II. Архитектура микропроцессорных систем
􀂈 D — бит размера по умолчанию (от англ. defaults size) обеспечивает со-
вместимость с процессором 80286. При D = 0 находящиеся в сегменте
операнды считаются имеющими размер 16 битов, иначе — 32 бита;
􀂈 X — зарезервирован Intel и не должен использоваться программистом
(содержит 0);
􀂈 U — бит пользователя (от англ. user) предназначен для использования
системным программистом. Процессор игнорирует этот бит.
Байт права доступа (AR) имеет несколько отличающуюся структуру для де-
скрипторов сегментов разных типов, но некоторые поля этого байта являются
общими для всех дескрипторов:
􀂈 Р — бит присутствия (от англ. present) сегмента, если Р = 0, то дескриптор
не может использоваться, т. к. сегмент отсутствует в ОЗУ. При обращении
к сегменту, дескриптор которого имеет Р = 0, формируется соответствую-
щее прерывание;
􀂈 DRL — уровень привилегий дескриптора (от англ. descriptor privilege
level) определяет уровень привилегий, ассоциируемый с той областью па-
мяти, которую описывает дескриптор;
􀂈 S — определяет роль дескриптора в системе: при S = 0 — системный де-
скриптор, служит для обращения к таблицам LDT или шлюзам для входа
в другие задачи, включая программы обслуживания прерываний. При
S = 1 дескриптор обеспечивает обращение к сегментам программ или дан-
ных, включая стек;
􀂈 А — бит обращения, устанавливается, когда проходит обращение к сег-
менту. Операционная система может следить за частотой обращения
к сегменту путем периодического анализа и очистки А.
Трехбитное поле тип сегмента определяет целевое использование сегмента,
задавая допустимые в сегменте операции. Значение этого поля для систем-
ных дескрипторов (S = 0) безразлично. Для несистемных сегментов биты по-
ля тип сегмента имеют следующие значения:
􀂈 бит 3 различает сегменты кода (1) и данных (0);
􀂈 для сегмента кода бит 2 (Conforming) отмечает при С = 1 так называемые
"подчиненные сегменты" (см. далее), а бит 1 (Read) при R = 1 допускает
чтение кода как данных с помощью префикса замены сегмента;
􀂈 для сегмента данных бит 2 (Expand Down) определяет так называемое
"расширение вниз" — для сегментов стека ED = 1, а для сегментов собст-
венно данных ED = 0;
􀂈 бит 1 (Write) показывает возможность записи в сегмент при W = 1.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 171
Дескрипторы хранятся в памяти и группируются в дескрипторные таблицы:
􀂈 GDT — глобальная дескрипторная таблица;
􀂈 IDT — дескрипторная таблица прерываний;
􀂈 LDT — локальная дескрипторная таблица.
Причем если GDT и IDT — общесистемные, присутствуют в системе в един-
ственном экземпляре и являются общими для всех задач, то LDT может соз-
даваться для каждой задачи.
Максимальный размер дескрипторной таблицы может составлять
213 = 8192 дескриптора ( 213 ×8 = 65 536 байтов).
Дескрипторная таблица локализуется в памяти с помощью соответствующего
регистра. 48-битовые регистры GDTR и IDTR содержат 32-битовое поле ба-
зового адреса таблицы и 16-битный предел (размер) таблицы с байтовой гра-
нулярностью.
Для локализации LDT используется 16-разрядный регистр LDTR, содержа-
щий только селектор сегмента, в котором размещена таблица. Таблицы LDT
хранятся как сегменты, а дескрипторы этих сегментов размещаются в GDT.
Селектор регистра LDTR выбирает из GDT нужный дескриптор, и атрибуты
LDT становятся доступны процессору. С LDTR, как и с сегментными регист-
рами, ассоциируется соответствующий "теневой регистр", в который помеща-
ется выбранный из GDT дескриптор LDT текущей задачи. При переключении
задачи достаточно заменить 16-разрядное содержимое LDTR, а процессор
автоматически загрузит теневой регистр.
Доступ к памяти в любом режиме х86 возможен лишь в область, определен-
ную как сегмент. Количество доступных в данный момент сегментов опреде-
ляется числом сегментных регистров (CS, SS, DS, ES, FS, GS). Однако
в защищенном режиме содержимое сегментного регистра не является базой
сегмента, а рассматривается как селектор сегмента и имеет формат, приве-
денный на рис. 7.2.
Индекс определяет смещение внутри дескрипторной таблицы, которая соот-
ветственно разрядности индекса может содержать 213 8-байтовых дескрип-
торов. Бит TI определяет тип дескрипторной таблицы: 0 — глобальная, 1 —
локальная. Поле RPL определяет запрашиваемый уровень привилегий.
Рис. 7.2. Формат селектора
172 Часть II. Архитектура микропроцессорных систем
Итак, селектор адресует дескриптор сегмента в одной из дескрипторных таб-
лиц. Всякий раз, когда производится перезагрузка сегментного регистра (за-
мена селектора), адресуемый им дескриптор извлекается из соответствующей
дескрипторной таблицы и помещается в "теневой регистр" дескриптора. Все
последующие обращения к этому сегменту не требуют чтения из дескрип-
торной таблицы.
Логический адрес в защищенном режиме, как и в реальном, описывается па-
рой RS:EA, где RS — содержимое выбранного сегментного регистра, ЕА —
эффективный адрес, генерируемый программой (смещение в сегменте).
Рис. 7.3. Преобразование логического адреса в линейный
Процесс загрузки дескрипторных регистров и преобразования эффективного
(логического) адреса в линейный протекает следующим образом (рис. 7.3):
1. При переходе в защищенный режим в памяти создается глобальная деск-
рипторная таблица, базовый адрес которой размещается в регистре GDTR.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 173
2. Несколько сегментов определяется в памяти, и их дескрипторы помеща-
ются в GDT.
3. При запуске очередной задачи можно определить дополнительно несколь-
ко сегментов и для хранения их дескрипторов создать локальную деск-
рипторную таблицу, как системный сегмент, дескриптор которого хранит-
ся в GDT, а его положение в GDT определяется селектором в регистре
LDTR. В теневой регистр LDTR автоматически помещается дескриптор
сегмента LDT.
4. При загрузке в любой сегментный регистр нового содержимого в соответ-
ствующий теневой регистр автоматически помещается новый дескриптор
из GDTR или LDTR.
5. При генерации программой очередного адреса ЕА из соответствующего
теневого сегментного регистра выбирается базовый адрес сегмента и
складывается со значением ЕА. Полученная сумма представляет собой
линейный адрес.
В приведенной выше процедуре не отражены особые случаи, которые могут
возникать при различных нарушениях (ошибках) в процессе формирования
линейного адреса.
Механизм сегментации можно искусственно подавить, назначив все базовые
адреса сегментов равными нулю и определив длину всех сегментов в 4 Гбайт.
Таким образом, в адресном пространстве определится единственный сегмент
размером 232 байта.
Сегмент в защищенном режиме — область памяти, снабженная рядом атри-
бутов: типом, размером, положением в памяти, уровнем привилегий и др.
Сегмент может начинаться и кончаться где угодно, и его размер — произ-
вольный. Другой элемент памяти — страница — имеет строго фиксирован-
ный размер (4 Кбайт) и положение в линейном адресном пространстве: стра-
ница всегда выровнена по границе 4-килобайтовых фрагментов, т. е.
12 младших разрядов адреса страницы — всегда нули.
7.1.2. Страничная организация памяти
Наряду с сегментной организацией в микропроцессорах х86 возможна до-
полнительно страничная организация памяти. Механизм страничной орга-
низации памяти может включаться (выключаться) программно путем уста-
новки (сброса) флага PG регистра CR0.
Все линейное адресное пространство делится на разделы, число которых
может достигать 1024. Каждый раздел, в свою очередь, может содержать
174 Часть II. Архитектура микропроцессорных систем
до 1024 страниц (рис. 7.4), размер которых фиксирован — 4 Кбайт, причем
начальные адреса страниц жестко фиксированы в физическом адресном про-
странстве: границы страниц совпадают с границами 4-килобайтовых блоков.
32-разрядный логический адрес, полученный на предыдущем этапе преобра-
зования адреса, рассматривается состоящим из трех полей:
􀂈 [31:22] — номер раздела (TABLE);
􀂈 [21:12] — номер страницы в разделе (PAGE);
􀂈 [11:0] — номер слова на странице (смещение).
Рис. 7.4. Разделы в линейном адресном пространстве
Начальные адреса страниц данного раздела (вместе с атрибутами страницы)
хранятся в памяти в страничной таблице, размер которой 1024 стр. × 4 бай-
та = 4096 байтов.
Поскольку в задаче может быть несколько разделов и, следовательно, столь-
ко же страничных таблиц, то начальные адреса всех страничных таблиц од-
ного сегмента хранятся в специальной таблице — каталоге раздела.
Линейный 32-разрядный адрес является исходной информацией для форми-
рования 32-разрядного физического адреса (рис. 7.5) с помощью каталога
раздела и страничной таблицы (СТ). Старшие 10 разрядов линейного адреса
определяют номер строки каталога разделов, который локализуется содер-
жимым системного регистра CR3.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 175
Рис. 7.5. Преобразование линейного адреса в физический
Поскольку каталог разделов имеет размер 1 Кбайт × 4 байта, он занимает
точно одну страницу (CR3[11:0] = 0) и содержит 4-байтовые поля, формат
которых показан на рис. 7.6. Помимо базового адреса страничной таблицы,
это поле хранит атрибуты страницы. Извлеченный из каталога базовый адрес
страничной таблицы складывается (конкатенируется) с разрядами [21:12] ли-
нейного адреса для получения адреса строки страничной таблицы, из кото-
рой, в свою очередь, извлекается базовый адрес страницы. Конкатенацией
базового адреса страницы с разрядами [11:0] линейного адреса получается
физический адрес.
Такая двухуровневая организация страничной таблицы позволяет значитель-
но экономить память для хранения страничных таблиц. Действительно, если
рассматривать разряды [31:20] линейного адреса как номер строки странич-
ной таблицы, то ее (таблицы) размер должен составлять 220 × 4 байтов, т. е.
4 Мбайт. Абсолютное большинство задач никогда не использует такого
количества страниц, однако во избежание возникновения особого случая
(внутреннего прерывания) необходимо поддерживать всю такую таблицу це-
ликом.
При двухуровневой организации страничного преобразования (см. рис. 7.5)
в памяти достаточно хранить каталог разделов и страничные таблицы только
реально существующих разделов. Максимальное число разделов может дос-
тигать 1024, однако во многих случаях достаточно бывает двух-трех разде-
лов, а то и единственного.
Каждая четырехбайтовая строка каталога разделов и страничной таблицы
содержит, помимо 20-разрядного базового адреса, атрибуты страницы, опре-
176 Часть II. Архитектура микропроцессорных систем
деляющие ее назначение, положение в физической памяти, а также информа-
цию, позволяющую аппаратно поддерживать некоторые алгоритмы замеще-
ния страниц при страничных сбоях. Формат строки этих таблиц представлен
на рис. 7.6.
Атрибуты страницы (СТ) :
􀂈 Р — бит присутствия, при Р = 0 страница отсутствует в оперативной памя-
ти, попытка обращения к ней вызывает прерывание 14 — "страничный
сбой";
􀂈 R/W — чтение/запись, если работает программа с уровнем привилегий 3
(низший), то при R/W = 0 разрешается только чтение, но не запись на
страницу;
􀂈 U/S — пользователь/супервизор, при U/S = 0 блокируется запрос с уров-
нем привилегий 3; при запросе с уровнями привилегий 0, 1, 2 значения би-
тов R/W, U/S игнорируются;
􀂈 А — бит доступа, устанавливается процессором при любом обращении
к странице;
􀂈 D — признак записи на страницу.
Биты А и D используются операционной системой (ОС) для поддержки вир-
туальной памяти, проверку и сброс этих битов осуществляет ОС. Кроме того,
биты 9—11 могут использоваться ОС для своих целей, например, для хране-
ния времени последнего обращения на страницу.
Рис. 7.6. Формат строки каталога разделов и страничных таблиц
В х86 предусмотрена ассоциативная память страничных таблиц, которая
называется буфером ассоциативной трансляции — TLB.
TLB представляет собой 32 ячейки АЗУ 1-го рода, поле признаков которого
(теги) включает старшие 20 разрядов линейного адреса. Информационное
поле ячейки включает 20 старших битов физического адреса страницы и ряд
ее атрибутов. Биты D, U/S, R/W имеют тот же смысл, что в слове СТ, а бит
достоверности V сбрасывается при записи в CR3 нового слова (смена катало-
га). После преобразования очередного линейного адреса в физический бит V
в этой ячейке устанавливается.
Наличие TLB позволяет при кэш-попадании избежать обращения к ОЗУ при
преобразовании линейного адреса. При кэш-промахе микропроцессор вы-
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 177
полняет процедуру формирования физического адреса по каталогу раздела
и СТ. Полученный из СТ 20-разрядный базовый адрес вместе с 20-разрядным
тегом заносятся в свободную ячейку TLB или занимают ячейку, в которой
хранится адрес, введенный в TLB ранее других.
Так как TLB хранит адреса 32 страниц по 4 Кбайт, то непосредственно дос-
тупными становятся физические адреса 128 Кбайт памяти.
7.1.3. Защита памяти
В х86 предусмотрены два вида защиты памяти: на уровне сегментов и на
уровне страниц.
Защита памяти на уровне сегментов
В х86 определено понятие привилегии для сегмента и установлены 4 уровня
привилегий PL (рис. 7.7), которые задаются номерами от 0 (наиболее защи-
щенный) до 3 (низший).
В ядро входит часть ОС, обеспечивающая инициализацию работы, управле-
ние доступом к памяти, защиту и ряд других жизненно важных функций, на-
рушение которых полностью выводит из строя МПС. Основная часть ОС
должна иметь уровень 1. К уровню 2 обычно относят ряд служебных про-
грамм ОС, например, драйверы внешних устройств, системы управления ба-
зами данных, специализированные подсистемы программирования и др.
Ранее отмечалось, что основой организации памяти х86 является сегмент.
С каждым сегментом (данных, кода или стека) ассоциируется уровень при-
вилегий DPL и все, что находится внутри этого сегмента, имеет данный уро-
вень привилегий. DPL располагается в байте доступа дескриптора сегмента,
поэтому его называют уровнем привилегий дескриптора (Descriptor Privilege
Level), однако правильнее считать его уровнем привилегий сегмента.
Рис. 7.7. Кольца защиты сегментов
178 Часть II. Архитектура микропроцессорных систем
Уровень привилегий выполняющегося кода называется текущим уровнем
привилегий CPL (Current Privilege Level или Code Privilege Level) и он задает-
ся полем RPL селектора в сегментном регистре CS. Значение CPL можно
считать уровнем привилегий процессора в текущий момент времени, т. к. при
передаче управления сегменту кода с другим уровнем привилегий процессор
будет работать на новом уровне привилегий.
Каждый селектор выбирает точно один дескриптор и, соответственно, один
сегмент, но конкретный сегмент могут идентифицировать несколько селек-
торов ("альтернативное именование"). Младшие два бита селектора содер-
жат поле запрашиваемого уровня привилегий RPL (Requested Privilege
Level). Это поле не влияет на выбор дескриптора, но учитывается при кон-
троле привилегий.
Таким образом, текущее состояние системы защиты характеризуется сле-
дующими признаками:
􀂈 CPL — уровень привилегий выполняемого кода, размещается в поле RPL
сегментного регистра кода CS;
􀂈 DPL — уровни привилегий для каждого из восьми открытых сегментов,
располагаются в байте доступа дескрипторов, помещенных в "теневые ре-
гистры";
􀂈 RPL — определяют уровни привилегий источника селектора, размещают-
ся в полях RPL сегментных регистров.
Процессор постоянно контролирует, обладает ли текущая программа доста-
точным уровнем привилегий, чтобы:
􀂈 выполнять некоторые команды;
􀂈 обращаться к данным других программ;
􀂈 передавать управление внешнему (по отношению к программе) коду
командами передачи управления типа FAR.
В системе команд существуют специальные привилегированные команды,
которые могут выполняться процессором, работающим только на уровне
привилегий 0. При попытке выполнить их на другом уровне привилегий ге-
нерируется прерывание 13 — нарушение общей защиты.
К привилегированным относятся команды:
􀂈 останов процессора;
􀂈 сброс флага переключенной задачи;
􀂈 загрузка регистров дескрипторных таблиц;
􀂈 загрузка регистра задачи;
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 179
􀂈 загрузка слова состояния машины;
􀂈 модификация флага прерываний IF*;
􀂈 команды ввода/вывода*.
Последние две группы команд (отмеченные *) не обязательно выполняются
на нулевом уровне, достаточно, чтобы уровень привилегий программы был
выше уровня привилегий ввода/вывода, определяемого полем IOPL в регист-
ре EFLAGS.
Рис. 7.8. Правила доступа к сегментам
Защита доступа к данным
Данные из сегмента могут выбираться только программой, имеющей такой
же или более высокий, чем сегмент, уровень привилегий. Программам не
разрешается обращение к данным, которые имеют более высокий уровень
привилегий, чем выполняемая программа. Программы могут использовать
данные на своем и более низких уровнях привилегий. Ограничения на воз-
можность доступа к данным иллюстрирует рис. 7.8.
Контроль реализуется двумя способами. Во-первых, проверка привилегий
осуществляется при загрузке селектора в один из сегментных регистров дан-
ных — DS, ES, FS или GS. Если значение DPL того сегмента, который выби-
рает селектор, численно меньше CPL, процессор не загружает селектор
и формирует нарушение общей защиты. Во-вторых, после успешной загруз-
ки селектора при использовании его для фактического обращения к памяти
180 Часть II. Архитектура микропроцессорных систем
процессор контролирует, разрешена ли для этого сегмента запрашиваемая
операция (чтение или запись). Кроме того, при обращении контролируется
значение запрашиваемого уровня привилегий RPL, причем обращение раз-
решается, если DPL > max(RPL, CPL), иначе формируется прерывание 13.
Обращение к сегменту стека возможно, если RPL = DPL = CPL, причем сег-
мент стека должен иметь разрешение на запись — бит W в байте доступа
должен быть установлен.
Защита сегментов кода
Межсегментная передача управления происходит по командам JMP, CALL,
RET, INT, IRET. Для передачи управления существуют жесткие ограничения:
передавать управление в общем случае можно только в пределах своего
уровня привилегий, т. е. DPL целевого дескриптора должен быть точно равен
CPL (см. рис. 7.8).
Однако часто бывает необходимо обойти установленные ограничения (на-
пример, фрагменты операционной системы могут использоваться програм-
мами пользователя). В х86 предусмотрены два механизма передачи управле-
ния между уровнями привилегий: подчиненные сегменты и шлюзы вызова.
Если сегмент кода определен как подчиненный (установлен в 1 бит подчи-
ненности С в байте доступа дескриптора), то для него вводятся другие пра-
вила защиты. С подчиненными сегментами не ассоциируется конкретный
уровень привилегий, он устанавливается равным уровню привилегий вызы-
вающей программы. Поэтому код подчиненных сегментов не должен содер-
жать привилегированных команд.
Когда управление передается подчиненному сегменту, биты поля RPL реги-
стра CS не изменяются на значение поля DPL дескриптора нового сегмента
кода, а сохраняют прежнее значение. Только в этой единственной ситуации
биты поля RPL регистра CS не соответствуют битам поля DPL дескриптора
текущего выполняемого сегмента кода.
При использовании подчиненных сегментов сохраняется одно ограниче-
ние — значение DPL дескриптора подчиненного сегмента всегда должно
быть меньше или равно текущему значению CPL. Другими словами, переда-
ча управления подчиненному сегменту разрешается только во внутренние,
более защищенные сегменты. Если бы это ограничение нарушалось, то воз-
врат в вызывающую программу был бы вызовом неподчиненного более за-
щищенного сегмента, что никогда не разрешено.
Наличие подчиненных сегментов кода обеспечивает некоторую свободу пе-
редачи управления между уровнями привилегий. Для реализации фактиче-
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 181
ского изменения уровня привилегий привлекаются особые системные объек-
ты, называемые шлюзами вызова (рис. 7.9).
Рис. 7.9. Шлюз вызова
Хотя шлюзы вызова и располагаются в дескрипторной таблице, они, по су-
ществу, дескрипторами не являются, т. к. не определяют никакого сегмента.
Поэтому в дескрипторе шлюза отсутствует база и граница сегмента, а содер-
жится лишь селектор вызываемого сегмента программы и относительный
адрес шлюза — задается фактически адрес селектор : смещение точки входа
той процедуры (назначения), которой шлюз передает управление. Байт дос-
тупа имеет тот же смысл, что и в обычных дескрипторах, а пятибитовое поле
WC указывает количество параметров, переносимых из стека текущей про-
граммы в стек новой программы.
При этом если вызываемая программа имеет более высокий уровень приви-
легий, чем текущая, то для нее по команде CALL создается новый стек, пози-
ция которого определяется из сегмента состояния задачи TSS. В этот стек
последовательно записываются: старые значения SS и ESP, параметры, пере-
носимые из старого стека, старые CS и EIP. По команде RET происходит воз-
врат к старому стеку.
Дескриптор шлюза вызова действует как своеобразный интерфейс между
сегментами кода на разных уровнях привилегий. Шлюзы вызова идентифи-
цируют разрешенные точки входа в более привилегированные программы,
которым может быть передано управление.
Селектор, определяющий шлюз вызова, можно загружать только в сегментный
регистр CS для передачи управления сегменту кода на другом уровне привилегий.
Защита памяти на уровне страниц
В отличие от 80386, процессоры 80486 и Pentium имеют дополнительные по-
ля в элементе страничной таблицы [3]. Формат строки СТ i80486 представлен
на рис. 7.10, сравните его с форматом на рис. 7.6.
Рис. 7.10. Формат строки СТ процессора 80486
182 Часть II. Архитектура микропроцессорных систем
Кроме используемых в i80386 полей:
􀂈 Р — бит присутствия;
􀂈 R/W — чтение/запись;
􀂈 U/S — пользователь/супервизор;
􀂈 А — бит доступа;
􀂈 D — признак записи на страницу;
􀂈 резерв ОС
введены биты управления кэшированием:
􀂈 PCD — запрет кэширования страницы;
􀂈 PWT — сквозная запись.
На уровне страниц в 80486 предусмотрены две разновидности контроля:
􀂈 ограничение адресуемой области;
􀂈 контроль типа.
Ограничение адресуемой области. Для страниц и сегментов привилегии
интерпретируются по-разному: для сегментов — 4 уровня, для страниц —
только 2, определяемые битом U/S. При U/S = 0 страница имеет уровень су-
первизора, иначе — уровень пользователя. На уровне супервизора работают
обычно операционные системы, драйверы ВУ, а также располагаются защи-
щенные данные (например, страничные таблицы). Уровни привилегий сег-
ментов отображаются на уровень привилегий страниц: если значение CPL
равно 0, 1 или 2, то процессор работает на уровне супервизора, при
CPL = 3 — на уровне пользователя. На уровне супервизора доступны все
страницы, а на уровне пользователя — только страницы уровня пользователя.
Контроль типа. Механизм защиты распознает только два типа страниц:
с доступом только по считыванию (R/W = 0) и с доступом по считыва-
нию/записи (R/W = 1), причем в 80386 ограничение по записи действительно
только для уровня пользователя. Программа уровня супервизора игнорирует
значение бита R/W и может записывать на любые страницы. В отличие от
80386, процессор 80486 разрешает защитить от записи страницы уровня
пользователя в режиме супервизора: установка в регистре CR0 бита WR = 1
обеспечивает чувствительность режима супервизора к защищенным от запи-
си страницам режима пользователя.
Для любой страницы атрибуты защиты ее элемента каталога разделов могут
отличаться от атрибутов защиты ее элемента страничной таблицы. Процессор
контролирует атрибуты защиты в таблицах обоих уровней и принимает ре-
шение таким образом, что всякое разночтение в уровне привилегий раздела
и страницы всегда разрешается в сторону большей защиты (предоставления
меньших прав пользователю).
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 183
7.2. Мультизадачность
Под мультизадачностью понимают способность процессора выполнять не-
сколько задач "одновременно". Конечно, процессор традиционной архитек-
туры не может выполнять строго одновременно более одного потока команд,
однако он может некоторое время выполнять один поток команд, потом бы-
стро переключиться на выполнение другого потока команд, потом третьего,
потом — снова первого и т. д. Такая организация вычислительных процессов
при высоком быстродействии процессора создает иллюзию одновременности
(параллельности) выполнения нескольких задач.
Для реализации мультизадачности необходимо:
􀂈 располагать быстродействующим процессором;
􀂈 процессор должен аппаратно поддерживать механизм быстрого переклю-
чения задач;
􀂈 процессор должен аппаратно поддерживать механизм защиты памяти;
􀂈 использовать специальную мультипрограммную операционную систему.
Под задачей в мультизадачной системе понимается программа, которая вы-
полняется или ожидает выполнения, пока выполняется другая задача, причем
в определение задачи обычно включают ресурсы, требуемые для ее решения
(объем памяти, процессорное время, дисковое пространство и др.).
Рассмотрим, как реализуется механизм переключения задач в процессо-
рах х86.
7.2.1. Сегмент состояния задачи
Переключение задач в мультизадачной системе предполагает сохранение со-
стояния приостанавливаемой задачи на момент ее останова. Информация
о задаче, сохраняемая для последующего восстановления прерванного про-
цесса, называется ее контекстом. В системе выделяется область оператив-
ной памяти, доступная только ОС, в которой хранятся контексты задач. Для
минимизации времени переключения контекста следует сохранять и восста-
навливать минимальную информацию о каждой задаче.
В какой-то степени процесс переключения задачи напоминает вызов про-
цедуры. Отличие состоит в том, что при вызове процедуры информация
о точке возврата (автоматически) и содержимое некоторых РОН (программ-
но) помещается в стек, что определяет свойство реентерабельности процедур
(возможность вызова самой себя). Задачи не являются реентерабельными,
184 Часть II. Архитектура микропроцессорных систем
т. к. контексты сохраняются не в стеке, а в фиксированной (для каждой задачи)
области памяти в специальной структуре данных, называемой сегментом
состояния задачи (Task State Segment, TSS), причем каждой задаче соответ-
ствует один TSS.
Сегмент TSS определяется дескриптором, который может находиться только
в GDT. Формат дескриптора TSS похож на дескриптор сегмента кода и со-
держит обычные для дескриптора сегмента поля: базового адреса, предела,
DPL, биты гранулярности (G = 0) и присутствия Р, бит S = 0 — признака сис-
темного сегмента. В поле типа бит занятости В показывает, занята задача или
нет. Занятая задача выполняется сейчас или ожидает выполнения. Процессор
использует бит занятости для обнаружения попытки вызова задачи, выпол-
нение которой прервано. Поле предела должно содержать значение, не
меньшее 67h, что на один байт меньше минимального размера TSS. Формат
32-разрядного TSS представлен на рис. 7.11.
Процедура, которая обращается к дескриптору TSS, может вызвать переклю-
чения задачи. В большинстве случаев поле DPL дескрипторов сегментов TSS
должно содержать 00, поэтому переключение задач могут проводить только
привилегированные программы (на нулевом уровне).
Сегмент TSS не является ни сегментом кода, ни сегментом данных. Доступ
к нему имеет только процессор, но не задача, даже на нулевом уровне! Если
предполагается программно использовать сегмент TSS, то следует применить
альтернативное именование.
Обращение к дескриптору TSS не предоставляет возможность процедуре
считать или модифицировать сегмент TSS. Загрузка селектора дескриптора
TSS в сегментный регистр вызывает особый случай. Доступ к сегменту TSS
возможен только с помощью альтернативного именования, когда сегмент
данных отображен на ту же область памяти.
Сегмент состояния задачи TSS (рис. 7.11) включает в себя содержимое всех
пользовательских регистров процессора, причем 8 регистров общего назна-
чения хранятся в сегменте в том же порядке, в каком они помещаются в стек
командой PUSHAD. Кроме того, в TSS сохраняются значения трех указателей
стека SSi : ESPi для трех уровней привилегий — i∈{0, 1, 2}. Сохранение
в TSS регистров CS и EIP позволяет осуществлять рестарт задачи, при этом
гарантируется правильное действие команд условных переходов, т. к. в TSS
сохраняется и EFLAGS. Сохранение в TSS содержимого регистров CR3
и LDTR позволяет для каждой задачи образовывать свой каталог разделов
и локальную дескрипторную таблицу.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 185
Рис. 7.11. Сегмент TSS
В сегменте TSS имеется также несколько дополнительных полей. Поле об-
ратной связи содержит селектор TSS той задачи, которая выполнялась перед
данной; с его помощью можно организовать цепь вложенных задач. Поле
базы двоичной карты разрешения ввода/вывода (БДКВВ) содержит 16-
битовое смещение в данном сегменте TSS, с которого начинается сама дво-
186 Часть II. Архитектура микропроцессорных систем
ичная карта ввода/вывода. Эта карта позволяет определить произвольное
подмножество адресов в пространстве ввода/вывода, по которым данной за-
даче разрешено обращаться независимо от уровня привилегий. Если в этом
поле — 00h, то карта отсутствует. Бит ловушки Т применяется для отладки:
когда в TSS Т = 1, при переключении на данную задачу генерируется особый
случай отладки (прерывание 1).
При переключении задач между ними не передается никакой информации,
т. е. они максимально изолированы друг от друга. Этим исключается искаже-
ния задач и обеспечивается возможность прекращения и запуска любой зада-
чи в любой момент времени и в любом порядке.
С целью экономии времени на процедуру переключения задач все поля TSS
разделяются на "статические" и "динамические". К статическим относятся
поля указателей стека трех уровней и содержимое регистра LDTR — они ос-
таются неизменными в течение всего времени существования задачи. Содер-
жимое статических полей TSS определяется ОС при создании задачи. Стати-
ческие поля процессор только считывает при переключении задачи. Поля
регистров и поле обратной связи модифицируются при каждом переключе-
нии задачи.
До перехода в мультипрограммный режим необходимо определить дескрип-
торы TSS, разместить сами сегменты TSS в адресном пространстве и пра-
вильно инициировать их. Напомним, что селекторы TSS нельзя загружать
в сегментные регистры, поэтому для работы с TSS следует пользоваться аль-
тернативным именованием, т. е. псевдонимами этих сегментов. При загрузке
начальных значений полей TSS в CS : EIP указывают точку старта програм-
мы (задачи), а в регистр SS — селектор сегмента стека с правильным уров-
нем привилегий. Если предполагается работа задачи на разных уровнях при-
вилегий, следует инициализировать поля SSi : ESPi, а если задача рассчитана
на использование локальной дескрипторной таблицы и страничного преобра-
зования, в сегменте TSS потребуется инициировать поля LDTR и CR3.
В сегменте TSS отсутствуют поля для регистров CR0 и CR2, следовательно,
их значение не изменяется при переключениях задач. Поэтому страничное
преобразование и условия работы с устройством "плавающей арифметики"
(определяются полями CR0 и CR2) являются глобальными для всех задач.
Для каждой задачи может быть свой каталог разделов, но страничное преоб-
разование может быть разрешено или запрещено только для всей системы.
Переключение задач не затрагивает регистры GDTR и IDTR, а также регист-
ры отладки и проверки.
Минимальный размер сегмента TSS должен быть 104 байта (68h). Однако
пользователь может увеличить размер сегмента TSS для размещения допол-
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 187
нительной информации, например, состояние устройства регистров сопро-
цессора "плавающей арифметики" FPU, списка открытых файлов, двоичной
карты ввода/вывода и др. Однако когда процессор привлекает TSS для пере-
ключения задач, он игнорирует все данные сверх аппаратно поддерживаемых
104 байтами, и эту дополнительную информацию из TSS считывают про-
граммно.
7.2.2. Переключение задачи
Переключение задачи в х86 могут вызвать следующие четыре события:
􀂈 старая задача выполняет команду FAR CALL или FAR JMP, и селектор выби-
рает шлюз задачи;
􀂈 старая задача выполняет команду FAR CALL или FAR JMP, и селектор выби-
рает дескриптор TSS;
􀂈 старая задача выполняет команду IRET для возврата в предыдущую зада-
чу; эта команда приводит к переключению задачи, если в регистре
EFLAGS бит вложенной задачи NT = 1;
􀂈 возникло аппаратное или программное прерывание и соответствующий
элемент дескрипторной таблицы прерываний IDT содержит шлюз задачи.
Под термином "старая задача" ("выходящая задача") будем понимать ту зада-
чу, выполнение которой прекращается; под термином "новая задача" ("вхо-
дящая задача") будем понимать ту задачу, которую начинает выполнять про-
цессор.
Таким образом, селекторами в командах переходов и вызовов могут быть как
селекторы TSS (прямое переключение задачи), так и селекторы шлюзов зада-
чи (косвенное переключение задачи). В последнем случае дескриптор шлюза
задачи обязательно содержит селектор TSS.
Формат дескриптора шлюза задачи приведен на рис. 7.12.
Рис. 7.12. Форматы шлюза задачи и дескриптора TSS
188 Часть II. Архитектура микропроцессорных систем
Старая задача должна быть достаточно привилегированна для доступа
к шлюзу задачи или к сегменту TSS. Правила привилегий обычные:
􀂈 max(CPL, RPL) > DPL шлюза задачи:
􀂈 max(CPL, RPL) > DPL сегмента TSS.
Процедура возврата из прерываний IRET всегда возвращает управление пре-
рванной программе. Если флаг NT сброшен в 0, производится обычный воз-
врат, а если он установлен в 1 — происходит переключение задачи. При этом
процессор сохраняет свое состояние в сегменте TSS старой задачи, загружает
в регистр TR содержимое поля обратной связи — селектор новой задачи
("задачи-предка", т. к. осуществляется возврат) и восстанавливает из сегмен-
та TSS контекст новой задачи. Благодаря наличию в каждом сегменте TSS
поля обратной связи можно поддерживать многократные вложения задач.
Характерно, что команда возврата из подпрограммы RET не чувствительна
к значению флага NT и не может осуществить переключение задачи.
После модификации TR и загрузки нового контекста из сегмента TSS про-
цессор отмечает этот сегмент как занятый (устанавливает бит 41 занятости
Busy в его дескрипторе). Занятый TSS может относиться либо к выполняю-
щейся, либо ко вложенной задаче. Переключение на задачу, отмеченную как
занятая, не производится! В частности, это исключает возможность реализа-
ции реентерабельных задач. Исключение представляет только команда IRET,
которая возвращает управление задаче-предку (очевидно, будучи вложенной,
она отмечена как запятая).
При переключении задачи процессор устанавливает также флаг переключе-
ния задачи TS в регистре CR0. Сброс этого флага может осуществиться толь-
ко привилегированной командой CLTS. TS применяется для правильного ис-
пользования некоторых системных ресурсов, в частности — устройства
плавающей арифметики (Float Point Unit, FPU). Если при каждом переключе-
нии задачи сохранять состояние FPU, то на это уйдет много времени, причем
новая задача может вообще не использовать ресурсы FPU, и тогда такое со-
хранение окажется напрасным. В процессоре 80486 команды FPU анализи-
руют состояние флага TS и если TS = 1, формируется особый случай 7 и вы-
зывается системная процедура сохранения состояния FPU. После этого флаг
TS сбрасывается.
При переключении задачи процессор не фиксирует факт использования но-
вой задачей FPU. Очевидно, это забота обработчика прерывания 7 — сам об-
работчик или ОС может поддерживать в TSS флаг использования сопроцес-
сора. Кроме того, обработчик прерывания 7 может запоминать селектор TSS
последней программы, использующей FPU.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 189
Итак, процесс переключения задачи можно представить следующим образом.
Имеется TR с теневым регистром дескриптора TSS, определяющий TSS старой
задачи. Если селектор в командах FAR JMP, FAR CALL, IRET (NT = 1), INT указы-
вает прямо (дескриптор TSS) или косвенно (шлюз задачи) в GDT на системный
объект переключения задачи, то производится переключение задачи:
􀂈 процессор сохраняет контекст старой задачи в сегменте TSS старой за-
дачи;
􀂈 процессор загружает в TR селектор сегмента новой задачи;
􀂈 процессор загружает в сегмент TSS новой задачи селектор TSS старой за-
дачи (в поле обратной связи);
􀂈 получив доступ к сегменту TSS новой задачи, процессор загружает кон-
текст новой задачи в регистры (в том числе CS : EIP — точка старта);
􀂈 процессор устанавливает флаги NT (в регистре EFLAGS) и TS (в CR0 для
анализа командами FPU), устанавливает бит занятости задачи в дескрип-
торе TSS новой задачи.
7.3. Прерывания и особые случаи
Прерывания текущей программы могут возникать по следующим трем при-
чинам:
􀂈 внешний сигнал по входам INTR или NMI;
􀂈 аномальная ситуация, сложившаяся при выполнении конкретной команды
и зафиксированная аппаратурой контроля;
􀂈 находящаяся в программе команда прерывания INT n.
Первая из указанных выше причин относится к аппаратным прерываниям,
а две другие — к программным.
Программные прерывания, вызываемые причинами 2 и 3, называют обычно
особыми случаями (иногда используют термин исключения). Особые случаи
возникают, например, при нарушении защиты по привилегиям, превышении
предела сегмента, делении на ноль и т. д.
Все особые случаи классифицируются как нарушения, ловушки или аварии.
Нарушение (fault) — этот особый случай процессор может обнаружить до
возникновения фактической ошибки (например, нарушение правил привиле-
гий или отсутствие сегмента в оперативной памяти). Очевидно, после обра-
ботки нарушения можно продолжить программу, осуществив рестарт винов-
ной команды.
190 Часть II. Архитектура микропроцессорных систем
Ловушка (trap) — обнаруживается после окончания выполнения виновной
команды. После ее обработки процессор возобновляет действия с той коман-
ды, которая следует за "захваченной" (например, прерывание при переполне-
нии или команда INT n). Большинство отладочных контрольных точек также
интерпретируются как ловушки.
Авария (abort) — приводит к потере контекста программы, ее продолжение
невозможно. Причину аварии установить нельзя, поэтому осуществить рес-
тарт программы не удается, ее необходимо прекратить. К авариям ("выходам
из процесса") относятся аппаратные ошибки, а также несовместимые или не-
допустимые значения в системных таблицах.
Общая реакция процессора на прерывания или особые случаи состоит в со-
хранении минимального контекста прерываемой программы (в стеке — адрес
возврата и, может быть, некоторую дополнительную информацию), иденти-
фикации источника прерывания или особого случая и передаче управления
соответствующему обработчику (программе, подпрограмме, задаче). Однако
имеются принципиальные различия по формированию сохраняемого кон-
текста.
При возникновении нарушений в стек обработчика особого случая в качестве
адреса возврата включается CS : EIP команды, вызвавшей нарушение.
При распознавании ловушки (к ним относятся и большинство внешних пре-
рываний) процессор включает в стек адрес возврата, относящийся к следую-
щей за ловушкой команде.
Наконец, при авариях содержательный адрес возврата отсутствует, поэтому
рестарт задачи при авариях невозможен.
Принцип реализации прерываний (внешних) и особых случаев (внутренних)
в микропроцессорах фирмы Intel сохранился практически неизменным
с МП 8086.
В 8086 сигналы запросов на обработку прерываний формировались либо ап-
паратурой контроля процессора (внутренние прерывания), либо поступали из
внешней среды на входы процессора INTR или NMI. При обнаружении (раз-
решенного) запроса в стек помещались текущие значения FLAGS, CS и IP.
В процессе идентификации источника запроса ему ставился в соответствие
восьмиразрядный двоичный код n — вектор прерывания, причем за каждым
внутренним прерыванием и за внешним NMI жестко закреплялся свой век-
тор, а для запросов, поступивших по входу INTR, реализовывалась процедура
ввода вектора с внешней шины. Далее, определенный вектор прерывания
рассматривался как номер строки таблицы, располагающейся с нулевого фи-
зического адреса памяти. Четырехбайтовыми элементами этой таблицы были
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 191
адреса CS : IP точек входа в подпрограммы — обработчики прерываний. Та-
ким образом, в системе поддерживалось до 256 различных обработчиков
прерываний, причем векторы 0—31 резервировались за внутренними преры-
ваниями (и NMI), а остальные — для внешних прерываний.
При идентификации источника запроса INTR выполняются следующие дей-
ствия (при условии, что флаг IF = 1, иначе запрос INTR игнорируется):
1. Генерируется два цикла шины для ввода вектора внешнего прерывания.
2. Помещается в стек содержимое регистра FLAGS.
3. Помещается в стек содержимое регистра CS.
4. Помещается в стек содержимое регистра IP.
5. Сбрасывается в 0 флаг разрешения внешних прерываний IF, запрещая
восприятие новых запросов по входу INTR до явной установки флага IF
в 1 командой STI.
6. По значению вектора n обращаются к n -му элементу таблицы векторов
прерываний и из нее загружаются новые значения регистров CS : IP.
7. Начинается выполнение обработчика прерывания с точки входа, опреде-
ляемой CS : IP.
Сохраненное в стеке старое содержимое регистров CS : IP образует адрес
возврата. Когда обработчик прерываний заканчивает свои действия, он дол-
жен выполнить команду возврата IRET, которая, извлекая из стека содержи-
мое FLAGS, CS, IP, возвращает управление прерванной программе.
Механизм реализации внешних и внутренних прерываний МП 80486
и Pentium в R-режиме аналогичен описанному выше, однако в Р-режиме он
значительно усовершенствован:
􀂈 таблица векторов прерываний трансформирована в дескрипторную табли-
цу прерываний IDT (рис. 7.13);
􀂈 более сложен процесс перехода к обработчику прерывания или особого
случая;
􀂈 обработчику передается дополнительная информация о причине возник-
новения особого случая.
Механизм передачи управления обработчику особого случая (прерывания)
соответствует обычному способу передачи управления через шлюз вызова.
При этом процессор аппаратно включает в стек значения EFLAGS, CS : EIP
(адрес возврата) прерываемой программы и, кроме того, в некоторых случа-
ях — код ошибки и текущие значения SS, ESP (последние — при смене при-
вилегий).
192 Часть II. Архитектура микропроцессорных систем
Рис. 7.13. Дескрипторная таблица прерываний
Точное значение адреса возврата зависит от того, является ли особый случай
нарушением, ловушкой или аварией. Первые 32 вектора зарезервированы за
особыми случаями Р-режима (табл. 7.1).
Таблица 7.1. Особые случаи
Вектор Причина Тип
0 Ошибка деления Нарушение
1 Отладка Нарушение/ловушка
2 Немаскируемое прерывание NMI Ловушка
3 Контрольная точка Ловушка
4 Переполнение Ловушка
5 Нарушение границы массива Нарушение
6 Недействительный код операции Нарушение
7 Устройство недоступно Нарушение
8 Двойное нарушение* Авария
9 Не используется
10 Недействительный TSS* Нарушение
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 193
Таблица 7.1 (окончание)
Вектор Причина Тип
11 Неприсутствие сегмента* Нарушение
12 Нарушение стека* Нарушение
13 Нарушение общей защиты* Нарушение/ловушка
14 Страничное нарушение* Нарушение
15 Зарезервирован
16 Ошибка операции c плавающей точкой Нарушение
17 Контроль выравнивания* Нарушение
18—31 Зарезервированы
Примечание. * — включает в стек код ошибки.
7.3.1. Дескрипторная таблица прерываний
Дескрипторная таблица прерываний IDT является прямой заменой таблицы
векторов прерываний процессора 8086. Она должна определять 256 обработ-
чиков прерываний и особых случаев, поэтому ее максимальный размер со-
ставляет 256 × 8 = 2048 байтов. Таблица IDT может находиться в любой об-
ласти памяти, процессор локализует ее с помощью 48-битного регистра
IDTR, который содержит базовый адрес и предел таблицы. Таблицу не реко-
мендуется объявлять короче максимального размера, т. к. любое обращение
за пределы таблицы вызывает нарушение общей защиты, а вектор внешнего
прерывания, вообще говоря, может иметь любое значение в диапазоне
00—FFh.
В таблице IDT разрешается применять только три вида дескрипторов: шлюз
ловушки, шлюз прерывания и шлюз задачи (но не дескриптор TSS). Шлюзы
прерывания и ловушки имеют большое сходство со шлюзом вызова (см.
рис. 7.9). Единственное отличие состоит в отсутствии в этих шлюзах 5-би-
тового поля счетчика WC, которое в шлюзе вызова определяет число пара-
метров, передаваемых в вызываемую подпрограмму через стек. Соответст-
вующее поле в шлюзах прерывания и ловушки зарезервировано.
Напомним, что шлюз вызова (а также ловушки и прерывания) содержит се-
лектор сегмента кода и смещение внутри него, которые однозначно опреде-
ляют точку передачи управления. Шлюз задачи содержит лишь селектор сег-
мента состояния задачи TSS (разумеется, каждый дескриптор содержит и
байт доступа).
194 Часть II. Архитектура микропроцессорных систем
После локализации сегмента кода обработчика особого случая и включения
информации в стек, выполнение начинается с той команды, которая опреде-
ляется смещением в шлюзе ловушки. Обработчик действует до тех пор, пока
не достигнет команды IRET. По этой команде процессор извлекает из стека
адрес возврата и содержимое регистра флажков (а также 48-битный указатель
внешнего стека, если при обработке особого случая происходила смена
уровней привилегий).
Если особый случай вызывается через шлюз прерывания, процессор сбрасы-
вает флаг разрешения прерывания IF после включения в стек адреса возврата
и содержимое регистра флажков, но до выполнения первой команды обра-
ботчика. При переходе через шлюз ловушки никакие флаги не изменяются.
Обработка особого случая через шлюз задачи аналогична действию команды
FAR CALL, приводящей к переключению задачи. Однако здесь невозможен
прямой переход через дескриптор TSS, а требуется промежуточный шлюз
задачи. С дескриптором шлюза задачи ассоциируется уровень привилегий,
который не должен быть выше уровня привилегий прерываемой задачи.
По существу, прерываемая задача как бы выполняет команду FAR CALL вызова
другой задачи через шлюз задачи, и здесь действуют стандартные правила
защиты по привилегиям.
Обработка особого случая через шлюз задачи, т. е. в другой задаче, имеет
определенные преимущества:
􀂈 автоматически сохраняется весь контекст прерванной задачи;
􀂈 обработчик особого случая не может исказить прерванную задачу, т. к. он
полностью изолирован от нее;
􀂈 обработчик прерывания может работать на любом уровне привилегий и в
заведомо правильной среде; он может иметь свое локальное адресное про-
странство благодаря наличию отдельной локальной дескрипторной табли-
цы (при необходимости).
К недостаткам применения шлюза задачи для вызова обработчика можно от-
нести:
􀂈 замедленную реакцию процессора на особый случай;
􀂈 в шлюзе задачи невозможно определить начальную точку выполнения за-
дачи;
􀂈 сложность получения информации о прерванной задаче.
Переключение задачи, инициируемое особым случаем, производит вложение
задачи обработчика в прерванную задачу. Старая задача остается занятой,
а новая — обработчик особого случая — отмечается как занятая, причем
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 195
в ней будет установлен флажок NT и загружено поле обратной связи. Со-
стояние флага IF в новой задаче не меняется и определяется тем значением
бита регистра EFLAGS, которое хранилось в TSS. Поэтому, если обработчик
особого случая через шлюз задачи предназначен для обработки внешних
прерываний, следует в TSS установить IF = 0, "аппаратно" запретив внешние
прерывания на время работы обработчика, или пока он явно не установит
IF = 1.
7.3.2. Учет уровня привилегий
Все особые случаи должны обрабатываться через шлюзы. В дескрипторах
шлюзов всех трех типов, содержащихся в IDT, имеется поле уровня привиле-
гий дескриптора DPL, определяющее минимальный уровень привилегий, не-
обходимый для использования шлюза. Для обработчиков прерываний реко-
мендуется устанавливать DPL = 3, чтобы обработка особого случая не
зависела от уровня привилегий текущей задачи.
Шлюзы ловушек или прерываний должны передавать управление сегменту
кода с более высоким или равным уровнем привилегий. Обработчику не раз-
решается работать на уровне привилегий, который ниже уровня прерываемой
задачи (если, конечно, он не является отдельной задачей). Из-за непредска-
зуемости возникновения прерываний и особых случаев требуется гарантиро-
вать невозможность нарушения правил защиты по привилегиям при обработ-
ке особого случая. Этого можно достичь двумя способами:
􀂈 определить все обработчики особых случаев, не вызывающие переключе-
ния задачи, в сегментах кода с уровнем привилегий 0; такие обработчики
будут действовать всегда, независимо от значения СPL программы;
􀂈 определить все обработчики особых случаев, не вызывающие переключе-
ния задачи, в подчиненные сегменты кода.
7.3.3. Код ошибки
В некоторых особых случаях процессор включает в стек 4 байта кода ошибки
(error code), причем действительными являются только 2 младших байта, ос-
тальные включаются лишь для выравнивания стека. Когда процессор обна-
руживает
􀂈 недействительный сегмент TSS:
􀂈 нарушение неприсутствия;
􀂈 нарушение стека;
􀂈 нарушение общей защиты,
196 Часть II. Архитектура микропроцессорных систем
он включает в стек обработчика особого случая информацию, идентифици-
рующую "виновный" дескриптор.
Формат кода ошибки напоминает селектор, т. к. большинство особых случаев
связано с ошибками дескрипторов и содержит следующие поля:
􀂈 биты [15:3] — индекс (номер строки дескрипторной таблицы);
􀂈 бит [2] — TI, как и в других селекторах, определяет принадлежность де-
скриптора к локальной (TI = 1) или глобальной (TI = 0) дескрипторной
таблице;
􀂈 бит [1] — I. Если I = 1, то индекс в старших битах [15:3] кода ошибки от-
носится к дескрипторной таблице прерываний IDT;
􀂈 бит [0] — ЕХТ = 1 означает, что особый случай был вызван аппаратным
прерыванием (внешним) или возник, когда процессор обрабатывал другой
особый случай.
Если процессор не может сформировать содержательный код ошибки, он
включает в стек код, равный 0.
Помимо кода ошибки в некоторых особых случаях дополнительная диагности-
ческая информация находится в других регистрах процессора. Например, при
страничном нарушении в регистре CR2 содержится линейный адрес, преобра-
зование которого привело к ошибке. Обработчик этого особого случая может
обратиться к соответствующим элементам PDE и РТЕ. Для особого случая от-
ладки полезная информация содержится в регистре состояния отладки DR6.
7.3.4. Описание особых случаев
Далее приводится краткое описание действий процессора х86 при возникно-
вении особых случаев [3].
Ошибка деления (0) — автоматически формируется, когда в команде DIV или
IDIV делитель равен нулю или частное слишком велико для получателя
(AL/AX/EAX).
Отладка (1) — формируется в следующих случаях (может быть нарушением
или ловушкой):
􀂈 нарушение контрольной точки по адресу команд;
􀂈 ловушка контрольной точки по адресу данных;
􀂈 нарушение общей защиты;
􀂈 ловушка покомандной работы (флаг TF =1);
􀂈 ловушка контрольной точки по переключению задачи (в сегменте TSS бит
Т = 1).
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 197
Немаскируемое прерывание NMI (2) — единственное внешнее радиальное
прерывание.
Контрольная точка (3) — формируется при выполнении команды INT3 (код
операции — CCh). Передача управления обработчику особого случая являет-
ся частью команды INT3, адрес возврата в стеке относится к началу следую-
щей команды. Тот же обработчик вызывается при выполнении внешнего
прерывания с вектором 03 или двухбайтовой команды INT 03.
Переполнение (4) — возникает при выполнении команды INTO при условии
установки в 1 флага переполнения OF. Как и для INT3, передача управления
обработчику особого случая является частью команды INTO, адрес возврата
в стеке относится к началу следующей команды. Обычно команда INTO при-
меняется в компиляторах для выявления переполнения в арифметике знако-
вых чисел. Тот же обработчик вызывается при выполнении внешнего преры-
вания с вектором 04 или команды INT 04.
Нарушение границы массива (5) — возникает при выполнении команды
BOUND, если контрольная проверка дает отрицательный результат, т. е. прове-
ряемый (первый) операнд не попадает в диапазон значений, определенных
вторым (нижняя граница) и третьим (верхняя граница) операндами команды.
Недействительный код операции (6) — генерируется, когда операционное
устройство процессора обнаруживает неверный код операции, несоответст-
вие типа операндов коду операции, попытку выполнения привилегированных
команд в R-режиме, неверные байты mod r/m или sib, использование префик-
са блокировки LOCK с командами, которые нельзя блокировать. Характерно,
что существует несколько одно- и двухбайтовых кодов, зарезервированных
фирмой Intel для развития системы команд, и хотя им в 80486 не соответст-
вуют никакие команды, зарезервированные коды не вызывают особого случая.
Устройство3 недоступно (7) — возникает в двух ситуациях:
􀂈 процессор выполняет команду ESC и бит ЕМ (эмуляция сопроцессора)
в регистре CR0 установлен в 1;
􀂈 процессор выполняет команду WAIT или ESC и бит TS (переключение зада-
чи) в регистре CR0 установлен в 1.
В первом случае программист намерен выполнить операции плавающей
арифметики программно.
Второй случай может возникнуть после переключения задачи. Бит TS аппа-
ратно устанавливается в 1 при переключении задачи, а первая же встретив-
3 Под устройством здесь понимается аналог математического сопроцессора — уст-
ройство с плавающей точкой FPU.
198 Часть II. Архитектура микропроцессорных систем
шаяся в новой задаче команда сопроцессора вызывает особый случай 7, ибо
контекст устройства с плавающей точкой старой задачи не сохранен. Обра-
ботчик особого случая 7 сохраняет старое состояние устройства с плавающей
точкой в сегменте TSS старой задачи и загружает новое состояние устройства
из сегмента TSS новой задачи. (В случае работы цепочки вложенных задач
обработчик должен программно отследить ту старую задачу, которая послед-
ней использовала FPU.) После этого привилегированной командой CLTS
сбрасывается флажок TS и осуществляется возврат на команду устройства
с плавающей точкой. Так как теперь флаг TS сброшен, команда сопроцессора
будет выполнена.
Двойное нарушение (8) — обычно, когда процессор обнаруживает особый
случай при попытке вызвать обработчик предыдущего особого случая, два
особых случая обрабатываются последовательно. Если процессор не может
обрабатывать их последовательно, он сигнализирует о двойном нарушении.
Для определения того, когда о двух нарушениях следует сообщать как
о двойном нарушении, процессор подразделяет все особые случаи на три
класса:
􀂈 легкие особые случаи — векторы 1, 2, 3, 4, 5, 6, 7, 16;
􀂈 тяжелые особые случаи — векторы 0, 10, 11, 12, 13;
􀂈 страничные нарушения — вектор 14.
Когда возникают два легких особых случая или один легкий и один тяжелый,
эти два события допускают последовательную обработку. При появлении
двух тяжелых событий их обработать нельзя, поэтому процессор формирует
особый случай двойного нарушения. Аналогичное состояние наступает, если
после страничного нарушения возникает тяжелый особый случай или второе
страничное нарушение, хотя если, наоборот, после тяжелого особого случая
возникает страничное нарушение, эти события могут быть обработаны.
Если при попытке вызвать обработчик двойного нарушения возникает любое
другое нарушение, процессор переходит в режим отключения. Этот режим
аналогичен состоянию процессора после выполнения команды HLT. До вос-
приятия сигналов NMI или RESET никакие команды не выполняются, при-
чем если отключение возникло при выполнении обработчика немаскируемо-
го прерывания, запустить процессор может только сигнал RESET.
Недействительный сегмент TSS (10) — возникает при попытке переключе-
ния на задачу с неверным сегментом TSS. Поскольку сегмент TSS может оп-
ределять LDT, сегменты кода, стека, данных, к особому случаю 10 относятся
ситуации с нарушением границ этих сегментов, нарушением прав доступа,
запретом записи в сегмент стека и др. Нарушения могут возникать как в кон-
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 199
тексте старой, так и новой задачи, поэтому обработчик особого случая 10
должен сам быть задачей и вызываться через шлюз задачи (десятая строка
IDT должна содержать шлюз задачи).
Неприсутствие сегмента (11) — формируется, когда бит присутствия сег-
мента в дескрипторе Р = 0. Это нарушение допускает рестарт, если обработ-
чик особого случая 11 реализует механизм виртуальной памяти на уровне
сегментов.
Нарушение стека (12) — возникает в двух ситуациях:
􀂈 в результате нарушения предела любой операции, которая обращается
к регистру SS (POP, PUSH, ENTER, неявное использование стека при обраще-
нии к памяти, например, MOV АХ, [ВР+6]);
􀂈 при попытке загрузить в регистр SS дескриптор, который отмечен непри-
сутствующим.
Нарушение общей защиты (13) — все нарушения защиты, которые не служат
причиной конкретного особого случая, вызывают особый случай общей
защиты:
􀂈 превышение предела сегмента (кроме стека);
􀂈 передача управления сегменту, который не является выполняемым;
􀂈 запись в защищенный от записи сегмент;
􀂈 считывание из выполняемого сегмента;
􀂈 загрузка в SS селектора сегмента, защищенного от записи;
􀂈 загрузка в регистры SS, DS, ES, FS, GS селектора системного сегмента;
􀂈 загрузка в регистры SS, DS, ES, FS, GS селектора выполняемого сегмента;
􀂈 обращение к памяти через DS, ES, FS, GS, когда в них пустой селектор;
􀂈 переключение на занятую задачу;
􀂈 нарушение правила привилегий
и др.
Страничное нарушение (14) — возникает, когда разрешено страничное пре-
образование и имеет место одна из следующих ситуаций:
􀂈 в элементе каталога разделов или таблицы страниц, используемом для
преобразования линейного адреса в физический, сброшен бит присут-
ствия;
􀂈 процедура не имеет достаточного уровня привилегий для доступа к адре-
суемой странице.
200 Часть II. Архитектура микропроцессорных систем
Ошибка операции c плавающей точкой (16) — сигнализирует об ошибке,
возникшей в команде устройства с плавающей точкой.
Контроль выравнивания (17) — возникает при нарушении выравнивания
операндов. Операнды считаются выровненными, если адрес двухбайтового
слова является четным (младший разряд равен 0), адрес четырехбайтового
двойного слова кратен 4, а адрес восьмибайтовой структуры данных кратен
8. Для разрешения контроля выравнивания должны выполняться три усло-
вия:
􀂈 бит AM в регистре CR3 установлен;
􀂈 флаг АС установлен;
􀂈 выполняется программа на уровне привилегий 3.
7.4. Средства отладки
Традиционно средства отладки микропроцессоров ограничивались наличием:
􀂈 короткой команды программного прерывания, которую можно было уста-
навливать вместо первого байта любой команды;
􀂈 аппаратной реализации пошагового (покомандного) режима, который
инициировался установкой специального бита Т в регистре флагов.
По мере усложнения МПС возможности внешних аппаратных средств по
наблюдению операций, происходящих внутри процессора, уменьшаются.
Поэтому в схемах мощных процессоров стали предусматривать разнообраз-
ные средства отладки.
Основу средств отладки в процессорах х86 старших моделей составляют
специализированные регистры отладки — программируемые регистры за-
дания контрольных точек, регистры управления и состояния отладки. Они
заменяют собой средства аппаратных внутрисхемных эмуляторов. Процес-
соры х86 старших моделей обеспечивают не только покомандную работу,
но и регистрацию переключения на конкретную задачу, установку кон-
трольных точек по адресам команд и фиксацию модификации значений пе-
ременных в памяти.
Регистры отладки поддерживают контрольные точки по командам и данным.
В общем, под контрольной точкой понимается адрес, при использовании
которого программой возникает особый случай отладки. Установка кон-
трольной точки по команде обеспечивает регистрацию команды по любому
линейному адресу. Задание контрольной точки по данным позволяет узнать,
когда производится обращение к конкретной переменной.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 201
Отладочные средства х86 включают в себя:
􀂈 однобайтовую команду контрольной точки INT3, которую можно встав-
лять в программу по любому адресу; при выполнении этой команды гене-
рируется особый случай отладки;
􀂈 флаг пошагового режима TF в регистре EFLAGS, позволяющий выпол-
нить программу по командам;
􀂈 четыре регистра отладки DR0—DR3, которые определяют четыре незави-
симые контрольные точки по командам или данным; регистр управления
отладкой DR7 и регистр состояния отладки DR6;
􀂈 флаг ловушки Т в TSS, который вызывает особый случай отладки при пе-
реключении на задачу с установленным в 1 битом Т;
􀂈 флаг возобновления RF в регистре EFLAGS, с помощью которого подав-
ляются многократные особые случаи в одной и той же команде.
Все эти средства действуют как ловушки, следя за возникновением условий,
представляющих интерес для программиста. Когда возникает такое условие,
формируется особый случай отладки (с вектором 1); только команда INT3
генерирует прерывание с вектором 3. Зарезервированный вектор отладки 1
упрощает процедуру вызова отладчика.
Итак, отладчик по вектору 1 вызывается в следующих случаях:
􀂈 при TF = 1 после каждой команды;
􀂈 при TTSS = 1 в момент переключения на задачу;
􀂈 ловушка контрольной точки по данным;
􀂈 нарушение контрольной точки по команде.
Команда INT3 предоставляет альтернативный способ задания контрольной
точки и особенно удобна, если контрольные точки размещаются в исходном
коде или требуется установить более четырех контрольных точек.
Программные контрольные точки задаются путем замены обычных команд
на команды INT3 — при этом требуется осуществлять запись в сегмент кода
(создавать альтернативный сегмент данных), а после отладки — восстанав-
ливать исходный код. Использование аппаратных контрольных точек исклю-
чает необходимость модификации кода (можно отлаживать программу, раз-
мещенную в ПЗУ), а так же допускает контроль обращения к данным.
Рассмотренные средства позволяют вызывать отладчик как процедуру в кон-
тексте текущей задачи или как отдельную задачу при выполнении одного из
следующих условий:
􀂈 выполнение команды контрольной точки INT3;
􀂈 выполнение любой команды (при TF = 1);
202 Часть II. Архитектура микропроцессорных систем
􀂈 выполнение команды по указанному адресу;
􀂈 считывание или запись байта, слова или двойного слова по указанному
адресу;
􀂈 запись байта, слова или двойного слова по указанному адресу;
􀂈 переключение на конкретную задачу;
􀂈 попытка изменить содержимое регистра отладки.
7.4.1. Регистры отладки
Регистры отладки, форматы которых приведены на рис. 7.14, включают в себя:
􀂈 четыре регистра DR0—DR3, предназначенные для хранения линейных
адресов четырех контрольных точек, каждая из которых независимо мо-
жет быть определена как контрольная точка по команде или по данным;
􀂈 регистр DR7 управления отладкой, включающий поля, которые опреде-
ляют свойства контрольных точек и некоторые параметры процесса от-
ладки;
􀂈 регистр DR6 состояния отладки, предназначенный для идентификации
причины прерывания отладки;
􀂈 наконец, зарезервированные регистры DR5, DR4.
Рис. 7.14. Форматы регистров отладки
Рассмотрим форматы регистров состояния и управления.
Выше отмечалось, что все события отладки, кроме INT3, вызывают прерыва-
ние с вектором 1. Следовательно, при возникновении особого случая отладки
встает вопрос о причине прерывания. Именно для идентификации причин
прерывания 1 предусмотрен регистр состояния отладки DR6.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 203
Младшие четыре бита В0—ВЗ относятся к четырем контрольным точкам
и единичное состояние Bi означает достижение контрольной точки, линей-
ный адрес которой находится в регистре DRi.
Флаг BS (Step) устанавливается в 1, когда процессор начинает отрабатывать
особый случай, вызванный ловушкой покомандной работы, т. е. при BS = 1
причиной особого случая является состояние TF = 1 регистра EFLAGS. Этот
случай имеет высший приоритет среди всех случаев отладки, когда BS = 1,
могут быть установлены и другие биты состояния отладки.
Флаг ВТ (Task) устанавливается в 1, когда особый случай отладки вызван
переключением на задачу, в TSS которой установлен бит ловушки Т =1.
Регистры отладки доступны (по записи или чтению) только в реальном ре-
жиме или в защищенном режиме по привилегированной (т. е. разрешенной
к выполнению только на нулевом уровне) команде MOV:
mov eax, dr6
mov dr1, eax
В регистре DR7 предусмотрен флаг GD, который, будучи установленным,
обеспечивает "сверхзащиту" всех обращений к регистрам отладки, вызывая
при любой попытке обращения к этим регистрам прерывание 1. Для иденти-
фикации этой ситуации в DR6 предусмотрен бит BD. Он устанавливается в 1,
если следующая команда будет считывать или записывать в один из восьми
регистров отладки. Характерно, что при вызове процедуры обработчика
с вектором 1 бит GD автоматически сбрасывается, что обеспечивает обра-
ботчику возможность доступа к регистрам отладки.
Процессор никогда не сбрасывает биты регистра состояния отладки DR6,
поэтому обработчик особого случая должен сбрасывать их программно, ина-
че причины особых случаев отладки будут накапливаться.
Возможно, при возникновении особого случая отладки в состоянии 1 будут
находиться несколько битов DR6 (что возможно при разрешении аппаратных
контрольных точек) или, наоборот, в DR6 не окажется единичных битов. По-
следнее возможно, если возникло внешнее прерывание с вектором 1 или вы-
полняется команда INT1.
Регистр управления отладкой DR7 содержит для каждой из четырех кон-
трольных точек следующие поля, определяющие ее характеристики: Li, Gi,
RWi и LENi, а также два однобитовых поля LE и GE, определяющие свойст-
ва, общие для всех контрольных точек. Назначение этих полей приведено
в табл. 7.2. Кроме того, в регистре DR7 бит 13 — GD — предназначен для
включения режима защиты регистров отладки от любого обращения со сто-
роны программ пользователя.
204 Часть II. Архитектура микропроцессорных систем
Таблица 7.2. Назначение полей регистра DR7
Поле Назначение
Li Локальное разрешение контрольной точки i∈{0,1, 2, 3} . Когда бит Li нахо-
дится в 1, разрешена аппаратная контрольная точка, линейный адрес кото-
рой находится в DR1, но только в текущей задаче. При переключении зада-
чи сбрасываются все биты Li
Gi Глобальное разрешение контрольной точки i . Функционирует аналогично
биту Li, но на него не действует переключение задач. Сбросить бит Gi мож-
но только программно
LE Локальная точность
GE Глобальная точность
RWi Определяет вид контрольной точки i :
• 00 — контрольная точка по команде;
• 01 — контрольная точка по данным с обращением по записи;
• 10 — не определена и не используется;
• 11 — контрольная точка по данным с обращением по считыванию или
записи (но не выбор команды)
LENi Для контрольной точки i по данным определяет длину данных:
• 00 — однобайтовое поле (и все команды);
• 01 — двухбайтовое поле (слово);
• 10 — не определена и не используется;
• 11 — четырехбайтовое поле (двойное слово)
Контрольная точка может быть локальной (в пределах одной задачи) или
глобальной — в зависимости от значений битов Li и Gi.
Допускается одновременное значение Li = Gi = 1 или Li = Gi = 0. В первом
случае это эквивалентно Gi = 1, а во втором — контрольная точка запрещена
и соответствие линейного адреса из регистра DRi адресу команды не вызыва-
ет особого случая (но Bi в регистре DR6 устанавливается в 1).
Аппаратные контрольные точки по командам устанавливаются путем за-
грузки в один из регистров DRi линейного адреса требуемой команды, уста-
новки в 00 соответствующих полей RWi и LENi, установки в 1 бита Li и/или
Gi. После этого процессор начинает контролировать устройство предвыборки
команд. Когда фиксируется равенство адреса команды и содержимого одного
из "разрешенных" регистров DRi, хранящих контрольную точку по коман-
дам, формируется особый случай отладки, причем в DR6 устанавливается
в 1 бит Bi.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 205
Адреса команд в регистрах DR0—DR3 должны быть 32-разрядными линей-
ными, а не логическими (селектор : смещение) или физическими. Линейный
адрес не зависит от страничного преобразования, поэтому контрольная точка
действует даже тогда, когда целевая команда участвует в свопинге и отобра-
жается на различные адреса физической памяти.
Если контрольная точка установлена как локальная, она сбрасывается при
переключении задачи, причем значение DR7 не сохраняется в TSS, поэтому
при восстановлении задачи контрольные точки не возобновляются. При не-
обходимости следует предусмотреть программное возобновление контроль-
ных точек. Для этого можно в расширении сегмента TSS той задачи, в кото-
рой определены локальные контрольные точки, записать значения DR0—
DR3 и DR7, а так же установить в TSS бит Т = 1. При переходе к такой задаче
вызывается обработчик особого случая, который и восстановит значения ре-
гистров DR из сегмента TSS.
Аппаратные контрольные точки по командам являются нарушениями, т. е.
процессор включает в стек адрес команды, вызвавшей нарушение, и обра-
ботчик особого случая возвращает управление на ту же команду. Поскольку
аппаратные контрольные точки по команде проверяются до выполнения са-
мой команды, процессор должен вновь сформировать особый случай. Необ-
ходимо обойти данную команду, для этого используется флаг возобновления
RF в регистре EFLAGS. Процессор автоматически устанавливает RF = 1 при
возникновении любого нарушения, включая и аппаратные контрольные точ-
ки по командам. Аппаратные прерывания по входам INTR и NMI, а также
программные ловушки и аварии не воздействуют на флаг RF. Когда RF = 1,
процессор игнорирует особый случай аппаратной контрольной точки по ко-
мандам, а после первой же команды, которая выполнена без особых случаев,
процессор сбрасывает RF.
Аппаратные контрольные точки по данным устанавливаются с помощью
тех же регистров отладки DR. Процессор формирует особый случай отладки
как ловушку, когда происходит обращение к данным по установленным в DR
адресам. Разрешается совместное применение контрольных точек по коман-
дам и по данным, причем возможно произвольное назначение типа кон-
трольной точки (поле RWi в регистре DR7).
Процессор контролирует выравнивание данных, если их длина, указанная
в поле LENi, равна слову или двойному слову. В этом случае при сравнении
текущего адреса сегмента данных с адресом контрольной точки игнорируют-
ся один или два младших бита регистра DRi.
Конвейерная архитектура старших моделей х86 обеспечивает одновре-
менную обработку нескольких команд. Случается, что контрольная точка
206 Часть II. Архитектура микропроцессорных систем
по данным фиксируется только после выполнения нескольких следующих
команд. В регистре управления отладкой DR6 предусмотрены биты, задаю-
щие локальную LE и глобальную GE "точность" определения контрольной
точки по данным. Будучи установленными в 1, эти биты замедляют внутрен-
ние операции процессора таким образом, что сообщают об обращении по
контролируемому адресу данных точно в тот момент, когда происходит об-
ращение к памяти. Биты LE, GE действуют только на контрольные точки по
данным, являются общими для всех таких точек, причем LE автоматически
сбрасывается при переключении задачи, а GE может быть сброшен лишь
программно.
Регистрация нескольких особых случаев
Если команда, на которую настроена контрольная точка, вызывает данные по
контролируемому адресу, процессор правильно сформирует два особых слу-
чая отладки. Первый — по команде — является нарушением, и обработчик
этого особого случая возвращает управление той же команде. При выполне-
нии команды второй особый случай не возникает (см. выше назначение бита
RF), зато фиксируется ловушка по данным. Причина текущего особого слу-
чая фиксируется в DR6.
7.5. Увеличение быстродействия
процессора
Одним из самых распространенных способов определения производительно-
сти процессора является оценка времени T решения некоторой (тестовой)
задачи. Очевидно,
,
f
N S
T
= ⋅ (7.1)
где N — количество выполненных при решении задачи машинных команд;
S — среднее количество тактов, приходящихся на выполнение одной коман-
ды; f — тактовая частота процессора.
Если длительности различных команд (в тактах) существенно отличаются
друг от друга, то более точно можно оценить значение T по выражению
,
1
1
Σ== ⋅
N
i
Si
f
T (7.2)
где Si — число тактов i-й команды.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 207
Используются и более точные (и, соответственно, более сложные) методы
оценки производительности [7, 11, 13], однако и из выражений (7.1), (7.2)
видны пути увеличения производительности процессора:
􀂈 увеличение тактовой частоты (решения лежат в области технологии
СБИС);
􀂈 сокращение длины программы (совершенствование технологии програм-
мирования, разработка оптимизирующих компиляторов);
􀂈 сокращение числа тактов, приходящихся на выполнение одной команды.
Последнее возможно за счет усложнения схемы процессора, при этом значи-
тельное усложнение может привести к сокращению числа тактов команды
при увеличении "глубины схемы", что повлечет за собой увеличение дли-
тельности такта, так что выигрыш может обернуться проигрышем.
Магистральным путем увеличения производительности ЭВМ можно считать
параллелизм на различных уровнях.
Существуют две основные формы параллелизма [11]:
􀂈 параллелизм на уровне процессов;
􀂈 параллелизм на уровне команд.
В первом случае над одной задачей могут одновременно работать несколько
процессоров или других устройств ЭВМ.
Во втором случае параллелизм реализуется в пределах отдельных команд.
Обычно стремятся совмещать во времени процедуры обращения к памяти
и обработки информации, параллельно выполнять арифметические операции
сразу над несколькими (или даже всеми) разрядами операндов, одновременно
выполнять несколько последовательных команд программы (разумеется, на
разных стадиях) и т. п.
Уже в младшей модели семейства х86 — микропроцессоре 8086 предусмат-
ривалась одновременная работа двух основных устройств — обработки дан-
ных и связи с магистралью. Подобный механизм (с модификациями) сохра-
нился и в старших моделях семейства.
Особенно эффективным способом организации параллельных операций
в компьютерной системе является конвейерная обработка команд.
Далее мы кратко рассмотрим некоторые из перечисленных методов увеличе-
ния производительности процессора. Более подробную информацию по этим
вопросам можно найти, например, в [11, 13].
208 Часть II. Архитектура микропроцессорных систем
7.5.1. Конвейеры
При отсутствии конвейера процессор выполняет программу, по очереди вы-
бирая из памяти и активизируя ее команды.
Процесс обработки команды может быть разбит, например, на следующие
шаги (стадии):
􀂈 F — выборка (от англ. fetch) — чтение команды из памяти;
􀂈 D — декодирование (от англ. decode) — декодирование команды;
􀂈 A — формирование адресов (от англ. address generate) и выборка опе-
рандов;
􀂈 Е — выполнение (от англ. execute) — выполнение заданной в команде
операции;
􀂈 W — запись (от англ. write) — сохранение результата по целевому адресу.
Приведенное разбиение не является единственно возможным — в некоторых
случаях рассматривают четырехстадийный командный цикл, иногда (напри-
мер, для процессоров, реализующих команды над числами с плавающей за-
пятой) — восьмистадийный и др.
Для реализации каждой из стадий командного цикла в процессоре преду-
смотрено соответствующее оборудование (регистры, дешифраторы, сумма-
торы, управляющие автоматы или их фрагменты), причем операционные
элементы разных стадий обычно слабо пересекаются между собой. Поэтому
когда очередная команда завершает действия на одной стадии, например F,
и переходит на следующую — D, то оборудование стадии F "простаивает"
и может быть использовано для чтения следующей команды. Таким образом,
очередная команда может начинать выполнение, не дожидаясь окончания
командного цикла предыдущей команды.
При рассмотрении пятистадийного командного цикла одновременно на раз-
ных стадиях может выполняться до пяти команд. Организация пятистадий-
ного конвейера потребует дублирования некоторых операционных элементов
на разных стадиях (например, регистра команд PC) и усложнение схемы
управления, однако игра стоит свеч.
Очевидно, очередная команда может перейти с одной стадии командного
цикла на другую при выполнении двух условий:
􀂈 действия команды на текущей стадии завершены;
􀂈 предыдущая команда освободила оборудование следующей стадии.
При условии, что каждая стадия выполняется в любой команде одинаковое
количество тактов (например, один), конвейер работает идеально, и одновре-
менно всегда выполняются пять команд (для пятистадийного конвейера).
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 209
Для большинства процессоров так называемой CISC4-архитектуры (к ним
относятся, в частности, процессоры семейства х86) такая идеальная ситуация
складывается далеко не всегда.
Действительно, команда, извлекаемая из памяти на стадии F, может иметь
разную длину и, следовательно, извлекаться из памяти за разное число ма-
шинных циклов.
В зависимости от заданного в команде способа адресации операндов время
выполнения стадии A может быть существенно различным (сравните непо-
средственную адресацию и косвенно-автоинкрементную). Расположение ад-
ресуемых операндов (и размещение результата) в памяти разного уровня так
же существенно влияет на время реализации стадии A (и стадии W).
Наконец, на стадии Е время выполнения операции зависит не только от типа
операции (короткие — сложение, конъюнкция, ..., длинные — умножение,
деление), но даже иногда и от значений операндов.
Учитывая отмеченные выше обстоятельства, можно сказать, что конвейеры
процессоров с классической CISC-архитектурой редко работают "на полную
мощность", находясь значительную часть времени в ожидании завершения
"длинных" операций.
Желание увеличить производительность конвейеров привело к появлению
процессоров т. н. RISC5-архитектуры, из систем команд которых были ис-
ключены все факторы, тормозящие реализацию командного цикла — длин-
ные команды, сложные способы адресации, размещение операндов в ОЗУ.
К особенностям RISC-архитектуры можно отнести:
􀂈 форматы всех команд имеют одинаковую длину, в крайнем случае, разно-
образие длин форматов ограничивается двумя вариантами;
􀂈 все операции выполняются за одинаковый промежуток времени (обычно 1
или 2 такта);
􀂈 операнды всех арифметических и логических операций располагаются
только в регистрах, к оперативной памяти обращаются только команды
загрузки и сохранения;
􀂈 сверхоперативная память представлена большим числом регистров
(32—256).
Реализация этих особенностей, с одной стороны, позволяет приблизить рабо-
ту конвейера к идеальной, с другой стороны — существенно ограничивает
4 Complex Instruction Set Computer — компьютер с полным набором команд.
5 Reduced Instruction Set Computer — компьютер с сокращенным набором команд.
210 Часть II. Архитектура микропроцессорных систем
возможности системы команд процессора. Действительно, из системы опера-
ций исключаются "длинные" операции — умножение, деление, операции над
числами с плавающей запятой и др. Исключаются сложные (и эффективные)
способы адресации, например, автоиндексные. Это приводит к значительно-
му увеличению длины программ, увеличению времени на выборку команд из
памяти, при этом среднее число команд, выполняемых в единицу времени,
в RISC-процессорах значительно больше, чем в CISC-процессорах.
По мере совершенствования интегральной технологии появилась возмож-
ность ценой значительных аппаратных затрат (теперь разработчики уже мог-
ли их себе позволить) резко сократить время выполнения "длинных" опера-
ций, например, за счет реализации матричного умножителя, табличной
арифметики и др. В этом случае длинные операции можно включать в систе-
му команд RISC-процессоров, не нарушая принципов их организации, но
увеличивая эффективность системы команд.
В настоящее время понятия "RISC-" и "CISC-архитектура" скорее являются
обозначением некоторых принципов проектирования, но не характеристика-
ми конкретных процессоров. Современные процессоры, как правило, реали-
зованы по "гибридному" принципу: содержат ядро RISC, которое выполняет
простые и самые распространенные команды за один такт на стадию конвей-
ера, а сложные команды интерпретируются как некая последовательность
простых (на уровне микрокоманд). Пользователь же в этом случае имеет дело
с системой команд привычной CISC-архитектуры, а внутренние вопросы реа-
лизации командного цикла его, как правило, не интересуют.
При реализации конвейеров возникает еще одна проблема, связанная с его
оптимальной загрузкой — команды условной передачи управления (в сред-
нем каждая 5—6-я команда программы). Действительно, когда такая команда
передается со стадии F на стадию D, на стадию F надо ставить следующую
команду, но какую? Условие перехода будет проверено лишь на стадии Е,
тогда же определится адрес следующей команды. Здесь возможны два пути
решения:
􀂈 приостановить загрузку конвейера до завершения командой перехода ста-
дии Е;
􀂈 загрузить конвейер "наугад" командой по одному из двух возможных ад-
ресов, а на стадии Е проверить правильность выбора и, если он оказался
неверным — очистить весь конвейер и начать загрузку заново по правиль-
ному адресу.
Второй путь представляется предпочтительным, т. к. конвейер не останавли-
вается, и (в среднем) в половине случаев мы избежим потери времени на пе-
резагрузку. Результаты работы конвейера будут еще лучше, если мы научимся
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 211
правильно предсказывать адрес перехода, чтобы вероятность угадывания ад-
реса приближалась к 1.
В современных процессорах часто предусматривают специальные аппарат-
ные блоки предсказания переходов. В разных процессорах реализуются раз-
личные алгоритмы предсказания, основанные на анализе результатов выпол-
нения предыдущих команд переходов [13].
7.5.2. Динамический параллелизм
Один конвейер хорошо, а два лучше? Почему бы, если позволяют ресурсы
интегральной технологии, не построить два конвейера и ставить на них одно-
временно пару команд программы. В процессоре Pentium именно так и сде-
лали — предусмотрели два 5-уровневых конвейера, которые могли работать
одновременно и выполнять две целочисленные команды за машинный такт.
Однако возможность одновременной постановки на два разных конвейера
пары последовательных команд программы ограничивается рядом условий.
Очевидно, что нельзя ставить на разные конвейеры две последовательные
команды, если вторая использует в качестве операнда результат работы пер-
вой или, во всяком случае, необходимо гарантировать, что к началу стадии
выборки операндов второй команды первая (на другом конвейере) уже за-
вершит стадию размещения результата. Существуют и другие ограничения,
которые определяют т. н. условия "спаривания" последовательных команд
(pairing), позволяющие размещать их одновременно на разных конвейерах.
В процессоре Pentium два конвейера не являются равноправными. Один из
них (U) может принять любую команду, а другой (V) — только удовлетво-
ряющую условиям "спаривания" (довольно сложным) с командой, постав-
ленной на U. Если эти условия не соблюдаются, следующая команда так же
помещается на U-конвейер, а V-конвейер пропускает такт. Некоторые коман-
ды могут появляться только на U-конвейере.
Разумеется, производительность двухконвейерного процессора, при прочих
равных условиях, превышает производительность одноконвейерного, но да-
леко не в два раза. Эффективность во многом определяется, насколько часто
будут встречаться в программе пары последовательных команд, допускаю-
щих "спаривание".
Очевидно, движение в направлении увеличения в процессоре числа конвейе-
ров, работающих по описанным выше принципам, бесперспективно. Условия
"страивания" (если можно так сказать) и т. д. будут настолько сложны, что
редко будут выполняться.
212 Часть II. Архитектура микропроцессорных систем
Следующим шагом на пути увеличения производительности было решение,
которое принято называть динамическим параллелизмом, а процессоры, реа-
лизующие этот принцип, называют суперскалярными.
Рассмотрим фрагмент программы, написанный на некотором условном языке:
MOV R1, R4
ADD R1, @R0
MOV R5, R6
SUB R5, R7
CLR R6
. . .
Вторая команда этого фрагмента использует в качестве операнда содержимое
ячейки памяти (косвенно-регистровая адресация) и, следовательно, попав на
конвейер, будет "тормозить" его6 на стадии A. В то же время следующие три
команды этого фрагмента никак не связаны с результатами работы второй
команды, выполняют действия только над регистрами и могли бы выпол-
няться еще до завершения предыдущей команды, однако в этом случае при-
шлось бы изменить порядок выполнения команд, определенный программой,
чего конвейер не предусматривает.
Суперскалярная архитектура процессора предполагает, что команды (на
некотором ограниченном участке программы) могут выполняться не только
в порядке их размещения в программе, но и по мере возможности их выпол-
нения независимо от порядка следования. Возможность выполнения опреде-
ляется, во-первых, отсутствием зависимостей от ранее расположенных, но
еще не завершенных команд, во-вторых, наличием свободных ресурсов про-
цессора, необходимых для выполнения команды.
Одним из первых микропроцессоров, реализующих механизм динамического
параллелизма, был процессор Pentium Pro (Pentium II) фирмы Intel (рис. 7.15).
На кристалле процессора размещаются два блока кэш-памяти первого уров-
ня, в одном из которых (кэш-C) размещается программа, а в другом
(кэш-D) — данные.
Устройство выборки/декодирования выбирает очередную команду из кэш-C
(в порядке их размещения в программе), при необходимости заменяет слож-
ные команды на последовательность микрокоманд, снабжает каждую коман-
ду полем признаков (тегом) и помещает в специальным образом организо-
ванную память — пул команд.
6 Здесь мы не обсуждаем возможности кэш-памяти.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 213
Рис. 7.15. Структура процессора Pentium Pro
Устройство диспетчирования постоянно анализирует, с одной стороны, со-
держимое пула команд и выявляет команды, готовые к выполнению на
какой-нибудь стадии, с другой стороны — свободные в данный момент опе-
рационные устройства. При совпадении "желания" (команда завершила пре-
дыдущую стадию и готова к выполнению следующей) и "возможностей"
(свободны соответствующие ресурсы) устройство диспетчирования отправ-
ляет команду на выполнение независимо от порядка поступления команд
в пул. После завершения обработки на очередной стадии команда возвраща-
ется в пул с соответствующей пометкой в поле тега.
Устройство отката размещает результаты выполнения команд по адресам
назначения. Оно просматривает содержимое пула команд, отыскивает ко-
манды, завершившие работу, и извлекает их из пула с размещением результа-
та в строгом соответствии с порядком расположения команд в программе.
Небольшое количество регистров в архитектуре процессоров Intel приводит
к интенсивному использованию каждого из них и, как следствие, к возникно-
вению множества мнимых зависимостей между командами, использующими
один и тот же регистр. Поэтому, чтобы исключить задержку в выполнении
команд из-за мнимых зависимостей, устройство диспетчирования/выпол-
нения работает с дублями регистров, находящимися в пуле команд (одному
регистру может соответствовать несколько дублей).
214 Часть II. Архитектура микропроцессорных систем
Реальный набор регистров контролируется устройством отката, и результаты
выполнения команд отражаются на состоянии вычислительной системы
только после того, как выполненная команда удаляется из пула команд в со-
ответствии с истинным порядком команд в программе.
Таким образом, принятая в Pentium Pro технология динамического выпол-
нения может быть описана как оптимальное выполнение программы, осно-
ванное на предсказании будущих переходов, анализе графа потоков данных
с целью выбора наилучшего порядка исполнения команд и на опережаю-
щем выполнении команд в выбранном оптимальном порядке. Однако сле-
дует иметь в виду, что процессор оптимизирует выполнение только ограни-
ченного участка программы, который в текущий момент располагается
в пуле.
Суперскалярная архитектура предполагает наличие на кристалле процессора
нескольких параллельно работающих операционных устройств (в т. ч. и не-
скольких одинаковых). Так, например, RISC-процессор PowerPC содержит
шесть параллельно работающих исполнительных устройств: блок предсказа-
ния ветвлений, два устройства для выполнения простых целочисленных опе-
раций (сложение, вычитание, сравнение, сдвиги, логические операции), одно
устройство для выполнения сложных целочисленных операций (умножение,
деление), устройство обработки чисел с плавающей запятой и блок обраще-
ния к внешней памяти. При этом обеспечивается одновременное выполнение
четырех команд.
Все операции обработки данных выполняются с регистровой адресацией.
При этом для хранения целочисленных операндов используется блок,
включающий тридцать два 32-разрядных регистра, а для хранения опе-
рандов с плавающей запятой — блок из тридцати двух 64-разрядных ре-
гистров.
Выборка данных из памяти производится только командами пересылки, ко-
торые выполняются блоком обращения к памяти и осуществляют загрузку
данных в регистры или запись их содержимого в память.
При параллельной работе исполнительных устройств возможно их одновре-
менное обращение к одним регистрам. Чтобы избежать ошибок, возникаю-
щих при этом в случае записи нового содержимого до того, как другим уст-
ройством будет считано предыдущее, введены буферные регистры — 12 для
целочисленных регистров и 8 — для регистров с плавающей запятой. Эти
регистры служат для промежуточного хранения операндов, дублируя основ-
ные регистры блоков, используемые при выполнении текущих операций. По-
сле завершения операций производится перезапись полученных результатов
в основные регистры (обратная запись).
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 215
7.5.3. VLIW-архитектура
Для реализации динамического параллелизма в процессорах с традиционной
системой команд и способами компиляции программного кода требуются
весьма сложные схемы организации пула, планировщики, схемы "отката"
и др. Процессоры такой архитектуры имеют несколько операционных блоков
различного, а иногда и одинакового назначения, которые могут работать па-
раллельно, например, 1—2 блока вычисления адресов, 2—3 блока АЛУ для
чисел с фиксированной запятой, блок обработки чисел с плавающей запятой,
блок размещения результата, блок предсказания переходов и др.
Поскольку процессор может планировать и формировать последовательность
выполнения команд на ограниченном (размером пула) участке программы, то
для эффективной загрузки операционных блоков требуются не только слож-
ные и эффективные процедуры планирования, но и некоторое "везение" —
хорошо, если в пул загружены команды, для выполнения которых нужны
различные операционные блоки, а если нет?
Один из путей дальнейшего повышения эффективности подобных систем
лежит в области разработки специальных компиляторов, которые упаковы-
вают несколько простых команд в "очень длинное командное слово"
(VLIW — аббревиатура от Very Long Instruction Word) таким образом, чтобы
в одной "очень длинной команде" можно было использовать все существую-
щие в процессоре операционные блоки. В этом случае командное слово соот-
ветствует набору функциональных устройств.
VLIW-архитектуру можно рассматривать как статическую суперскалярную,
поскольку распараллеливание кода производится на этапе компиляции, а не
динамически во время исполнения, т. е. в машинном коде VLIW присутству-
ет явный параллелизм.
Одним из примеров воплощения идей VLIW может служить предложенная
Intel в содружестве с НР концепция 64-разрядной архитектуры микропроцес-
сора IA-64 (Intel 64-bit Architecture, 64-разрядная архитектура Intel). Для ее
обозначения использована аббревиатура EPIC (Explicitly Parallel Instruction
Computing, вычисления с явным параллелизмом команд).
Процессор, разработанный на базе этой концепции, отличающийся следую-
щими особенностями:
􀂈 большое количество регистров: 128 64-разрядных регистров общего на-
значения (целочисленных), плюс 128 80-разрядных регистров арифметики
плавающей запятой, плюс 64 1-pазpядных предикатных регистра;
􀂈 масштабируемость архитектуры до большого количества функциональ-
ных устройств. Это свойство представители фирм Intel и HP называют
216 Часть II. Архитектура микропроцессорных систем
"наследственно масштабируемым набором команд" (inherently scalable instruction
set);
􀂈 явный параллелизм в машинном коде: поиск зависимостей между коман-
дами производит не процессор, а компилятор;
􀂈 предикация (predication): команды из разных ветвей условного ветвления
снабжаются предикатными полями (полями условий) и запускаются на
выполнение параллельно;
􀂈 загрузка по предположению (speculative loading): данные из медленной
основной памяти загружаются заранее.
Формат команды IA-64 включает код операции, три 7-разрядных поля опе-
рандов — 1 приемник и 2 источника (операндами могут быть только регист-
ры), особые поля для вещественной и целой арифметики, 6-разрядное преди-
катное поле.
Команды IA-64 упаковываются (группируются) компилятором в "связку"
длиною в 128 разрядов. Связка содержит 3 команды и шаблон, в котором
указаны зависимости между командами в связке (можно ли с командой k1
запустить параллельно k2 , или же k2 должна выполниться только после k1 ),
а также между другими связками (можно ли с командой k3 из связки c1 за-
пустить параллельно команду k4 из связки c2 ).
Одна такая связка, состоящая из трех команд, соответствует набору из трех
функциональных устройств процессора. Процессоры IA-64 могут содержать
разное количество таких блоков, оставаясь при этом совместимыми по коду.
Ведь благодаря тому, что в шаблоне указана зависимость и между связками,
процессору с N одинаковыми блоками из трех функциональных устройств
будет соответствовать командное слово из N ×3 команд ( N связок). Таким
образом, обеспечивается масштабируемость IA-64.
Предикация — способ обработки условных ветвлений. Суть этого способа —
компилятор указывает, что обе ветви выполняются на процессоре параллель-
но. Если в исходной программе встречается условное ветвление, то команды
из разных ветвей помечаются различными предикатными регистрами (коман-
ды имеют для этого предикатные поля), далее они выполняются совместно,
но их результаты не записываются, пока значения предикатных регистров не
определены. Когда, наконец, вычисляется значение условия ветвления, пре-
дикатный регистр, соответствующий "правильной" ветви, устанавливается
в 1, а другой — в 0. Перед записью результатов процессор будет проверять
предикатное поле и записывать результаты только тех команд, предикатное
поле которых содержит предикатный регистр, установленный в 1.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 217
Загрузка по предположению — это механизм, который предназначен снизить
простои процессора, связанные с ожиданием выполнения команд загрузки из
относительно медленной основной памяти. Компилятор перемещает команды
загрузки данных из памяти так, чтобы они выполнились как можно раньше.
Следовательно, когда данные из памяти понадобятся какой-либо команде,
процессор не будет простаивать. Перемещенные таким образом команды на-
зываются командами загрузки по предположению и помечаются особым об-
разом. Непосредственно перед командой, использующей загружаемые по
предположению данные, компилятор вставляет команду проверки предполо-
жения.
Выводы
Основная особенность EPIC — распараллеливанием потока команд занима-
ется компилятор, а не процессор.
Достоинства данного подхода:
􀂈 упрощается архитектура процессора; вместо распараллеливающей логики
на EPIC-процессоре можно разместить больше регистров, функциональ-
ных устройств;
􀂈 процессор не тратит время на анализ потока команд на предмет возмож-
ности их параллельного выполнения — эту работу уже выполнил компи-
лятор;
􀂈 возможности процессора по анализу программы во время выполнения ог-
раничены сравнительно небольшим участком программы, тогда как ком-
пилятор способен произвести анализ по всей программе;
􀂈 если некоторая программа должна запускаться многократно, выгоднее
распараллелить ее один раз (при компиляции), а не каждый раз, когда она
исполняется на процессоре.
Недостатки:
􀂈 компилятор производит статический анализ программы, раз и навсегда
планируя вычисления. Однако даже при небольшом изменении начальных
данных путь выполнения программы может сколь угодно сильно изме-
ниться;
􀂈 серьезно увеличивается сложность компиляторов. Значит, увеличится
число ошибок в них, время компиляции;
􀂈 еще более увеличивается сложность отладки, т. к. отлаживать придется
оптимизированный параллельный код;
􀂈 производительность EPIC будет всецело зависеть от качества компилятора;
218 Часть II. Архитектура микропроцессорных систем
􀂈 проблематичным пока видится преемственность программного обеспечения
при переходе на новые поколения микропроцессоров (скомпилированный
код очень сильно "привязан" к конкретной архитектуре процессора).
Тем не менее, представители Intel и HP называют EPIC концепцией следую-
щего поколения и противопоставляют ее CISC и RISC. По мнению Intel, тра-
диционные архитектуры имеют фундаментальные свойства, ограничивающие
производительность.
Производители RISC-процессоров не разделяют подобного пессимизма.
Кстати, в 1980-х годах, когда возникла концепция RISC, прозвучало много
заявлений, что концепция CISC устарела, имеет фундаментальные свойства,
ограничивающие производительность. Но процессоры, причисляемые к CISC
(например, семейство x86), широко используются до сих пор, их производи-
тельность растет.
В действительности же, все эти аббревиатуры — CISC, RISC, VLIW, EPIC —
обозначают только идеализированные концепции. Реальные современные
микропроцессоры трудно подвести исключительно под какой-либо из пере-
численных выше классов. Просто в наиболее совершенных современных
процессорах заложено большое число удачных идей, использующих многие
рассмотренные здесь концепции.
7.6. Однокристальные микроЭВМ
При рассмотрении процессов эволюции современных процессоров и ЭВМ,
прежде всего, обращают внимание на увеличение производительности сис-
темы (быстродействие процессора). Некоторые из путей повышения быстро-
действия были обсуждены в предыдущих разделах, другие, реализующие па-
раллелизм на уровне процессов (мультипроцессоры, векторные, массивно-
параллельные, компьютерные сети [11, 12, 13], нейроматричные процессоры,
и др.), выходят за рамки настоящей книги.
Однако всегда существовали и существуют задачи, для решения которых во-
все не требуется высокое быстродействие процессора и мощная система ко-
манд. На первый план здесь выступают другие характеристики: стоимость,
надежность, малые габариты, способность работать в экстремальных клима-
тических условиях, при значительных перепадах питающего напряжения и на
фоне высокого уровня электромагнитных помех, с автономным питанием.
Для получения таких характеристик растущие возможности интегральной
технологии можно использовать не для увеличения разрядности и вычисли-
тельной мощности процессора, а размещая на кристалле, наряду с простым
(на первых порах — восьмиразрядным) процессором, все другие устройства,
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 219
входящие в состав ЭВМ: регистры, различные типы памяти (на первых по-
рах — небольшого объема), тактовый генератор, порты параллельного и по-
следовательного обмена, различные внешние устройства (таймеры, АЦП
и др.).
При этом получается полностью "самодостаточный" кристалл БИС (СБИС)
однокристальной микроЭВМ (некоторые авторы используют термин микро-
контроллер, учитывая, что основная сфера применения подобных изделий —
управляющие системы, работающие в реальном времени).
В настоящее время многие фирмы (Motorola, Intel, MicroСhip, Zilog и др.)
выпускают широкую номенклатуру подобных однокристальных микроЭВМ
(ОМЭВМ), отличающихся разрядностью, системой команд, типами и объе-
мом памяти, составом и характеристиками внешних устройств. Большинство
ОМЭВМ выпускается с 8-разрядным процессором, но на рынке присутству-
ют и 16- и даже 32-разрядные ОМЭВМ.
Базовые принципы архитектуры ОМЭВМ можно проиллюстрировать на
примере 8-разрядных ОМЭВМ. Далее кратко отметим некоторые особенно-
сти этих контроллеров. Подробнее архитектура ряда ОМЭВМ и примеры их
применения описаны в [4, 12].
Контроллеры разных фирм, несмотря на кажущиеся различия, имеют много
общих черт, определяющих тенденции развития современных ОМЭВМ ма-
лой и средней производительности. Попробуем отметить некоторые из них.
􀂈 Все без исключения контроллеры имеют встроенные тактовые генера-
торы; для запуска большинства из них используют одну из четырех воз-
можных внешних цепей: источник внешних тактовых импульсов, кварце-
вый резонатор, LC-цепь, RC-цепь. Последние две можно использовать
лишь в системах, где точностью временных привязок можно пренебречь.
Большинство контроллеров имеют в своем составе динамические элемен-
ты памяти, что ограничивает допустимую тактовую частоту не только
сверху, но и снизу (обычно — до 1 МГц). ОМЭВМ Motorola используют
на кристалле только статические элементы памяти, что позволяет работать
на произвольно низких системных тактовых частотах. Снижение тактовой
частоты контроллера целесообразно при управлении инерционными объ-
ектами, если необходимо отслеживать достаточно длительные временные
задержки (от долей секунды до десятков секунд).
􀂈 Процессоры большинства ОМЭВМ реализуют классическую ("интеллов-
скую") систему команд, включающую одно- и двухадресные команды
с операциями над ячейками памяти и регистрами, с использованием раз-
нообразных способов адресации (прямая, регистровая, косвенно-регист-
ровая, индексная, непосредственная). Предусмотрен широкий выбор
220 Часть II. Архитектура микропроцессорных систем
команд передачи управления, в т. ч. вызовы подпрограмм. Во многих кон-
троллерах реализовано умножение и деление. Процессоры семейств
MCS-51 и MC68HC11 имеют развитую систему операций с битами.
􀂈 Память большинства ОМЭВМ организована по гарвардской архитектуре,
предполагающей различные адресные пространства для памяти программ
и памяти данных (исключение составляют лишь контроллеры фирмы
Motorola, традиционно поддерживающие единое адресное пространство).
Такое решение снижает риск потери управления при выполнении про-
граммы, но ограничивает возможности по распределению ресурсов памя-
ти системы.
􀂈 На кристалле могут располагаться различные типы памяти: масочное или
однократно программируемое ПЗУ, ППЗУ со стиранием ультрафиолето-
вым излучением, электрически стираемое ППЗУ (флэш-память), ОЗУ (ре-
гистры).
􀂈 Многие параллельные порты контроллеров допускают двунаправленный
обмен, часто возможно независимое программирование линий порта на
ввод или вывод. Допускается выбор типа выхода — обычный ТТЛ-вывод
или вывод с открытым коллектором (стоком). Большинство линий портов
имеют одну или несколько альтернативных функций, выбор которых
осуществляется программно.
􀂈 Важным элементом ОМЭВМ являются системы контроля времени, пред-
ставленные различными счетчиками с управляемыми коэффициентами
пересчета и возможностью выбора источника счетных импульсов: такто-
вый генератор — в режиме таймера и внешний вывод — в режиме счетчи-
ка внешних событий. Более мощные контроллеры имеют в своем составе
таймерные системы, включающие несколько модулей сравнения, автоза-
хвата, ШИМ (широтно-импульсная модуляция) и др.
􀂈 Последовательные каналы включаются обычно в старшие модели се-
мейств. Предусматриваются либо универсальные синхронно-асинхронные
приемопередатчики, программируемые на работу в определенном режиме,
либо отдельные блоки SCI (UART) — асинхронный приемопередатчик
и SPI — синхронный периферийный интерфейс, работающие независимо
друг от друга.
􀂈 Средства работы с аналоговыми сигналами включают в себя компарато-
ры, многоканальные 8-разрядные аналого-цифровые и реже — цифроана-
логовые преобразователи.
􀂈 Подсистема прерываний включает несколько внешних радиальных входов
и большое число внутренних прерываний, которые генерируются в систе-
ме контроля времени, АЦП, последовательных и параллельных каналах.
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 221
В современных микроконтроллерах предусматривается широкий набор спе-
циальных средств, повышающих надежность и эффективность функциониро-
вания систем управления. Прежде всего, это т. н. сторожевой таймер WDT
(Watch-Dog Timer), который предотвращает аварийное зацикливание про-
граммы. В некоторых контроллерах предусматриваются специальные схемы,
следящие за правильной работой тактового генератора. В системах с авто-
номным питанием большое значение имеют средства энергосбережения.
Большинство контроллеров программно можно переводить в специальные
режимы пониженного энергопотребления (в состоянии ожидания) с оста-
новкой основных подсистем (в том чиле иногда и тактового генератора), но
с сохранением контекста задачи. Выход из таких режимов возможен по раз-
решенному прерыванию или по сбросу (часто системный сброс реализуется
как одно из прерываний).
16- и 32-разрядные ОМЭВМ построены обычно по модульному принципу.
На внутрикристальный системный интерфейс могут подключаться процессо-
ры различной вычислительной мощности, различные модули памяти, кон-
троллеры параллельного и последовательного обмена, модули АЦП и ЦАП,
таймерные сопроцессоры и сопроцессоры ввода/вывода. В зависимости от
требований решаемой задачи пользователь может выбрать подходящую кон-
фигурацию кристалла ОМЭВМ. В качестве примера коротко рассмотрим се-
мейство 32-разрядных микроконтроллеров фирмы Motorola.
Отличительной особенностью ОМЭВМ фирмы Motorola является модульная
технология построения многофункциональных устройств на одном кристал-
ле. Определен стандарт внутрикристальной межмодульной шины IMB
и множество наборов системных модулей, из которых собирается ОМЭВМ:
􀂈 процессорные ядра (CPU), включающие 16- и 32-разрядные микропроцес-
соры различной вычислительной мощности, но относящиеся к одному се-
мейству;
􀂈 системные интеграционные модули (SIM), контролирующие внешнюю ши-
ну, запуск, инициализацию и конфигурацию микроконтроллера. Они вклю-
чают в себя тактовый генератор, блок системной конфигурации и защиты,
блок тестирования и интерфейс с внешней шиной. Модули отличаются друг
от друга, главным образом, разрядностью шин адреса и данных;
􀂈 модули памяти, отличающиеся типом и объемом запоминающих уст-
ройств: ОЗУ, ПЗУ(включая однократно программируемое пользователем),
ЭСППЗУ;
􀂈 модули последовательных портов включают различные варианты син-
хронных и асинхронных программируемых контроллеров последователь-
ного обмена. Предусмотрены модули, содержащие несколько различных
интерфейсов;
222 Часть II. Архитектура микропроцессорных систем
􀂈 таймерные системы представлены различными вариантами таймерных
сопроцессоров (TPU). TPU способен независимо от процессора выполнять
как простые, так и сложные таймерные функции, его можно считать от-
дельным специализированным микропроцессором, который осуществляет
две основные операции — проверку на совпадение (от англ. match —
сравнение) и сохранение значения счетчика-таймера в момент изменения
состояния какого-либо входа (от англ. capture — захват) над одним опе-
рандом — временем. Выполнение любой из них называется событием.
Обслуживание событий сопроцессором замещает обработку прерываний
центральным процессором. С помощью двух основных операций TPU
может реализовать значительный набор функций: счет внешних событий,
захват по внешнему входу, сравнение временных интервалов, широтно-
импульсную модуляцию, измерение периода входного сигнала, програм-
мируемую генерацию импульсов и многие другие, программируемые
пользователем. TPU, естественно, имеет собственную систему команд, его
программы хранятся на общей памяти системы или в специализированной
памяти программ TPU;
􀂈 системы аналогового ввода реализованы на различных вариантах АЦП
(ADC), отличающихся разрядностью получаемого кода и способом (а сле-
довательно, и временем) аналого-цифрового преобразования.
На рис. 7.16 приведена структура 32-разрядного микроконтроллера MC68332.
Рис. 7.16. Структура MC68332
Глава 7. Эволюция архитектур микропроцессоров и микроЭВМ 223
Кристалл микроконтроллера содержит следующие модули:
􀂈 CPU32 — 32-разрядный центральный процессор семейства MC68000;
􀂈 RAM — 2 Кбайт ОЗУ с независимым питанием для размещения программ
и данных (напомним, что большинство изделий Motorola поддерживают
архитектуру фон Неймана с единым адресным пространством программ
и данных);
􀂈 QSM — подсистемы последовательного ввода/вывода, включающие уни-
версальный асинхронный приемопередатчик (UART) и дуплексный син-
хронный последовательный интерфейс (SPI);
􀂈 TPU — шестнадцатиканальный таймерный сопроцессор;
􀂈 SIM — системный интеграционный модуль.
Внешняя память может при необходимости подключаться к контроллеру
к шинам адреса A[18:0], данных D[15:0], управления шиной.
Линии порта С могут использоваться для выдачи функционального кода,
идентифицирующего состояние процессора и адресное пространство текуще-
го цикла шины (FC[2:0]), старших разрядов адреса (Ah) в режиме расширен-
ного адресного пространства и сигналов выбора кристалла (CS), разрешаю-
щих работу периферийных устройств по запрограммированным адресам.
Порт F принимает запросы внешних прерываний, линии порта D могут ис-
пользоваться для передачи сигналов последовательных интерфейсов.
Группа линий TP[15:0] — входы/выходы каналов таймерного сопроцессора.
На вход Vstb может подаваться независимое питание для сохранения инфор-
мации в ОЗУ при отключении основного питания.
ЧАСТЬ III
Лабораторный практикум
и курсовое проектирование
Глава 8. Описание программных моделей АЛУ
Глава 9. Описание архитектуры учебной ЭВМ
Глава 10. Лабораторные работы
Глава 11. Курсовая работа
Часть III. Лабораторный 226 практикум и курсовое проектирование
Лабораторный практикум построен на использовании программных моделей.
Часть практикума посвящена изучению функционирования устройств ЭВМ
в рамках тех теоретических положений, которые были изложены в главе 4.
Он же может быть использован для углубленного изучения алгоритмов
арифметических преобразований, обсуждаемых в главе 3. В качестве примера
читателю предлагается поработать с программными моделями арифметико-
логических устройств (АЛУ).
Для изучения общих принципов организации, функционирования и синтеза
устройств ЭВМ удобнее всего оказалось использовать именно арифметико-
логическое устройство. Действительно, функции, реализуемые запоминаю-
щими устройствами, слишком примитивны (чтение, запись, хранение), функ-
ции устройств управления слишком разнообразны и специфичны и требуют
отдельного анализа. Зато функции АЛУ интуитивно понятны (все знают
арифметику, хотя бы и не машинную) и могут быть достаточно сложными,
чтобы позволить в полной мере проиллюстрировать особенности поведения
и построения устройств.
В книге читателю на выбор предлагаются две модели АЛУ со сходными
функциональными возможностями. В моделях реализованы различные фик-
сированные (достаточно универсальные) структуры операционных автоматов
(ОА), на которых можно реализовать большинство алгоритмов арифметиче-
ских и логических преобразований. К каждому из ОА может подключаться
соответствующая модель управляющего автомата.
Использование программных моделей АЛУ позволяет изучать на практике:
􀂈 различные алгоритмы арифметических (и логических) преобразований;
􀂈 методы построения управляющих автоматов с программируемой логикой;
􀂈 организацию взаимодействия ОА и УА в составе АЛУ.
Программные модели ALU-1 и ALU-R отличаются структурами ОА и дизай-
ном. В ALU-1 реализована классическая 4-регистровая структура с единст-
венной магистралью связи между регистрами, а в ALU-R используется струк-
тура с блоком двухпортового регистрового СОЗУ.
Другая часть практикума построена в расчете на изучение взаимодействия
устройств в структуре ЭВМ с помощью программной модели некоторой аб-
страктной учебной ЭВМ, которая программируется на языке ассемблера.
Часто путь современного программиста начинается со знакомства с языком
(языками) высокого уровня и все его общение с компьютером проходит с ис-
пользованием таких языков.
Во многих случаях знание операторов языка высокого уровня, структуры
данных и способов их обработки является достаточным для создания различ-
Часть III. Лабораторный практикум и курсовое проектирование 227
ных полезных приложений. Однако по-настоящему решать проблемы, свя-
занные с управлением различной, особенно нестандартной, аппаратурой (про-
граммирование "по железу") невозможно без знания ассемблера [14]. Не слу-
чайно практически все компиляторы языков высокого уровня содержат
средства связи своих модулей с модулями на ассемблере либо поддерживают
выход на ассемблерный уровень программирования.
Однако проводить начальное обучение программированию на низком уровне
с рассмотрением механизмов взаимодействия устройств на реальном языке,
например х86 на персональной ЭВМ, не всегда удобно. В этом случае между
пользователем и аппаратурой ЭВМ присутствует операционная система
(ОС), которая существенно ограничивает желания пользователя эксперимен-
тировать с аппаратными средствами. Для преодоления этих ограничений не-
обходимо обладать глубокими знаниями как ОС, так и аппаратных средств
ЭВМ.
Предлагаемая для использования программная модель учебной ЭВМ отражает
все основные особенности систем команд и структур современных простых
ЭВМ, включает в себя, помимо процессора и памяти, модели нескольких
типичных внешних устройств. Модель позволяет изучить основы про-
граммирования на низком уровне, вопросы взаимодействия различных уровней
памяти в составе ЭВМ и способы взаимодействия процессора с внешними уст-
ройствами.
Глава 8
Описание программных
моделей АЛУ
Предлагаемые модели АЛУ упрощены по сравнению с реальными АЛУ про-
цессоров. Реальное арифметическо-логическое устройство связано рядом ли-
ний с другим устройством ЭВМ — устройством управления выборкой и вы-
полнением команд. В число этих линий входят линии управления входными
(и, возможно, выходными) регистрами АЛУ, а также линии внешнего управ-
ления управляющим автоматом, которые служат для настройки автомата на
выполнение каждой конкретной операции.
Так как на моделях предполагается выполнять отдельные операции, внешние
связи АЛУ в предлагаемых моделях не описаны.
Программные модели не описывают также механизм тактирования АЛУ. При
стандартном подходе к построению АЛУ каждый узел ОА, имеющий память,
а также регистры УА имеют вход тактирования. На все входы тактирования
поступают периодические прямоугольные импульсные сигналы от одного
устройства, именуемого тактовым генератором. АЛУ проектируются, напри-
мер, так, что выходные сигналы УА меняются скачком при положительных
перепадах тактирующего сигнала, а состояния узлов с памятью ОА меняются
скачком при отрицательных перепадах тактирующего сигнала. В реальных
АЛУ система тактирования может быть сложнее, потому что разработчик
стремится максимально увеличить быстродействие устройства. С точки зре-
ния построения микропрограммы механизм тактирования существенного
значения не имеет.
8.1. Программная модель ALU-1
Программная модель ALU-1 включает в себя две основные части — опера-
ционный автомат 8-разрядного двоичного АЛУ и управляющий автомат
с программируемой логикой (УАПЛ), который может работать как автоном-
но, так и во взаимодействии с ОА АЛУ.
Часть III. Лабораторный 230 практикум и курсовое проектирование
8.1.1. Операционный автомат ALU-1
Структура ОА, предлагаемая в данной книге, почти универсальна и позволя-
ет реализовать большинство известных алгоритмов традиционных арифме-
тических преобразований. Операционный автомат предназначен для реализа-
ции арифметических операций над двоичными числами с фиксированной
запятой в формате 1 байт без знака (диапазон представления чисел — 0...255)
или 1 байт со знаком (диапазон — минус 127...+127) и логических операций
над двоичными векторами длиной в 1 байт.
ОА позволяет микропрограммно реализовать следующие арифметические
операции:
􀂈 сложение без знака;
􀂈 вычитание без знака;
􀂈 сложение/вычитание алгебраические в прямом (ПК), обратном (ОК) или
дополнительном (ДК) коде;
􀂈 умножение (без знака или со знаком);
􀂈 деление (без знака или со знаком) способом с восстановлением остатка
или способом без восстановления остатка,
а также поразрядные логические операции:
􀂈 конъюнкция;
􀂈 дизъюнкция;
􀂈 неравнозначность;
􀂈 инверсия.
Очевидно, возможна реализация и других, более "экзотических" арифметиче-
ских и логических операций.
Результатом всех логических и арифметических операций (кроме умноже-
ния) является байт в формате исходных данных (со знаком или без знака).
Произведение может быть представлено в 8- или 16-разрядном формате.
На рис. 8.1 представлена структура ОА в форме, в которой она выводится на
экран компьютера программой, поддерживающей процесс разработки мик-
ропрограмм управления выполнением операций для АЛУ.
Операционный автомат включает в себя следующие элементы:
􀂈 входные 8-разрядные регистры Ax и Bx , допускающие загрузку исход-
ных операндов;
􀂈 8-разрядные регистры операндов A и B ;
Глава 8. Описание программных моделей АЛУ 231
Рис. 8.1. Операционный автомат ALU-1
􀂈 8-разрядный арифметико-логический блок (АЛБ) с триггерами входного
p0 и выходного p8 переносов (заемов);
􀂈 два 8-разрядных двухвходовых мультиплексора, выбирающих для входов
R и S АЛБ прямые или инверсные значения регистров A и B соответст-
венно;
􀂈 триггер Z , значение которого формируется в соответствии с выражением
Z = p8 ⊕DL
и используется для формирования цифры частного в некоторых алгорит-
мах деления;
􀂈 блок сдвигателя, включающий 8-разрядный реверсивный комбинацион-
ный сдвигатель и два триггера DL и DR, формирующие/принимающие
данные слева и справа;
􀂈 два 8-разрядных регистра результата C и D;
􀂈 демультиплексор, передающий значение вектора F[7:0] с выхода блока
сдвигателя в один из регистров результата C или D;
Часть III. Лабораторный 232 практикум и курсовое проектирование
􀂈 четырехразрядный двоичный счетчик Cч;
􀂈 8-разрядную шину, роль источников на которую могут играть регистры
Ax , Bx , C , D, а приемников — A и/или B .
Регистры сами по себе никаких функциональных преобразований кодов не
осуществляют. Они являются только устройствами запоминания, подключен-
ными к общей шине. Входные и выходные регистры Ax , Bx , C , D обладают
так называемыми трехстабильными выходными устройствами, позволяющими
подключать выходы регистра к шине или отключать их от шины. Если от-
влечься от физических рассуждений, шину можно рассматривать как набор из
восьми переменных (по числу элементов памяти в регистрах), каждая из кото-
рых может принимать три значения: "неактивна", "0" и "1".
В настоящей версии программы ALU-1 возможна только передача в рабочие
регистры A, B содержимого регистров Ax , Bx , C , D, причем за один такт
можно осуществить передачу только из одного регистра-источника в регистр
A, регистр B или в оба регистра вместе. Для этого подается одна из четырех
микроопераций, подключающая к шине выводы соответствующего регистра-
источника y0 , y1 , y26 , y27 , и одна (или обе) микрооперация y2 , y3 , пере-
дающая состояние шины на входы регистров-приемников (см. табл. 8.1).
Ясно, что одновременное подключение к шине двух регистров-источников
приводит к противоречию ("конфликту данных") и недопустимо. Напротив,
одновременная запись информации с шины в разные регистры допустима,
правда, такая необходимость редко встречается при реализации конкретных
алгоритмов.
Арифметико-логический блок (АЛБ) включает комбинационную схему функ-
ционального преобразователя и два элемента памяти: триггеры p0 и p8 . Со-
стояние триггера p0 может быть произвольно установлено с помощью мик-
роопераций y14 и y15 и участвует в микрооперациях сложения (вычитания)
в качестве значения переноса (заема) младшего разряда. Триггер p8 изменя-
ется только микрокомандами арифметических и логических операций АЛБ
и в арифметических микрооперациях принимает значение переноса (заема),
возникающего из старшего разряда, а в логических микрооперациях всегда
устанавливается в "0". Остальные микрооперации сохраняют ранее установ-
ленное значение p8 .
АЛБ реализует ряд бинарных операций над входными 8-разрядными двоичны-
ми векторами R и S и двоичной переменной p0 . Результат операции при-
сваивается 8-разрядному двоичному вектору Q и двоичной переменной p8 .
Значение p8 рассматривается как логическое условие x1 , формируемое ОА.
Глава 8. Описание программных моделей АЛУ 233
Кроме того, в блоке АЛБ формируется значение логического условия
x6 = p8 ⊕DL,
для вывода которого на экран обозревателя необходимо включить специаль-
ную опцию в меню Настройки.
АЛБ реализует следующие бинарные микрооперации:
p8.Q:= R + S + p0 ,
p8.Q := R − S − p0 ,
p8.Q := S − R − p0 ,
0.Q:= S & R,
0.Q:= S ∨ R,
0.Q := S ⊕ R.
Кроме того, АЛБ реализует унарную микрооперацию p8.Q:= p8.R (значение
p8 не меняется).
Блок сдвигателя включает в себя собственно реверсивный сдвигатель на
один разряд и два триггера данных ("слева" DL и "справа" DR). Каждый из
этих триггеров может устанавливаться в произвольные значения микроопе-
рациями ( y28 , y29 , y30 , y31) и принимать значение разрядов, теряемых при
сдвиге вектора Q . Текущие значения триггеров могут рассматриваться как
значения логических условий x2 и x3 .
При правом сдвиге младший разряд Q0 сдвигаемого кода Q[7:0] записывает-
ся в триггер DR, а в старший разряд F7 выходного кода F[7:0] попадает зна-
чение, предварительно установленное в триггере DL, при этом состояние DL
сохраняется. При левом сдвиге — наоборот: DL := Q7, F0 := DR, DR := DR.
Сдвигатель позволяет пропускать входной код на выход и без сдвига, при
этом значения триггеров DL и DR не меняются. Таким образом, блок сдвига-
теля выполняет следующие микрооперации:
􀂈 F[7:0].DR := DL.Q[7:0] — правый сдвиг обыкновенный;
􀂈 DL.F[7:0] := Q[7:0].DR — левый сдвиг обыкновенный;
􀂈 F[7:0].DR := DR.Q[7:0] — правый сдвиг специальный;
􀂈 F[7:0] := Q[6:0].⎤Z — левый сдвиг специальный;
􀂈 F[7:0] := Q[7:0] — передача без сдвига.
Часть III. Лабораторный 234 практикум и курсовое проектирование
Правый специальный сдвиг удобно использовать в микропрограмме умноже-
ния при формировании произведения двойной длины, а левый специальный
сдвиг — в операции деления при формировании очередной цифры частного.
Четырехразрядный двоичный счетчик реализует две микрооперации — на-
чальная установка (в "0000") и инкремент и считает от 0000 до 1000. Счет-
чик формирует два логических условия: x4 истинно, когда состояние счет-
чика равно 1000, а x5 истинно, когда состояние счетчика превышает 0011.
Назначение мультиплексоров и демультиплексора ясно из приведенной на
рис. 8.1 структурной схемы.
Полный список микроопераций, реализуемых элементами структуры ОА
и логических условий, формируемых в ОА, приведен в табл. 8.1 и 8.2.
Таблица 8.1. Микрооперации операционного автомата ALU-1
Y Микрооперация Подробное определение микрооперации
Y0 Shina := Ax Подключение входов регистра Ax к шине данных
Y1 Shina := Bx Подключение входов регистра Bx к шине данных
Y2 A := Shina Запись в регистр A значений из регистра, подключенного
к шине
Y3 B := Shina Запись в регистр B значений из регистра, подключенного
к шине
Y4 R := A Подключение прямых выходов элементов регистра A
к входу R АЛБ. При отсутствии микрокоманды подклю-
чения на вход R подаются все нули
Y5 R := ⎤A Подключение инверсных выходов элементов регистра A
к входу R АЛБ
Y6 S := B Подключение прямых выходов элементов регистра B к
входу S АЛБ. При отсутствии микрокоманды подключе-
ния на вход S подаются все нули
Y7 S := ⎤B Подключение инверсных выходов элементов регистра B
к входу S АЛБ
Y8 p8.Q := R + S + p0 Сложение чисел, представленных кодами на входах R, S
и триггером p0 АЛБ. Содержимое p0 добавляет 0 или 1
к младшему разряду суммы, в p8 формируется перенос
Y9 p8.Q := R – S – p0 Вычитание из числа, представленного на входе R, числа,
представленного на входе S, и числа, представленного
состоянием триггера p0. Содержимое p0 вычитается из
младшего разряда разности, в p8 формируется заем стар-
шего разряда
Глава 8. Описание программных моделей АЛУ 235
Таблица 8.1 (продолжение)
Y Микрооперация Подробное определение микрооперации
Y10 p8.Q := S – R – p0 Вычитание из числа, представленного на входе S, числа,
представленного на входе R, и числа, представленного
состоянием триггера p0. Содержимое p0 вычитается из
младшего разряда разности, в p8 формируется заем стар-
шего разряда
Y11 0.Q := S & R Поразрядная конъюнкция кодов, представленных на вхо-
дах R, S АЛБ. В p8 записывается ноль
Y12 0.Q := S ∨ R Поразрядная дизъюнкция кодов, представленных на вхо-
дах R, S АЛБ. В p8 записывается ноль
Y13 0.Q := S ⊕R Поразрядная неравнозначность кодов, представленных на
входах R, S АЛБ. В p8 записывается ноль
Y14 p0 := 0 Установка триггера p0 в 0
Y15 p0 := 1 Установка триггера p0 в 1
Y16 F := Q Передача кода Q с выхода АЛБ на выход F схемы сдвига
без изменений
Y17 F[7:0].DR :=
DL.Q[7:0]
Сдвиг выходного кода АЛБ Q вправо. Младший разряд Q
записывается в DR. Старший разряд F заполняется со-
держимым DL. DL не изменяется
Y18 DL.F[7:0] :=
Q[7:0].DR
Сдвиг выходного кода АЛБ влево. Старший разряд Q
записывается в DL. Младший разряд F заполняется со-
держимым DR. DR не изменяется
Y19 F[7:0].DR :=
DR.Q[7:0]
Специальный сдвиг выходного кода АЛБ вправо. Млад-
ший разряд Q записывается в DR. Старший разряд F за-
полняется предыдущим значением DR
Y20 F[7:0] := Q[6:0].⎤ Z
Z = p8 ⊕ DL
Сдвиг выходного кода АЛБ влево. Старший разряд Q
теряется, значение DL сохраняется. Младший разряд Q
заполняется цифрой частного (в операциях деления)
Y21 Стоп Останов. Сигнал окончания выполнения операции
Y22 Сч := 0 Присвоение всем разрядам счетчика значения 0. Установ-
ка триггеров признаков (выходы x4, x5 ОА) в ноль
Y23 Сч := Сч + 1 Увеличение счетчика на 1. При кодах счетчика 0100,
0101, 0110, 0111, 1000 x5 = 1. При коде счетчика 1000
x4 = 1. За кодом 1000 следует код 0000 и оба признака
сбрасываются в ноль
Часть III. Лабораторный 236 практикум и курсовое проектирование
Таблица 8.1 (окончание)
Y Микрооперация Подробное определение микрооперации
Y24 C := F Запись выхода схемы сдвига в регистр C
Y25 D := F Запись выхода схемы сдвига в регистр D
Y26 Shina := C Подключение входов регистра C к шине данных
Y27 Shina := D Подключение входов регистра D к шине данных
Y28 DL := 0 Установка триггера DL в 0
Y29 DL := 1 Установка триггера DL в 1
Y30 DR := 0 Установка триггера DR в 0
Y31 DR := 1 Установка триггера DR в 1
Y32 Q := R Передача кода с входа R АЛБ на выход Q АЛБ без изме-
нений
Таблица 8.2. Логические условия, формируемые операционным автоматом ALU-1
x Значение логического условия
x1 p8 — признак переноса/заема
x2 DL — значение триггера "данные слева"
x3 DR — значение триггера "данные справа"
x4 Сч = 8 — признак "счетчик равен 8"
x5 Сч > 3 — признак "счетчик больше 3"
x6 Z := p8 ⊕ DL — признак, по которому можно определить значение цифры
частного в операциях деления
Описанная модель операционного автомата может работать в двух режи-
мах — автономно или под управлением микропрограммы, размещенной
в модели управляющего автомата, о котором речь пойдет далее.
Автономный режим реализуется только пошагово и позволяет проверить
правильность разработанных алгоритмов арифметических и логических пре-
образований на ряде конкретных примеров.
Рассмотрим простой пример реализации арифметической операции в авто-
номном режиме.
Глава 8. Описание программных моделей АЛУ 237
Пример 8.1
Необходимо построить микропрограмму управления процессом сложения
двух семиразрядных двоичных чисел со знаком, заданных в прямом вось-
миразрядном двоичном коде в регистрах Ax и Bx . Результат должен быть
расположен в регистре C . В триггер DL должна быть записана единица
в случае возникновения переполнения и ноль в случае отсутствия перепол-
нения.
Для разработки микропрограммы сложения прямых кодов воспользуемся
ГСА (см. рис. 3.3), убрав две верхние вершины графа (кроме "Начало"), ко-
торые необходимы для анализа типа операции (сложение или вычитание).
Обратим внимание на противоположные способы нумерации разрядов в ОА
(знаковый разряд имеет номер 7) и ГСА (0). Анализ ГСА позволяет выделить
действия в ОА, необходимые для реализации алгоритма:
􀂈 сравнение знаков операндов;
􀂈 сложение или вычитание (прямое или обратное) операндов;
􀂈 анализ знака результата;
􀂈 присваивание результату знака одного из операндов;
􀂈 установка признака переполнения.
Анализ структуры ОА (рис. 8.1) и списка микроопераций (табл. 8.1) позволя-
ет разработать микропрограмму сложения, соответствующую выбранному
алгоритму. Форма представления микропрограммы может быть разной (см.,
например, рис. 4.5, 4.14). Здесь для удобства размещения комментариев вос-
пользуемся языком функционального микропрограммирования.
При работе с ОА в автономном режиме пользователь играет роль управ-
ляющего автомата, поэтому сам определяет путь перехода в микрооперациях
передачи управления, причем принимать решения по выбору пути реализа-
ции микропрограммы он может только по текущим значениям логических
условий x1 , ..., x6 . Такие действия выделены в микропрограмме табл. 8.3
квадратными скобками.
Таблица 8.3. Реализация микропрограммы сложения в автономном режиме
№ Метка Микрокоманда Комментарий
1 y0, y2 Ввод первого слагаемого A
2 y1, y3 Ввод второго слагаемого B
Часть III. Лабораторный 238 практикум и курсовое проектирование
Таблица 8.3 (окончание)
№ Метка Микрокоманда Комментарий
3 y4, y6, y13, y18 Формируем вектор неравнозначности Q = A
⊕ B и сдвигаем влево, при этом значение
неравнозначности знаковых разрядов
попадает в DL, а значит x2 = a7 ⊕ b7
4 [if x2 then L1] Проверяем равенство знаков операндов, пе-
реход на метку L1, если знаки операндов
разные
5 y4, y6, y8, y18, y24 Сложение и сдвиг влево; при этом в DL —
сумма знаковых разрядов, а в регистре С —
сумма модулей операндов, сдвинутая на
один разряд влево
6 [if x2 then END] Переполнение, если c7 = 1 (см. пояснение
к формуле 3.16)
7 L2: y4, y32, y18 Копирование знака a7 в DL
8 L3: y26, y2 Возвращение сдвинутого результата в ре-
гистр A
9 y4, y32, y17, y24 Смещение модуля результата вправо и при-
сваивание ему знака операнда, записанного
в DL
10 y28 Сброс флага переполнения (триггера DL)
11 [go to END] Завершение операции
12 L1: y4, y6, y9, y18, y24 Вычитание A – B и сдвиг влево
13 [if x2 then L2] Если c7 = 1, то результату присваивается
знак A
14 y4, y6, y10, y18, y24 Вычитание B – A и сдвиг влево
15 y6, y12, y18 Копирование знака b7 в DL
16 [go to L3] Переход на присвоение знака результату
17 END: y21 Завершение операции
На модели ОА ALU-1 можно проверить правильность разработанной мик-
ропрограммы на нескольких примерах.
Подробно рассмотрим пример сложения двух чисел: (+11) + (–7) = +4 по
приведенной выше микропрограмме. Действия с моделью ОА представим
Глава 8. Описание программных моделей АЛУ 239
в виде табл. 8.4 (состояния элементов памяти отражены в тактах их воз-
можного изменения).
Таблица 8.4. Состояние операционного автомата
в процессе выполнения микропрограммы
№
МК Микрокоманда Ax Bx A B C
DL
(x2)
00001011 10000111
1 y0, y2 00001011
2 y1, y3 10000111
3 y4, y6, y13, y18 1
4 Анализируем x2
12 y4, y6, y9, y18, y24 00001000 1
13 Анализируем x2
7 y4, y32, y18 0
8 y26, y2 00001000
9 y4, y32, y17, y24 00000100
10 y28 0
11 Переход на END
17 y21 00000100 0
Аналогично можно рассмотреть примеры с другими сочетаниями знаков
и модулей слагаемых.
8.1.2. Управляющий автомат
с программируемой логикой
Предлагаемая модель УА ориентирована прежде всего на управление опи-
санным выше ОА, но может реализовать и любую "абстрактную" микропро-
грамму (с учетом приведенных далее ограничений).
УАПЛ реализован как автомат с естественной адресацией и смешанным спо-
собом кодирования поля микроопераций, использующий единственный фор-
мат микрокоманды. Структурная схема моделируемого УА аналогична при-
веденной на рис. 4.16. Отличия — в количестве микроопераций и их полей,
в числе поступающих из ОА логических условий.
Часть III. Лабораторный 240 практикум и курсовое проектирование
Количественные характеристики УА и формат микрокоманды выбирались
прежде всего исходя из потребностей управления ОА ALU-1. Анализ струк-
туры ОА и реализуемых на ней микропрограмм показывает, что можно огра-
ничиться пятью микрооперациями в микрокоманде. Действительно, глядя на
рис. 8.1, можно отметить, что для выполнения любой бинарной микрокоман-
ды (например, сложения двоичных векторов) необходимо одновременно:
1. Выбрать первый операнд R.
2. Выбрать второй операнд S.
3. Указать операцию в АЛБ.
4. Указать действие в блоке сдвигателя.
5. Определить регистр назначения для результата.
Таким образом, все множество микроопераций ОА { } Y = y0 , ..., y32 следует
разбить на пять подмножеств (см. разд. 4.4.2) с учетом анализа типичных
микропрограмм арифметико-логических операций. Такая работа была проде-
лана при проектировании модели, и ее результат предлагается как кодировка
микроопераций По умолчанию (рис. 8.2).
Рис. 8.2. Кодировка микроопераций и логических условий По умолчанию
Практика показывает, что большинство алгоритмов арифметико-логических
преобразований допускает реализацию в структуре ОА ALU-1 с предложен-
ным разбиением и кодировкой микроопераций. Однако пользователь может
Глава 8. Описание программных моделей АЛУ 241
произвольно менять разбиение микроопераций на подмножества и кодировку
(установить опцию Разрешить правку в меню Настройки), нельзя лишь
увеличивать количество подмножеств, а число микроопераций в одном под-
множестве на может превышать 7. Понятно, что эти ограничения связаны с
жестко определенным форматом микрокоманды.
Формат микрокоманды (рис. 8.3) включает в себя пять трехразрядных полей
Y1 , Y2 , ..., Y5 кодирования микроопераций, трехразрядное поле X номера
логического условия (ОА генерирует 6 логических условий и еще два кода
используются для кодирования констант "0" и "1"), одноразрядное поле i
инверсии логического условия и семиразрядное поле адреса перехода. Оче-
видно, максимальная длина микропрограммы в этом случае может составлять
27 = 128 микрокоманд.
Рис. 8.3. Формат микрокоманды
В разд. "Пример проектирования УАПЛ" главы 4 приведен пример проекти-
рования управляющего автомата с программируемой логикой по исходной
микропрограмме. Процесс проектирования включает следующие этапы:
􀂈 определение формата микрокоманды (разбиение множества микроопе-
раций на подмножества, кодирование микроопераций и логических
условий);
􀂈 формирование последовательности управляющих слов в ПЗУ МК, реали-
зующих заданную микропрограмму.
Очевидно, в случае использования для построения УАПЛ программной мо-
дели УА ALU-1 первый этап выполнять не придется, если предложенное "по
умолчанию" разбиение позволяет реализовать заданную микропрограмму.
Второй этап можно выполнять "вручную" или с помощью встроенного мик-
роассемблера.
Работа "вручную" весьма трудоемка и приводит к значительному числу оши-
бок, но на начальном этапе небольшую микропрограмму следует, на мой
взгляд, выполнить именно этим способом, чтобы получить полное представ-
ление о структуре микрокомандных слов и способах переходов по микропро-
грамме. Процесс "ручного" микропрограммирования подробно описан
в примере в разд. "Пример проектирования УАПЛ" главы 4.
Часть III. Лабораторный 242 практикум и курсовое проектирование
Использование микроассемблера позволит значительно увеличить ско-
рость и надежность подготовки микропрограмм. Для работы с микроас-
семблером достаточно открыть пункт меню Компилятор в окне Управ-
ляющий автомат и в открывшемся окне текстового редактора
Компилятор набрать текст микропрограммы, состоящий из последова-
тельности микрокоманд. Формат микрокоманды (см. рис. 8.3) определяет
структуру записи на языке микроассемблера. Определим элементы записи
микрокоманды следующим образом:
<строка> ::= [<метка>][<микрокоманда>][#<комментарий>]
<микрокоманда> ::= [<последовательность микроопераций>][; <логическое
условие>,<инверсия логического условия>,<метка>]
<последовательность микроопераций> ::= <микрооперация> [,<микрооперация>,
<микрооперация> ...] (не более 5)
<микрооперация> ∈ {yi}, i ∈ {0 .. 32}
<логическое условие> ∈ {xj, 0, 1}, j ∈ {1 .. 6}
<инверсия логического условия> ∈ { 0, 1}
<метка>::= <идентификатор>
При написании микропрограммы для последующей компиляции в среде
ALU-1 необходимо соблюдать следующие правила:
􀂈 в одной строке должно располагаться не более одной микрокоманды, воз-
можно, помеченной;
􀂈 идентификаторы меток перехода, микроопераций, логических условий
должны существовать;
􀂈 идентификаторы меток не должны дублироваться.
Следующие знаки используются для разделения полей в микропрограмме:
􀂈 , — разделяет микрооперации в последовательности микроопераций;
􀂈 ; — отделяет поле переадресации от поля микроопераций;
􀂈 : — отделяет метку от следующей за ней микрокоманды;
􀂈 # — отделяет комментарий (до конца строки);
􀂈 +n — директива сдвига команды на n адресов (n задается десятичным чис-
лом).
Примерами микрокоманд могут служить следующие строки:
y26, y2
y4, y6, y8, y16, y25
y28; 1, 0, L2 # сброс DL и безусловный переход на метку L2
#(в качестве логического условия используется константа "1")
Глава 8. Описание программных моделей АЛУ 243
y28; x1, 0, L2 # сброс DL и переход на метку L2 при x1 = 1
y4, y32, y18; x2, 1, L3 # здесь передача управления происходит
# при значении x2 = 0, т. к. флаг инверсии логического условия равен 1
L3: y21 # помеченная микрокоманда
Если микрокоманда содержит только последовательность микроопераций, то
компилятор добавляет по умолчанию поля переадресации ;000,0,0000000,
что соответствует тождественно ложному условию без инверсии, т. е. осуще-
ствляется переход к адресу, на единицу большему текущего.
При работе с ОА под управлением УАПЛ необходимо предварительно загру-
зить в память модели управляющего автомата код микропрограммы. Рас-
смотрим эти действия на алгоритме примера 8.1. В табл. 8.3 каждая строка
определяет действие в ОА или выбор адреса следующей микрокоманды.
Формат микрокоманды УА (см. рис. 8.3) содержит как поля микроопераций,
так и поля переадресации. Поэтому в каждой микрокоманде возможно вы-
полнить действие в ОА и выбрать адрес следующей микрокоманды. Таким
образом, две последовательные строки табл. 8.3, первая из которых опреде-
ляет микрооперации, а вторая — переход, реализуются одной микрокоман-
дой УА. Если после операционной микрокоманды следует другая операци-
онная, то осуществляется безусловный переход на нее.
Рис. 8.4. Текст микропрограммы
Часть III. Лабораторный 244 практикум и курсовое проектирование
Рис. 8.5. Код микропрограммы
Учитывая эти правила и приведенный ранее синтаксис, можно записать текст
микропрограммы сложения на микроассемблере (рис. 8.4). После компиля-
ции память микропрограмм УА будет иметь вид, показанный на рис. 8.5 —
микропрограмма, готовая к исполнению.
Теперь можно перейти в окно операционного автомата, установить опцию
Настройки | Управление | Управляющий автомат и выполнять микропро-
грамму сложения с различными операндами в пошаговом или автоматиче-
ском режиме.
8.2. Программная модель ALU-R
Программная модель ALU-R отличается от ALU-1 прежде всего организацией
управления в операционном автомате. Вместо набора микроопераций, подавае-
мых в конкретные точки управления, в ОА ALU-R каждое поле микрокоманды
управляет конкретным узлом структуры: АЛБ, счетчиком, сдвигателем...
Кроме того, в ОА вместо пары входных и пары выходных регистров операн-
дов, предусмотрен блок двухпортового ОЗУ — 8 регистров общего назначе-
ния, каждый из которых может быть как источником операнда, так и прием-
ником результата.
Глава 8. Описание программных моделей АЛУ 245
8.2.1. Операционный автомат ALU-R
Структура ОА показана на рис. 8.6. Он включает в себя:
􀂈 блок из восьми 8-разрядных регистров общего назначения R0, ..., R7, каж-
дый из которых может являться регистром исходных операндов A и B ,
а также регистром результата F ;
􀂈 два блока инверторов для операндов A и B , позволяющие сформировать
на выходах, подключенных ко входам АЛБ R и S соответственно:
• значение входного 8-разрядного двоичного вектора без изменений;
• инверсию всех разрядов входного двоичного вектора;
• константу 00000000;
• инверсию всех разрядов входного вектора, кроме старшего (знакового),
который передается на выход без изменений;
Рис. 8.6. Операционный автомат ALU-R
􀂈 8-разрядный арифметико-логический блок (АЛБ) с триггером входного
(ТрP0) и выходного (ТрP8) переносов, реализующий шесть бинарных
арифметических и логических операций и пересылки на выход значения
одного из входов R или S без изменений;
Часть III. Лабораторный 246 практикум и курсовое проектирование
􀂈 блок сдвигателя с триггерами данных "слева" (DL) и "справа" (DR), по-
зволяющий передавать информацию без изменений или осуществлять
различные варианты правых и левых сдвигов на один разряд;
􀂈 трехразрядный двоичный реверсивный счетчик;
􀂈 четырехразрядный регистр признаков результата, формирующий по ре-
зультату очередной операции следующие флаги:
• C — перенос из старшего разряда (совпадает со значением ТрP8);
• N — отрицательный результат (совпадает со значением F7);
• Z — нулевой результат;
• OV — арифметическое переполнение (формируется только специаль-
ной микрокомандой).
Структура операционного автомата предусматривает возможность редакти-
рования состояния следующих элементов:
􀂈 любых разрядов регистров общего назначения R0, ..., R7;
􀂈 триггеров данных сдвигателя DL и DR;
􀂈 триггера входного переноса/заема ТрP0;
􀂈 разряды микрокоманды.
Редактирование осуществляется щелчком мыши по соответствующей двоич-
ной цифре, при этом она инвертируется.
В правой части окна обозревателя ОА (см. рис. 8.6) размещены органы
управления ОА и справочная информация.
Органы управления включают в себя:
􀂈 флажки: Подключить УА, Десятичный ввод, Со знаком, Десятичный
вывод;
􀂈 кнопки: Шаг, Сброс, Авто, Стоп;
􀂈 микрокоманду, разряды которой доступны для редактирования.
Если флажок Подключить УА сброшен, то ОА работает под управлением
кода, установленного в поле микрокоманды (автономный режим). О работе
в автоматическом режиме под управлением УА см. в разд. 8.2.2.
Установка флажка Десятичный ввод открывает две строки ввода — "крас-
ную" и "зеленую", соответствующие регистрам входных операндов A и B ,
адреса которых указаны в микрокоманде (в блоке регистров соответствую-
щие регистры и в микрокоманде соответствующие поля помечены теми же
цветами). Строки ввода отображают текущие значения содержимого соот-
ветствующих регистров в десятичном коде и допускают редактирование,
Глава 8. Описание программных моделей АЛУ 247
причем если установлен флажок Со знаком, то старший разряд регистров
интерпретируется как знаковый (диапазон вводимых чисел — –127...+127),
иначе — диапазон 0...255. Всякое изменение состояния разрядов регистра
отражается в строке ввода, и наоборот, причем попытка ввести в строку вво-
да десятичное число, модуль которого выходит за пределы диапазона допус-
тимых значений, приводит к вводу числа с максимальным допустимым
модулем.
Установка флага Десятичный вывод открывает "серую" строку вывода, ко-
торая отображает десятичное представление регистра, адрес которого указан
в поле F микрокоманды.
Кнопка Шаг в автономном режиме запускает выполнение одной микроко-
манды, код которой установлен на панели управления ОА.
Кнопка Сброс устанавливает в "0" все элементы памяти ОА, включая регист-
ры общего назначения, но не меняет установок на панели управления.
Кнопки Авто и Стоп работают только в режиме под управлением УА.
Операционный автомат управляется с помощью микрокоманд, форматы
которых представлены на рис. 8.7. Микрокоманду рис. 8.7, а будем счи-
тать "основной".
а
б
Рис. 8.7. Форматы микрокоманд ОА ALU-R
Поля "основной" микрокоманды (рис. 8.7, а) имеют следующее назначение
и кодировку:
􀂈 A — адрес регистра первого операнда ("красный");
􀂈 B — адрес регистра второго операнда ("зеленый");
􀂈 F — адрес регистра результата ("серый");
Примечание
Допускаются любые сочетания этих значений (в т. ч. A = B или A = F или даже
A = B = F).
Часть III. Лабораторный 248 практикум и курсовое проектирование
􀂈 !a — код управления блоком инверторов для первого операнда:
• 00 — передает без изменений;
• 01 — инвертируются все восемь разрядов;
• 10 — на выходе формируется константа 0;
• 11 — инвертируются все разряды, кроме старшего;
􀂈 !b — то же для блока инверторов второго операнда;
􀂈 АЛБ — код, задающий операцию в АЛБ:
• 000 — p8.Q := R + S + p0 — сложение;
• 001 — p8.Q := R − S − p0 — вычитание;
• 010 — p8.Q := S − R − p0 — обратное вычитание;
• 011 — 0.Q := S & R — конъюнкция;
• 100 — 0.Q:= S ∨ R — дизъюнкция;
• 101 — 0.Q:= R⊕S — неравнозначность;
• 110 — 0.Q:= R — передача первого операнда без изменений;
• 111 — 0.Q:= S — передача второго операнда без изменений;
􀂈 СД — код, задающий операцию в блоке сдвигателя:
• 000 — F := Q — передача без сдвига;
• 001 — DL.F[7:0] := Q[7:0].DR — левый сдвиг обыкновенный;
• 010 — F[7:0].DR := DL.Q[7:0] — правый сдвиг обыкновенный;
• 011 — F[7:0].DR := DR.Q[7:0] — правый сдвиг, но в старший разряд
Q[7] помещается значение не DL, а DR (можно использовать в опера-
циях умножения для формирования произведения двойной длины);
• 100 — F[7:0] := Q[7:0].( p8 ⊕ DL ) — левый сдвиг с размещением в млад-
шем разряде Q[0] значения очередной цифры частного (можно исполь-
зовать в операциях деления);
• 101 — не используется;
• 110 — не используется;
• 111 — переключение на другой формат микрокоманды;
􀂈 Сч — код, задающий операцию в счетчике:
• 00 — Сч := Сч — сохранить состояние счетчика неизменным;
• 01 — Сч := Сч + 1 — инкремент счетчика;
• 10 — Сч := Сч – 1 — декремент счетчика;
• 11 — Сч := 000 — сброс счетчика в 0.
Глава 8. Описание программных моделей АЛУ 249
Чтобы не вводить в микрокоманду дополнительные поля, которые относи-
тельно редко используются, удобнее оказалось предусмотреть второй ("до-
полнительный") формат (рис. 8.7, б), для переключения на который исполь-
зуется один из свободных кодов (111) поля СД управления сдвигом.
Микрокоманда этого формата предназначена для принудительного измене-
ния состояния триггеров блока сдвигателя DL и DR, флага переполнения OV
и триггера входного переноса p0 . Четыре двухразрядных поля OV, p8, DL,
DR кодируются одинаковым образом:
􀂈 00 — сохранить состояние триггера неизменным;
􀂈 01 — установить триггер в "1";
􀂈 10 — сбросить триггер в "0";
􀂈 11 — не используется.
Поле СД в такой микрокоманде должно содержать код 111, при этом сохра-
няется возможность модифицировать состояние счетчика так же, как и в "ос-
новной" микрокоманде.
Теперь можно рассмотреть простой пример реализации арифметической опе-
рации на структуре ОА ALU-R в автономном режиме.
Пример 8.2
Попробуем реализовать алгоритм, уже обсужденный в примере 8.1. Будем
считать, что коды слагаемых размещены в регистрах R0 и R1, результат
следует поместить в регистр R2, а признак переполнения сформировать во
флаге OV.
Регистр R3 будем использовать как рабочий. Дело в том, что любая микро-
команда формата рис. 8.7, а обязательно заносит код с выхода сдвигателя
в регистр, номер которого указан в ее поле F, даже если этот результат не
требуется сохранять по логике реализуемого алгоритма. Поэтому, чтобы не
потерять значений операндов и результата, будем сбрасывать такие ненуж-
ные коды в регистр R3.
При описании микрокоманд будем использовать не двоичные коды полей,
а мнемонические обозначения, принятые в модели ALU-R. Символ "х" озна-
чает безразличное значение поля в данной микрокоманде (табл. 8.5).
Анализ значений логических условий и выбор следующей микрокоманды
в автономном режиме возлагается на оператора. Эти действия заключены
в тексте микропрограммы в квадратные скобки.
Часть III. Лабораторный 250 практикум и курсовое проектирование
Таблица 8.5. Микропрограмма алгебраического сложения для ALU-R
Метка A B F !A !B АЛБ СД Сч Комментарии
R0 R1 R3 A B XOR L x Анализ равенства знаков
[if x2 then L1] Переход, если знаки разные
R0 R1 R2 A B ADD L x Сложение и сдвиг влево
[if x2 then LOV] Если DL = 1, то перепол-
нение
L2: R0 x R3 A x R L x Знак А сдвигаем в DL
L3: R2 x R2 A x R R x Присваиваем DL знаку
результата
10 00 00 00
11
1
x
Микрокоманда дополни-
тельного формата (см.
рис. 8.7, б) OV := 0
[go to END]
L1: R0 R1 R2 A B SUBA L x Прямое вычитание и сдвиг
[if x2 then L2] Если x2 = 1, то |A| > |B|
R1 R0 R2 A B SUBA L x Обратное вычитание и
сдвиг *
R1 x R3 A x R L x Знак B сдвигаем в DL
[go to L3]
LOV: 01 00 00 00
11
1
x Микрокоманда дополни-
тельного формата OV := 1
END:
Примечание. * — можно использовать микрокоманду | R0 | R1 | R2 | A | B | SUBB | L | x |.
8.2.2. Управляющий автомат ALU-R
Управляющий автомат реализован как автомат с программируемой логикой.
Форматы микрокоманд УА соответствуют рис. 8.7 с добавлением группы по-
лей переадресации (рис. 8.8).
Рис. 8.8. Фрагмент формата микрокоманд УА ALU-R
Глава 8. Описание программных моделей АЛУ 251
Добавленные поля имеют следующее назначение:
􀂈 x — номер проверяемого логического условия x1—x5 (код 000 соответ-
ствует константе "0", код 111 — константе "1");
􀂈 i — признак инверсии логического условия. При i = 0 , переход на ука-
занный адрес осуществляется по истинному значению логического усло-
вия, при i = 1 — по ложному;
􀂈 Адрес — задает адрес, на который осуществляется переход при выполне-
нии логического условия. Если условие не выполнено, то УА переходит
к выполнению следующей по порядку микрокоманды.
На рис. 8.9 представлено окно обозревателя управляющего автомата. В левой
части окна показано содержимое памяти микропрограмм, в правой — органы
управления.
Рис. 8.9. Управляющий автомат ALU-R
Память микропрограмм может хранить до 128 32-разрядных микрокоманд,
код которых формируется с помощью наборного поля, расположенного над
окном памяти. Над каждым полем микрокоманды расположен список допус-
тимых значений этого поля (в форме мнемоник). Щелчок мышью по выбран-
ной мнемонике генерирует соответствующий двоичный код в поле текущей
микрокоманды. Над полем Адрес располагается строка ввода/счетчик, в ко-
торой можно установить адрес перехода в десятичном коде.
Часть III. Лабораторный 252 практикум и курсовое проектирование
Если для поля Сдв выбрать мнемонику С (код 111), то набор мнемоник из-
менится в соответствии с форматом "дополнительной" микрокоманды (см.
рис. 8.7, б).
Такой способ набора микрокоманд исключает синтаксические ошибки, по-
скольку выбор мнемоники порождает только допустимые коды. Однако при
желании пользователь может и непосредственно редактировать двоичный
код микрокоманды.
В правой части окна обозревателя УА (см. рис. 8.9) размещены органы
управления УА, включающие в себя:
􀂈 флажки: Подключить к ОА, Удаление, Добавление;
􀂈 строка ввода текущего адреса;
􀂈 таблица ввода значений логических условий;
􀂈 кнопки: Очистить ПЗУ МК, Сохранить, Сохранить мнемоники, Загру-
зить, Шаг, Сброс, Авто, Стоп.
Флажок Подключить к ОА является копией флажка Подключить УА в ок-
не ОА — при установке/сбросе одного из них то же значение принимает
и другой.
Вводить новые микрокоманды описанным ранее способом можно только при
установленном флажке Добавление.
Установка флажка Удаление разрешает процедуру удаления строк (микро-
команд) по нажатию клавиши <Delete>.
Строка ввода Текущий адрес позволяет установить адрес ячейки, в которой
можно выполнять редактирование или, начиная с которой, можно запускать
выполнение микропрограммы.
Таблица Логические условия позволяет установить в автономном режиме
УА значения логических условий независимо от состояния ОА. Это может
быть полезно при отладке микропрограммы. В режиме совместной работы
ОА и УА значения логических условий определяются состоянием ОА.
Кнопка Очистить ПЗУ МК сбрасывает содержимое памяти микропрограмм.
Кнопки Сохранить и Сохранить мнемоники открывают стандартный диа-
лог сохранения файла. По кнопке Сохранить в текстовом файле сохраняются
двоичные коды записанных в памяти микрокоманд. Такой файл можно потом
загрузить в память микропрограмм по кнопке Загрузить. По кнопке Сохра-
нить мнемоники в текстовом файле сохраняются мнемокоды микрокоманд.
Попытка загрузить такой файл в память УА блокируется с выдачей сообще-
ния об ошибке. Такие файлы можно использовать только для формирования
отчетов.
Глава 8. Описание программных моделей АЛУ 253
Кнопки Шаг, Сброс, Авто и Стоп в режиме совместной работы УА и ОА
дублируют соответствующие кнопки окна ОА. Кнопка Авто запускает вы-
полнение микропрограммы с текущего адреса, а кнопка Стоп останавливает
процесс выполнения микропрограммы.
В автономном режиме Шаг обеспечивает выполнение одной микрокоманды
по текущему адресу. В этом режиме фактически можно лишь отследить пра-
вильность переходов по микропрограмме в соответствии с установленными
значениями логических условий.
Кнопка Сброс в автономном режиме устанавливает в 0 значение текущего
адреса.
Для редактирования кода микропрограммы в памяти предназначены еще две
кнопки, расположенные непосредственно над полем адреса микрокоман-
ды — стрелка вверх и стрелка вниз.
Кнопка сдвигает в памяти блок микрокоманд, начиная с текущего адреса,
на одну позицию в сторону больших адресов, при этом в позиции текущего
адреса появляется пустая ячейка. Последовательное n-кратное нажатие кноп-
ки приводит к появлению блока из n свободных ячеек в позиции выше теку-
щего адреса. Свободные ячейки можно заполнить произвольными микро-
командами.
Нажатие кнопки приводит к перемещению блока микрокоманд, начиная
с текущего адреса, на одну позицию вверх (в сторону меньших адресов). При
этом содержимое ячейки, расположенной выше текущей, теряется. Таким
образом можно удалять микрокоманды из микропрограммы.
Каждое перемещение микрокоманд по кнопкам и сопровождается кор-
рекцией адресов переходов на перемещенные микрокоманды, так что логика
переходов в микропрограмме не нарушается.
В качестве примера рассмотрим размещение в памяти микропрограмм УА
микропрограммы алгебраического сложения, приведенной в табл. 8.5
(рис. 8.10).
Каждой строке табл. 8.5 соответствует либо операционная часть микро-
команды, либо информация о проверяемом логическом условии и адрес
перехода. В автономном режиме проверка значения указанного условия
и выбор следующей микрокоманды выполняются пользователем "вруч-
ную". При подготовке микропрограммы для загрузки в память УА нужно
включать информацию о выборе следующей микрокоманды в поля пере-
адресации предыдущей команды.
Часть III. Лабораторный 254 практикум и курсовое проектирование
Первая и вторая строки табл. 8.5 порождают следующую микрокоманду:
R0(000) | R1(001) | R3(011) | A(00) | B(00) | XOR(101) | L(001) | x(00)
||X2(010)|0|???
которая записывается в ячейку с адресом 0 памяти микропрограмм УА. Пока
микрокоманда, помеченная в табл. 8.5 меткой L1, не получит своего адреса, мы
не можем заполнить поле адреса первой микрокоманды, поэтому пока в этом
поле неопределенное значение. (Конечно, можно заранее "на бумаге" распи-
сать все адреса микрокоманд и вводить адреса переходов на первом проходе.)
Действуя подобным образом и далее, получаем закодированную микропро-
грамму сложения, представленную на рис. 8.10.
Особо следует сказать о последней микрокоманде, которой нет соответствия
в табл. 8.5. Необходимость ее появления обусловлена тем, что в данной реализации
УА отсутствует специальная микрокоманда завершения микропрограммы, и мо-
дель УА рассматривает переход к следующему адресу, если в нем не содержится
микрокоманда (пустая строка), как завершение микропрограммы. Но если на пус-
тую ячейку указывает адрес перехода, это интерпретируется моделью как ошибка.
В нашем случае микрокоманда по адресу 4 (0000100) ссылается на строку 9
(0001001), тогда по адресу 9 приходится размещать какую-либо "фиктивную"
микрокоманду, например, копирующую содержимое регистра R2 в R2. Пере-
ход к следующей (0001010) пустой строке интерпретируется как завершение
микропрограммы.
Рис. 8.10. Микропрограмма алгебраического сложения
Глава 9
Описание архитектуры
учебной ЭВМ
Современные процессоры и операционные системы — не слишком благо-
приятная среда для начального этапа изучения архитектуры ЭВМ.
Одним из решений этой проблемы может быть создание программных моде-
лей учебных ЭВМ, которые, с одной стороны, достаточно просты, чтобы
обучаемый мог освоить базовые понятия архитектуры (система команд, ко-
мандный цикл, способы адресации, уровни памяти, способы взаимодействия
процессора с памятью и внешними устройствами), с другой стороны — архи-
тектурные особенности модели должны соответствовать тенденциям разви-
тия современных ЭВМ.
Программная модель позволяет реализовать доступ к различным элементам
ЭВМ, обеспечивая удобство и наглядность. С другой стороны, модель позво-
ляет игнорировать те особенности работы реальной ЭВМ, которые на данном
уровне рассмотрения не являются существенными.
Далее приводится описание программной модели учебной ЭВМ1, предназна-
ченной для начальных этапов изучения архитектуры (в т. ч. на младших курсах
вуза и даже в школе). Именно этим объясняется использование в модели деся-
тичной системы счисления для кодирования команд и представления данных.
9.1. Структура ЭВМ
Моделируемая ЭВМ включает процессор, оперативную (ОЗУ) и сверхопера-
тивную память, устройство ввода (УВв) и устройство вывода (УВыв). Процес-
сор, в свою очередь, состоит из центрального устройства управления (УУ),
1 Программная модель учебной ЭВМ находится на компакт-диске, прилагаемом к книге.
Часть III. Лабораторный 256 практикум и курсовое проектирование
арифметического устройства (АУ) и системных регистров (CR, PC, SP
и др.). Структурная схема ЭВМ показана на рис. 9.1.
В ячейках ОЗУ хранятся команды и данные. Емкость ОЗУ составляет
1000 ячеек. По сигналу MWr выполняется запись содержимого регистра
данных (MDR) в ячейку памяти с адресом, указанным в регистре адреса
(MAR). По сигналу MRd происходит считывание — содержимое ячейки памяти
с адресом, находящимся в MAR, передается в MDR.
Сверхоперативная память с прямой адресацией содержит десять регистров
общего назначения R0—R9. Доступ к ним осуществляется (аналогично дос-
тупу к ОЗУ) через регистры RAR и RDR.
АУ осуществляет выполнение одной из арифметических операций, опреде-
ляемой кодом операции (СОР), над содержимым аккумулятора (Асс) и реги-
стра операнда (DR). Результат операции всегда помещается в Асс. При завер-
шении выполнения операции АУ вырабатывает сигналы признаков
результата: Z (равен 1, если результат равен нулю); S (равен 1, если результат
отрицателен); OV (равен 1, если при выполнении операции произошло пере-
полнение разрядной сетки). В случаях, когда эти условия не выполняются,
соответствующие сигналы имеют нулевое значение.
В модели ЭВМ предусмотрены внешние устройства двух типов. Во-первых,
это регистры IR и OR, которые могут обмениваться с аккумулятором с помо-
щью безадресных команд IN (Асс := IR) и OUT (OR := Асс). Во-вторых, это на-
бор моделей внешних устройств, которые могут подключаться к системе и
взаимодействовать с ней в соответствии с заложенными в моделях алго-
ритмами. Каждое внешнее устройство имеет ряд программно-доступных ре-
гистров, может иметь собственный обозреватель (окно видимых элементов).
Подробнее эти внешние устройства описаны в разд. 9.6.
УУ осуществляет выборку команд из ОЗУ в последовательности, определяе-
мой естественным порядком выполнения команд (т. е. в порядке возрастания
адресов команд в ОЗУ) или командами передачи управления; выборку из
ОЗУ операндов, задаваемых адресами команды; инициирование выполнения
операции, предписанной командой; останов или переход к выполнению сле-
дующей команды.
В качестве сверхоперативной памяти в модель включены регистры общего
назначения (РОН), и может подключаться модель кэш-памяти.
В состав УУ ЭВМ входят:
􀂈 PC — счетчик адреса команды, содержащий адрес текущей команды;
􀂈 CR — регистр команды, содержащий код команды;
􀂈 RB — регистр базового адреса, содержащий базовый адрес;
Глава 9. Описание архитектуры учебной ЭВМ 257
Магистраль данных
Магистраль адреса
Процессор
АУ
Acc
DR
CR:COP.TA.ADR
PC SP
RA RB
INT
RDR
РОН
[0:9]
RAR
Кэш-
память
MDR
ОЗУ
[0:999]
MAR
IR
OR
Контроллер
клавиатуры
Дисплей Блок
таймеров
Контроллер
прерываний
Рис. 9.1. Общая структура учебной ЭВМ
Часть III. Лабораторный 258 практикум и курсовое проектирование
􀂈 SP — указатель стека, содержащий адрес верхушки стека;
􀂈 RA — регистр адреса, содержащий исполнительный адрес при кос-
венной адресации.
Регистры Асc, DR, IR, OR, CR и все ячейки ОЗУ и РОН имеют длину
6 десятичных разрядов, регистры PC, SP, RA и RB — 3 разряда.
9.2. Представление данных в модели
Данные в ЭВМ представляются в формате, показанном на рис. 9.2. Это целые
десятичные числа, изменяющиеся в диапазоне –99 999…+99 999, содержа-
щие знак и 5 десятичных цифр.
Рис. 9.2. Формат десятичных данных учебной ЭВМ
Старший разряд слова данных используется для кодирования знака: плюс (+)
изображается как 0, минус (–) — как 1. Если результат арифметической опе-
рации выходит за пределы указанного диапазона, то говорят, что произошло
переполнение разрядной сетки. АЛУ в этом случае вырабатывает сигнал пе-
реполнения OV = 1. Результатом операции деления является целая часть ча-
стного. Деление на ноль вызывает переполнение.
9.3. Система команд
При рассмотрении системы команд ЭВМ обычно анализируют три аспекта:
форматы, способы адресации и систему операций.
9.3.1. Форматы команд
Большинство команд учебной ЭВМ являются одноадресными или безадрес-
ными, длиной в одно машинное слово (6 разрядов). Исключение составляют
двухсловные команды с непосредственной адресацией и команда MOV, яв-
ляющаяся двухадресной.
В форматах команд выделяются три поля:
􀂈 два старших разряда [0:1] определяют код операции СОР;
􀂈 разряд 2 может определять тип адресации (в одном случае (формат 5а) он
определяет номер регистра);
Глава 9. Описание архитектуры учебной ЭВМ 259
􀂈 разряды [3:5] могут определять прямой или косвенный адрес памяти, но-
мер регистра (в команде MOV номера двух регистров), адрес перехода или
короткий непосредственный операнд. В двухсловных командах непо-
средственный операнд занимает поле [6:11].
Полный список форматов команд показан на рис. 9.3, где приняты следую-
щие обозначения:
􀂈 СОР — код операции;
􀂈 ADR — адрес операнда в памяти;
􀂈 ADC — адрес перехода;
􀂈 I — непосредственный операнд;
􀂈 R, Rl, R2 — номер регистра;
􀂈 ТА — тип адресации;
􀂈 X — разряд не используется.
Рис. 9.3. Форматы команд учебной ЭВМ
9.3.2. Способы адресации
В ЭВМ принято различать пять основных способов адресации: прямая, кос-
венная, непосредственная, относительная, безадресная.
Каждый способ имеет разновидности. В модели учебной ЭВМ реализованы семь
способов адресации, приведенные в табл. 9.1.
Часть III. Лабораторный 260 практикум и курсовое проектирование
Таблица 9.1. Адресация в командах учебной ЭВМ
Код ТА Тип адресации Исполнительный адрес
0 Прямая (регистровая) ADR (R)
1 Непосредственная —
2 Косвенная O3У(ADR)[3:5]
3 Относительная ADR + RB
4 Косвенно-регистровая POH(R)[3:5]
5 Индексная с постинкрементом POH(R)[3:5], R:= R + l
6 Индексная с преддекрементом R:= R – l, POH(R)[3:5]
9.3.3. Система операций
Система команд учебной ЭВМ включает команды следующих классов:
􀂈 арифметико-логические и специальные: сложение, вычитание, умноже-
ние, деление;
􀂈 пересылки и загрузки: чтение, запись, пересылка (из регистра в регистр),
помещение в стек, извлечение из стека, загрузка указателя стека, загруз-
ка базового регистра;
􀂈 ввода/вывода: ввод, вывод;
􀂈 передачи управления: безусловный и шесть условных переходов, вызов
подпрограммы, возврат из подпрограммы, цикл, программное прерыва-
ние, возврат из прерывания;
􀂈 системные: пустая операция, разрешить прерывание, запретить прерыва-
ние, стоп.
Список команд учебной ЭВМ приведен в табл. 9.4 и 9.6.
9.4. Состояния и режимы работы ЭВМ
Ядром УУ ЭВМ является управляющий автомат (УА), вырабатывающий сиг-
налы управления, которые инициируют работу АЛУ, РОН, ОЗУ и УВВ, пере-
дачу информации между регистрами устройств ЭВМ и действия над содер-
жимым регистров УУ.
ЭВМ может находиться в одном из двух состояний: Останов и Работа.
Глава 9. Описание архитектуры учебной ЭВМ 261
В состояние Работа ЭВМ переходит по действию команд Пуск или Шаг.
Команда Пуск запускает выполнение программы, представляющую собой
последовательность команд, записанных в ОЗУ, в автоматическом режиме до
команды HLT или точки останова. Программа выполняется по командам, на-
чиная с ячейки ОЗУ, на которую указывает PC, причем изменение состояний
объектов модели отображается в окнах обозревателей.
В состояние Останов ЭВМ переходит по действию команды Стоп или авто-
матически в зависимости от установленного режима работы.
Команда Шаг, в зависимости от установленного режима работы, запускает
выполнение одной команды или одной микрокоманды (если установлен
Режим микрокоманд), после чего переходит в состояние Останов.
В состоянии Останов допускается просмотр и модификация объектов моде-
ли: регистров процессора и РОН, ячеек ОЗУ, устройств ввода/вывода. В про-
цессе модификации ячеек ОЗУ и РОН можно вводить данные для програм-
мы, в ячейки ОЗУ — программу в кодах. Кроме того, в режиме Останов
можно менять параметры модели и режимы ее работы, вводить и/или редак-
тировать программу в мнемокодах, ассемблировать мнемокоды, выполнять
стандартные операции с файлами.
9.5. Интерфейс пользователя
В программной модели учебной ЭВМ использован стандартный интерфейс
Windows, реализованный в нескольких окнах.
Основное окно модели Модель учебной ЭВМ содержит главное меню и
кнопки на панели управления. В рабочее поле окна выводятся сообщения
о функционировании системы в целом. Эти сообщения группируются в фай-
ле logfile.txt (по умолчанию), сохраняются на диске и могут быть проана-
лизированы после завершения сеанса работы с моделью.
Меню содержит следующие пункты и команды:
􀂈 Файл:
• неактивные команды;
• Выход;
􀂈 Вид:
• Показать все;
• Скрыть все;
• Процессор;
Часть III. Лабораторный 262 практикум и курсовое проектирование
• Микрокомандный уровень;
• Память;
• Кэш-память;
• Программа;
• Текст программы;
􀂈 Внешние устройства:
• Менеджер ВУ;
• окна подключенных ВУ;
􀂈 Работа:
• Пуск;
• Стоп;
• Шаг;
• Режим микрокоманд;
• Кэш-память;
• Настройки.
Команды меню Вид открывают окна соответствующих обозревателей, опи-
санные далее. Менеджер внешних устройств позволяет подключать/отклю-
чать внешние устройства, предусмотренные в системе. Команда вызова
менеджера внешних устройств выполняется при нажатии кнопки на панели
инструментов. Подробнее о внешних устройствах и их обозревателях см.
в разд. 9.6.
Команды меню Работа позволяют запустить программу в автоматическом
(команда Пуск) или шаговом (команда Шаг) режиме, остановить выполне-
ние программы в модели процессора (команда Стоп). Эти команды могут
выполняться при нажатии соответствующих одноименных кнопок на панели
инструментов основного окна.
Команда Режим микрокоманд включает/выключает микрокомандный ре-
жим работы процессора, а команда Кэш-память подключает/отключает
в системе модель этого устройства.
Команда Настройки открывает диалоговое окно Параметры системы, по-
зволяющее установить задержку реализации командного цикла (при выпол-
нении программы в автоматическом режиме), а также установить параметры
файла logfile.txt, формируемого системой и записываемого на диск.
Глава 9. Описание архитектуры учебной ЭВМ 263
9.5.1. Окна основных обозревателей системы
Окно Процессор
Окно Процессор (рис. 9.4) обеспечивает доступ ко всем регистрам и флагам
процессора.
Рис. 9.4. Окно Процессор
􀂈 Программно-доступные регистры и флаги:
• Асс — аккумулятор;
• PC — счетчик адреса команды, содержащий адрес текущей команды;
• SP — указатель стека, содержащий адрес верхушки стека;
• RB — регистр базового адреса, содержащий базовый адрес;
• RA — регистр адреса, содержащий исполнительный адрес при косвен-
ной адресации;
• IR — входной регистр;
• OR — выходной регистр;
• I — флаг разрешения прерываний.
􀂈 Системные регистры и флаги:
• DR — регистр данных АЛУ, содержащий второй операнд;
• MDR — регистр данных ОЗУ;
• MAR — регистр адреса ОЗУ;
Часть III. Лабораторный 264 практикум и курсовое проектирование
• RDR — регистр данных блока РОН;
• RAR — регистр адреса блока РОН;
• CR — регистр команд, содержащий поля:
◊ СОР — код операции;
◊ ТА — тип адресации;
◊ ADR — адрес или непосредственный операнд;
• Z — флаг нулевого значения Асс;
• S — флаг отрицательного значения Асс;
• OV — флаг переполнения.
Регистры Асс, DR, IR, OR, CR и все ячейки ОЗУ и РОН имеют длину 6 деся-
тичных разрядов, регистры PC, SP, RA и RB — 3 разряда. В окне Процессор
отражаются текущие значения регистров и флагов, причем в состоянии
Останов все регистры, включая регистры блока РОН, и флаги (кроме флага I)
доступны для непосредственного редактирования.
Элементы управления окна Процессор включают меню и кнопки, вызываю-
щие команды:
􀂈 Сохранить;
􀂈 Загрузить;
􀂈 Reset;
􀂈 Reset R0-R9 (только команда меню Работа).
Команды Сохранить и Загрузить позволяют сохранить текущее значение
регистров и флагов процессора в файле и восстановить состояние процессора
из файла. Команда Reset и кнопка R устанавливают все регистры (в т. ч.
блок РОН) в начальное (нулевое) значение. Содержимое ячеек памяти при
этом не меняется. Выполняемая лишь из меню Работа команда Reset R0-R9
очищает только регистры блока РОН.
Окно Память
Окно Память (рис. 9.5) отражает текущее состояние ячеек ОЗУ. В этом окне
допускается редактирование содержимого ячеек, кроме того, предусмотрена
возможность выполнения (через меню или с помощью кнопок панели инстру-
ментов) пяти команд: Сохранить, Загрузить, Перейти к, Вставить, Убрать.
Команды Сохранить, Загрузить во всех окнах, где они предусмотрены, ра-
ботают одинаково — сохраняют в файле текущее состояние объекта (в дан-
ном случае памяти) и восстанавливают это состояние из выбранного файла,
Глава 9. Описание архитектуры учебной ЭВМ 265
причем файл в каждом окне записывается по умолчанию с характерным для
этого окна расширением.
Команда Перейти к открывает диалоговое окно, позволяющее перейти на
заданную ячейку ОЗУ.
Команда Убрать открывает диалог, в котором указывается диапазон ячеек
с m по n . Содержимое ячеек в этом диапазоне теряется, а содержимое ячеек
[ (n +1) : 999] перемещается в соседние ячейки с меньшими адресами. Осво-
бодившиеся ячейки с адресами 999, 998, ... заполняются нулями.
Рис. 9.5. Окно Память
Команда Вставить, позволяющая задать номера ячеек, перемещает содер-
жимое всех ячеек, начиная от m-й на n − m позиций в направлении больших
адресов, ячейки заданного диапазона [m : n ] заполняются нулями, а содер-
жимое последних ячеек памяти теряется.
Окно Текст программы
Окно Текст программы (рис. 9.6) содержит стандартное поле текстового
редактора, в котором можно редактировать тексты, загружать в него тексто-
вые файлы и сохранять подготовленный текст в виде файла.
Команды меню Файл:
􀂈 Новая — открывает новый сеанс редактирования;
􀂈 Загрузить — открывает стандартный диалог загрузки файла в окно ре-
дактора;
􀂈 Сохранить — сохраняет файл под текущим именем;
Часть III. Лабораторный 266 практикум и курсовое проектирование
􀂈 Сохранить как — открывает стандартный диалог сохранения файла;
􀂈 Вставить — позволяет вставить выбранный файл в позицию курсора.
Все перечисленные команды, кроме последней, дублированы кнопками на
панели инструментов окна. На той же панели присутствует еще одна кноп-
ка — Компилировать, которая запускает процедуру ассемблирования текста
в поле редактора.
Ту же процедуру можно запустить из меню Работа. Команда Адрес вставки
позволяет задать адрес ячейки ОЗУ, начиная с которой программа будет раз-
мещаться в памяти. По умолчанию этот адрес принят равным 0.
Ниже области редактирования в строку состояния выводится позиция теку-
щей строки редактора — номер строки, в которой находится курсор.
В случае обнаружения синтаксических ошибок в тексте программы диагно-
стические сообщения процесса компиляции выводятся в окно сообщений и
запись в память кодов (даже безошибочного начального фрагмента програм-
мы) не производится.
Рис. 9.6. Окно Текст программы
Глава 9. Описание архитектуры учебной ЭВМ 267
После исправления ошибок и повторной компиляции выдается сообщение об
отсутствии ошибок, о расположении и размере области памяти, занятой под
ассемблированную программу.
Набор текста программы производится по стандартным правилам языка ас-
семблера. В каждой строке может содержаться метка, одна команда и ком-
ментарий. Метка отделяется от команды двоеточием, символы после знака
"точка с запятой" до конца строки игнорируются компилятором и могут рас-
сматриваться как комментарии. Строка может начинаться с ; и, следователь-
но, содержать только комментарии.
Окно Программа
Окно Программа (рис. 9.7) отображает таблицу, имеющую 300 строк и
4 столбца. Каждая строка таблицы соответствует дизассемблированной ячей-
ке ОЗУ. Второй столбец содержит адрес ячейки ОЗУ, третий — дизассемб-
лированный мнемокод, четвертый — машинный код команды. В первом
столбце может помещаться указатель --> на текущую команду (текущее зна-
чение PC) и точка останова — красная заливка ячейки.
Рис. 9.7. Окно Программа
Часть III. Лабораторный 268 практикум и курсовое проектирование
Окно Программа позволяет наблюдать процесс прохождения программы.
В этом окне ничего нельзя редактировать. Органы управления окна позволя-
ют сохранить содержимое окна в виде текстового файла, выбрать начальный
адрес области ОЗУ, которая будет дизассемблироваться (размер области по-
стоянный — 300 ячеек), а также установить/снять точку останова. Последнее
можно проделать тремя способами: командой Точка останова из меню
Работа, кнопкой на панели инструментов или двойным щелчком мыши
в первой ячейке соответствующей строки. Характерно, что прочитать в это
окно ничего нельзя. Сохраненный текстовый asm-файл можно загрузить
в окно Текст программы, ассемблировать его и тогда дизассемблированное
значение заданной области памяти автоматически появится в окне Про-
грамма. Такую процедуру удобно использовать, если программа изначально
пишется или редактируется непосредственно в памяти в машинных кодах.
Начальный адрес области дизассемблирования задается в диалоге командой
Начальный адрес меню Работа.
Окно Микрокомандный уровень
Окно Микрокомандный уровень (рис. 9.8) используется только в режиме
микрокоманд, который устанавливается командой Режим микрокоманд ме-
ню Работа. В это окно выводится мнемокод выполняемой команды, список
микрокоманд, ее реализующих, и указатель на текущую выполняемую мик-
рокоманду.
Шаговый режим выполнения программы или запуск программы в автомати-
ческом режиме с задержкой командного цикла позволяет наблюдать процесс
выполнения программы на уровне микрокоманд.
Рис. 9.8. Окно Микрокомандный уровень
Глава 9. Описание архитектуры учебной ЭВМ 269
Если открыть окно Микрокомандный уровень, не установив режим микро-
команд в меню Работа, то после начала выполнения программы в режиме
Шаг (или в автоматическом режиме) в строке сообщений окна будет выдано
сообщение "Режим микрокоманд неактивен".
Окно Кэш-память
Окно Кэш-память используется в режиме с подключенной кэш-памятью.
Подробнее об этом режиме см. в разд. 9.8.
9.6. Внешние устройства
Модели внешних устройств (ВУ), используемые в описываемой системе,
реализованы по единому принципу. С точки зрения процессора они представ-
ляют собой ряд программно-доступных регистров, лежащих в адресном про-
странстве ввода/вывода. Размер регистров ВУ совпадает с размером ячеек па-
мяти и регистров данных процессора — шесть десятичных разрядов.
Доступ к регистрам ВУ осуществляется по командам IN aa, ОUT aa, где aa —
двухразрядный десятичный адрес регистра ВУ. Таким образом, общий объем
адресного пространства ввода/вывода составляет 100 адресов. Следует помнить,
что адресные пространства памяти и ввода/вывода в этой модели разделены.
Разные ВУ содержат различное число программно-доступных регистров,
каждому из которых соответствует свой адрес, причем нумерация адресов
всех ВУ начинается с 0. При создании ВУ ему ставится в соответствие базо-
вый адрес в пространстве ввода/вывода, и все адреса его регистров становят-
ся смещениями относительно этого базового адреса.
Если в системе создается несколько ВУ, то их базовые адреса следует выби-
рать с учетом величины адресного пространства, занимаемого этими устрой-
ствами, исключая наложение адресов.
Если ВУ способно формировать запрос на прерывание, то при создании ему
ставится в соответствие вектор прерывания — десятичное число. Разным ВУ
должны назначаться различные векторы прерываний.
Программная модель учебной ЭВМ комплектуется набором внешних уст-
ройств, включающим:
􀂈 контроллер клавиатуры;
􀂈 дисплей;
􀂈 блок таймеров;
􀂈 тоногенератор,
которым по умолчанию присвоены параметры, перечисленные в табл. 9.2.
Часть III. Лабораторный 270 практикум и курсовое проектирование
Таблица 9.2. Параметры внешних устройств
Внешнее устройство Базовый
адрес
Адреса
регистров
Вектор
прерывания
Контроллер клавиатуры 0 0, 1, 2 0
Дисплей 10 0, 1, 2, 3 Нет
Блок таймеров 20 0, 1, 2, 3, 4, 5, 6 2
Тоногенератор 30 0, 1 Нет
При создании устройств пользователь может изменить назначенные по умол-
чанию базовый адрес и вектор прерывания.
В описываемой версии системы не предусмотрена возможность подключения
в систему нескольких одинаковых устройств.
Большинство внешних устройств содержит регистры управления CR и со-
стояния SR, причем обычно регистры CR доступны только по записи,
a SR — по чтению.
Регистр CR содержит флаги и поля, определяющие режимы работы ВУ,
a SR — флаги, отражающие текущее состояние ВУ. Флаги SR устанавлива-
ются аппаратно, но сбрасываются программно (или по внешнему сигналу).
Поля и флаги CR устанавливаются и сбрасываются программно при записи
кода данных в регистр CR или специальными командами.
Контроллер ВУ интерпретирует код, записываемый по адресу CR как коман-
ду, если третий разряд этого кода равен 1, или как записываемые в CR дан-
ные, если третий разряд равен 0. В случае получения командного слова
запись в регистр CR не производится, а пятый разряд слова рассматривается
как код операции.
9.6.1. Контроллер клавиатуры
Контроллер клавиатуры (рис. 9.9) представляет собой модель внешнего уст-
ройства, принимающего ASCII-коды2 от клавиатуры ПЭВМ.
Символы помещаются последовательно в буфер символов, размер которого
установлен равным 50 символам, и отображаются в окне обозревателя
(рис. 9.10).
2 Сокр. от American Standard Code for Information Interchange — американский стан-
дартный код обмена информацией.
Глава 9. Описание архитектуры учебной ЭВМ 271
Рис. 9.9. Контроллер клавиатуры
Рис. 9.10. Окно обозревателя контроллера клавиатуры
В состав контроллера клавиатуры входят три программно-доступных регистра:
􀂈 DR (адрес 0) — регистр данных;
􀂈 CR (адрес 1) — регистр управления, определяет режимы работы контрол-
лера и содержит следующие флаги:
• Е — флаг разрешения приема кодов в буфер;
Часть III. Лабораторный 272 практикум и курсовое проектирование
• I — флаг разрешения прерывания;
• S — флаг режима посимвольного ввода;
􀂈 SR (адрес 2) — регистр состояния, содержит два флага:
• Err — флаг ошибки;
• Rd — флаг готовности.
Регистр данных DR доступен только для чтения, через него считываются
ASCII-коды из буфера, причем порядок чтения кодов из буфера соответству-
ет порядку их записи в буфер — каждое чтение по адресу 0 автоматически
перемещает указатель чтения буфера. В каждый момент времени DR содер-
жит код символа по адресу указателя чтения буфера.
Флаги регистра управления CR устанавливаются и сбрасываются программно.
Флаг Е, будучи установленным, разрешает прием кодов в буфер. При Е = 0
контроллер игнорирует нажатие на клавиатуре, прием кодов в буфер не про-
изводится. На считывание кодов из буфера флаг Е влияния не оказывает.
Флаг I, будучи установленным, разрешает при определенных условиях фор-
мирование контроллером запроса на прерывание. При I = 0 запрос на преры-
вание не формируется.
Флаг S = 1 устанавливает так называемый режим посимвольного ввода, иначе
контроллер работает в обычном режиме. Флаг S устанавливается и сбрасыва-
ется программно, кроме того, S сбрасывается при нажатии кнопки Очистить
буфер в окне Контроллер клавиатуры.
Условия формирования запроса на прерывание определяются, с одной сторо-
ны, значением флага разрешения прерывания I, с другой — режимом работы
контроллера. В режиме посимвольного ввода запрос на прерывание форми-
руется после ввода каждого символа (разумеется, при I = 1), в обычном ре-
жиме запрос будет сформирован по окончании набора строки.
Завершить набор строки можно, щелкнув по кнопке Завершить ввод в окне
Контроллер клавиатуры (см. рис. 9.10). При этом устанавливается флаг
готовности Rd (от англ. ready) в регистре состояния SR. Флаг ошибки Err
(от англ. error) в том же регистре устанавливается при попытке ввода в буфер
51-го символа. Ввод 51-го и всех последующих символов блокируется.
Сброс флага Rd осуществляется автоматически при чтении из регистра DR,
флаг Err сбрасывается программно. Кроме того, оба эти флага сбрасываются
при нажатии кнопки Очистить буфер в окне Контроллер клавиатуры; од-
новременно со сбросом флагов производится очистка буфера — весь буфер
заполняется кодами 00h, и указатели записи и чтения устанавливаются на на-
чало буфера.
Глава 9. Описание архитектуры учебной ЭВМ 273
Для программного управления контроллером предусмотрен ряд командных
слов. Все команды выполняются при записи по адресу регистра управления
CR кодов с 1 в третьем разряде.
Контроллер клавиатуры интерпретирует следующие командные слова:
􀂈 xxxl0l — очистить буфер (действие команды эквивалентно нажатию кноп-
ки Очистить буфер);
􀂈 ххх102 — сбросить флаг Err в регистре SR;
􀂈 ххх10З — установить флаг S в регистре CR;
􀂈 ххх104 — сбросить флаг S в регистре CR.
Если по адресу 1 произвести запись числа ххх0nn, то произойдет изменение
4-го и 5-го разрядов регистра CR по следующему правилу:
0—записать 0;
1— записать 1;
2, ..., 9 — сохранить разряд без изменения.
n
⎧⎪
=⎨⎪⎩
(9.1)
9.6.2. Дисплей
Дисплей (рис. 9.11) представляет собой модель внешнего устройства, реали-
зующую функции символьного дисплея. Дисплей может отображать симво-
лы, задаваемые ASCII-кодами, поступающими на его регистр данных. Дис-
плей включает:
􀂈 видеопамять объемом 128 слов (ОЗУ дисплея);
􀂈 символьный экран размером 8 строк по 16 символов в строке;
􀂈 четыре программно-доступных регистра:
DR (адрес 0) — регистр данных;
CR (адрес 1) — регистр управления;
SR (адрес 2) — регистр состояния;
AR (адрес 3) — регистр адреса.
Через регистры адреса AR и данных DR по записи и чтению осуществляется
доступ к ячейкам видеопамяти. При обращении к регистру DR по записи со-
держимое аккумулятора записывается в DR и в ячейку видеопамяти, адрес
которой установлен в регистре AR.
Часть III. Лабораторный 274 практикум и курсовое проектирование
Рис. 9.11. Контроллер дисплея
Регистр управления CR доступен только по записи и содержит в 4-м и 5-м раз-
рядах соответственно два флага:
􀂈 Е — флаг разрешения работы дисплея; при Е = 0 запись в регистры AR
и DR блокируется;
􀂈 А — флаг автоинкремента адреса; при А = 1 содержимое AR автомати-
чески увеличивается на 1 после любого обращения к регистру DR — по
записи или чтению.
Изменить значения этих флагов можно, если записать по адресу CR (по
умолчанию — 11) код ххх0nn, при этом изменение 4-го и 5-го разрядов реги-
стра CR произойдет согласно выражению (9.1).
Для программного управления дисплеем предусмотрены две команды, коды
которых должны записываться по адресу регистра CR, причем в третьем раз-
ряде командных слов обязательно должна быть 1:
􀂈 xxxl0l — очистить дисплей (действие команды эквивалентно нажатию
кнопки Очистить в окне Дисплей), при этом очищается видеопамять
(в каждую ячейку записывается код пробела — 032), устанавливается в 000
регистр адреса AR и сбрасываются флаги ошибки Err и автоинкремента А;
􀂈 ххх102 — сбросить флаг ошибки Err.
Регистр состояния SR доступен только по чтению и содержит единственный
флаг (в пятом разряде) ошибки Err. Этот флаг устанавливается аппаратно при
Глава 9. Описание архитектуры учебной ЭВМ 275
попытке записать в регистр адреса число, большее 127, причем как в режиме
прямой записи в AR, так и в режиме автоинкремента после обращения по
адресу 127. Сбрасывается флаг Err программно или при нажатии кнопки
Очистить в окне Дисплей (рис. 9.12).
Рис. 9.12. Окно обозревателя контроллера дисплея
9.6.3. Блок таймеров
Блок таймеров (рис. 9.13) включает в себя три однотипных канала, каждый из
которых содержит:
􀂈 пятиразрядный десятичный реверсивный счетчик Т, на вход которого по-
ступают метки времени (таймер);
􀂈 программируемый предделитель D;
􀂈 регистр управления таймером CTR;
􀂈 флаг переполнения таймера FT.
Регистры таймеров Т доступны по записи и чтению (адреса 1, 3, 5 соответст-
венно для T1, T2, ТЗ). Программа в любой момент может считать текущее
содержимое таймера или записать в него новое значение.
Часть III. Лабораторный 276 практикум и курсовое проектирование
Рис. 9.13. Блок таймеров
На входы предделителей поступают общие для всех каналов метки времени
CLK с периодом 1 мс. Предделители в каждом канале программируются не-
зависимо, поэтому таймеры могут работать с различной частотой.
Регистры управления CTR доступны по записи и чтению (адреса 2, 4, 6) и
содержат следующие поля:
􀂈 Т (разряд 5) — флаг включения таймера;
􀂈 EI (разряд 4) — флаг разрешения формирования запроса на прерывание
при переполнении таймера;
􀂈 I/D (разряд 3) — направление счета (инкремент/декремент), при I/D = 0
таймер работает на сложение, при I/D = 1 — на вычитание;
􀂈 k (разряды [1:2]) — коэффициент деления предделителя (от 1 до 99).
Флаги переполнения таймеров собраны в один регистр — доступный только
по чтению регистр состояния SR, имеющий адрес 0. Разряды регистра (5, 4 и 3
для T1, T2, ТЗ соответственно) устанавливаются в 1 при переполнении соот-
ветствующего таймера. Для таймера, работающего на сложение, переполне-
ние наступает при переходе его состояния из 99 999 в 0, для вычитающего
таймера — переход из 0 в 99 999.
В окне обозревателя (рис. 9.14) предусмотрена кнопка Сброс, нажатие кото-
рой сбрасывает в 0 все регистры блока таймеров, кроме CTR, которые уста-
навливаются в состояние 001000. Таким образом, все три таймера обнуляются,
Глава 9. Описание архитектуры учебной ЭВМ 277
переключаются в режим инкремента, прекращается счет, запрещаются пре-
рывания, сбрасываются флаги переполнения и устанавливаются коэффици-
енты деления предделителей равными 01.
Рис. 9.14. Окно обозревателя блока таймеров
Программное управление режимами блока таймеров осуществляется путем
записи в регистры CTR соответствующих кодов. Запись по адресу SR числа
с 1 в третьем разряде интерпретируется блоком таймеров как команда, при-
чем младшие разряды этого числа определяют код команды:
􀂈 xxxl00 — общий сброс (эквивалентна нажатию кнопки Сброс в окне обо-
зревателя);
􀂈 xxxl0l — сброс флага переполнения таймера FT1;
􀂈 xxxl02 — сброс флага переполнения таймера FT2;
􀂈 xxxl03 — сброс флага переполнения таймера FT3.
9.6.4. Тоногенератор
Модель этого простого внешнего устройства не имеет собственного обозре-
вателя, содержит всего два регистра, доступных только для записи:
􀂈 FR (адрес 0) — регистр частоты звучания (Гц):
􀂈 LR (адрес 1) — регистр длительности звучания (мс).
По умолчанию базовый адрес тоногенератора — 30. Сначала следует запи-
сать в FR требуемую частоту тона в герцах, затем в LR — длительность зву-
чания в миллисекундах. Запись числа по адресу регистра LR одновременно
является командой на начало звучания.
Часть III. Лабораторный 278 практикум и курсовое проектирование
9.7. Подсистема прерываний
В модели учебной ЭВМ предусмотрен механизм векторных внешних преры-
ваний. Внешние устройства формируют запросы на прерывания, которые по-
ступают на входы контроллера прерываний. При подключении ВУ, способ-
ного формировать запрос на прерывание, ему ставится в соответствие номер
входа контроллера прерываний — вектор прерывания, принимающий значе-
ние в диапазоне 0—9.
Контроллер передает вектор, соответствующий запросу, процессору, кото-
рый начинает процедуру обслуживания прерывания.
Каждому из возможных в системе прерываний должен соответствовать так
называемый обработчик прерывания — подпрограмма, вызываемая при воз-
никновении события конкретного прерывания.
Механизм прерываний, реализованный в модели учебной ЭВМ, поддержива-
ет таблицу векторов прерываний, которая создается в оперативной памяти
моделью операционной системы (если она используется) или непосредствен-
но пользователем.
Номер строки таблицы соответствует вектору прерывания, а элемент табли-
цы — ячейка памяти, в трех младших разрядах которой размещается началь-
ный адрес подпрограммы, обслуживающей прерывание с этим вектором.
Таблица прерываний в рассматриваемой модели жестко фиксирована — она
занимает ячейки памяти с адресами 100—109. Таким образом, адрес обра-
ботчика с вектором 0 должен располагаться в ячейке 100, с вектором 2 — в
ячейке 102. При работе с прерываниями не рекомендуется использовать
ячейки 100—109 для других целей.
Процессор начинает обработку прерывания (если они разрешены), завершив
текущую команду. При этом он:
1. Получает от контроллера вектор прерывания.
2. Формирует и помещает в верхушку стека слово, три младших разряда
([3:5]) которого — текущее значение PC (адрес возврата из прерывания),
а разряды [1:2] сохраняют десятичный эквивалент шестнадцатеричной циф-
ры, определяющей значение вектора флагов (I, OV, S, Z). Например, если
I = 1, OV = 0, S = 1, Z = 1, то в разряды [1:2] запишется число 1110 = 10112 .
3. Сбрасывает в 0 флаг разрешения прерывания I.
4. Извлекает из таблицы векторов прерываний адрес обработчика, соответ-
ствующий обслуживаемому вектору, и помещает его в PC, осуществляя
тем самым переход на подпрограмму обработчика прерывания.
Глава 9. Описание архитектуры учебной ЭВМ 279
Таким образом, вызов обработчика прерывания, в отличие от вызова подпро-
граммы, связан с помещением в стек не только адреса возврата, но и текуще-
го значения вектора флагов. Поэтому последней командой подпрограммы
обработчика должна быть команда IRET, которая не только возвращает в PC
три младшие разряда ячейки — верхушки стека (как RET), но и восстанавли-
вает те значения флагов, которые были в момент перехода на обработчик
прерывания.
Не всякое событие, которое может вызвать прерывание, приводит к прерыва-
нию текущей программы. В состав процессора входит программно-
доступный флаг I разрешения прерывания. При I = 0 процессор не реагирует
на запросы прерываний. После сброса процессора флаг I так же сброшен
и все прерывания запрещены. Для того чтобы разрешить прерывания, следу-
ет в программе выполнить команду EI (от англ. enable interrupt).
Ранее отмечалось, что при переходе на обработчик прерывания флаг I авто-
матически сбрасывается, в этом случае прервать обслуживание одного пре-
рывания другим прерыванием нельзя. По команде IRET значение флагов вос-
станавливается, в т. ч. вновь устанавливается I = 1, следовательно, в основной
программе прерывания опять разрешены.
Если требуется разрешить другие прерывания в обработчике прерывания,
достаточно в нем выполнить команду EI. Контроллер прерываний и процес-
сор на аппаратном уровне блокируют попытки запустить прерывание, если
его обработчик начал, но не завершил работу.
Таким образом, флаг I разрешает или запрещает все прерывания системы.
Если требуется выборочно разрешить некоторое подмножество прерываний,
используются программно-доступные флаги разрешения прерываний непо-
средственно на внешних устройствах.
Как правило, каждое внешнее устройство, которое может вызвать прерыва-
ние, содержит в составе своих регистров разряд флага разрешения прерыва-
ния (см. формат регистров CR и CTR на рис. 9.9, 9.13), по умолчанию уста-
новленный в 0. Если оставить этот флаг в нуле, то внешнему устройству
запрещается формировать запрос контроллеру прерываний.
Иногда бывает удобно (например, в режиме отладки) иметь возможность вы-
звать обработчик прерывания непосредственно из программы. Если исполь-
зовать для этих целей команду CALL, которая помещает в стек только адрес
возврата, то команда IRET, размещенная последней в обработчике, может ис-
казить значения флагов (все они будут сброшены в 0, т. к. команда CALL фор-
мирует только три младшие разряда ячейки верхушки стека, оставляя ос-
тальные разряды в 000).
Часть III. Лабораторный 280 практикум и курсовое проектирование
Поэтому в системах команд многих ЭВМ, в т. ч. и нашей модели, имеются
команды вызова прерываний — INT n (в нашей модели n ∈ {0, 1, ..., 9}),
где n — вектор прерывания. Процессор, выполняя команду INT n, произво-
дит те же действия, что и при обработке прерывания с вектором n.
Характерно, что с помощью команды INT n можно вызвать обработчик пре-
рывания даже в том случае, когда флаг разрешения прерывания I сброшен.
9.8. Программная модель кэш-памяти
К описанной в разд. 9.1 программной модели учебной ЭВМ может быть под-
ключена программная модель кэш-памяти, структура которой в общем виде
отображена на рис. 5.2. Конкретная реализация кэш-памяти в описываемой
программной модели показана на рис. 9.15.
Рис. 9.15. Структура модели кэш-памяти
Кэш-память содержит N ячеек (в модели N может выбираться из множест-
ва {4, 8, 16, 32}), каждая из которых включает трехразрядное поле тега (адре-
са ОЗУ), шестиразрядное поле данных и три однобитовых признака (флага):
􀂈 Z — признак занятости ячейки;
􀂈 U — признак использования;
􀂈 W — признак записи в ячейку.
Глава 9. Описание архитектуры учебной ЭВМ 281
Таким образом, каждая ячейка кэш-памяти может дублировать одну любую
ячейку ОЗУ, причем отмечается ее занятость (в начале работы модели все
ячейки кэш-памяти свободны, ∀Zi = 0 ), факт записи информации в ячейку
во время пребывания ее в кэш-памяти, а также использование ячейки (т. е.
любое обращение к ней).
Текущее состояние кэш-памяти отображается на экране в отдельном окне
в форме таблицы, причем количество строк соответствует выбранному числу
ячеек кэш. Столбцы таблицы определяют содержимое полей ячеек, напри-
мер, так, как показано в табл. 9.3.
Таблица 9.3. Пример текущего состояния кэш-памяти
Теги Данные Z U W
1 012 220152 1 0 0
2 013 211003 1 1 0
3 050 000025 1 1 1
4 000 000000 0 0 0
Для настройки параметров кэш-памяти можно воспользоваться диалоговым
окном Кэш-память, вызываемым командой Вид | Кэш-память, а затем на-
жать первую кнопку на панели инструментов открытого окна. После этих
действий появится диалоговое окно Параметры кэш-памяти, позволяющее
выбрать размер кэш-памяти, способ записи в нее информации и алгоритм
замещения ячеек.
Напомним, что при сквозной записи при кэш-попадании в процессорных
циклах записи осуществляется запись как в ячейку кэш-памяти, так и в ячей-
ку ОЗУ, а при обратной записи — только в ячейку кэш-памяти, причем эта
ячейка отмечается битом записи (Wi := 1). При очистке ячеек, отмеченных
битом записи, необходимо переписать измененное значение ноля данных
в соответствующую ячейку ОЗУ.
При кэш-промахе следует поместить в кэш-память адресуемую процессором
ячейку. При наличии свободных ячеек кэш-памяти требуемое слово помеща-
ется в одну из них (в порядке очереди). При отсутствии свободных ячеек сле-
дует отыскать ячейку кэш-памяти, содержимое которой можно удалить,
записав на его место требуемые данные (команду). Поиск такой ячейки осу-
ществляется с использованием алгоритма замещения строк.
Часть III. Лабораторный 282 практикум и курсовое проектирование
В модели реализованы три различных алгоритма замещения строк:
􀂈 случайное замещение, при реализации которого номер ячейки кэш-памяти
выбирается случайным образом;
􀂈 очередь, при которой выбор замещаемой ячейки определяется временем
пребывания ее в кэш-памяти;
􀂈 бит использования, случайный выбор осуществляется только из тех ячеек,
которые имеют нулевое значение флага использования.
Напомним, что бит использования устанавливается в 1 при любом обраще-
нии к ячейке, однако, как только все биты Ui установятся в 1, все они тут же
сбрасываются в 0, так что в кэш всегда ячейки разбиты на два непересекаю-
щихся подмножества по значению бита U — те, обращение к которым со-
стоялось относительно недавно (после последнего сброса вектора U ), имеют
значение U = 1, иные — со значением U = 0 являются "кандидатами на уда-
ление" при использовании алгоритма замещения "бит использования".
Если в параметрах кэш-памяти установлен флаг "с учетом бита записи", то
все три алгоритма замещения осуществляют поиск "кандидата на удаление"
прежде всего среди тех ячеек, признак записи которых не установлен, а при
отсутствии таких ячеек (что крайне маловероятно) — среди всех ячеек кэш-
памяти. При снятом флаге "с учетом бита записи" поиск осуществляется по
всем ячейкам кэш-памяти без учета значения W.
Оценка эффективности работы системы с кэш-памятью определяется числом
кэш-попаданий по отношению к общему числу обращений к памяти. Учиты-
вая разницу в алгоритмах записи в режимах сквозной и обратной записи, эф-
фективность использования кэш-памяти вычисляется по следующим выра-
жениям (соответственно для сквозной и обратной записи):
о
к к
S
S S
K w −
= , (9.2)
о
к к
S
S S
K
i
w −
= , (9.3)
где:
􀂈 K — коэффициент эффективности работы кэш-памяти;
􀂈 Sо — общее число обращений к памяти;
􀂈 Sк — число кэш-попаданий;
􀂈
w
Sк — число сквозных записей при кэш-попадании (в режиме сквозной
записи);
􀂈 i
w
Sк — число обратных записей (в режиме обратной записи).
Глава 9. Описание архитектуры учебной ЭВМ 283
9.9. Вспомогательные таблицы
В данном разделе представлены вспомогательные таблицы (табл. 9.4—9.8)
для работы с моделью учебной ЭВМ.
Таблица 9.4. Таблица команд учебной ЭВМ
Мл.
Ст.
0 1 2 3 4
0 NOP JMP MOV
1 IN JZ RD RD RDI
2 OUT JNZ WR WR
3 IRET JS ADD ADD ADI
4 WRRB JNS SUB SUB SBI
5 WRSP JO MUL MUL MULI
6 PUSH JNO DIV DIV DIVI
7 POP JRNZ IN
8 RET INT EI OUT
9 HLT CALL DI
Таблица 9.5. Типы адресации, их коды и обозначение
Обозначение Код Тип адресации Пример команды
0 Прямая (регистровая) ADD 23 (ADD R3)
# 1 Непосредственная ADD #33
@ 2 Косвенная ADD @33
[ ] 3 Относительная ADD [33]
@R 4 Косвенно-регистровая ADD @R3
@R+ 5 Индексная с постинкрементом ADD @R3+
–@R 6 Индексная с преддекрементом ADD –@R3
В табл. 9.6 приняты следующие обозначения:
􀂈 DD — данные, формируемые командой в качестве (второго) операнда:
прямо или косвенно адресуемая ячейка памяти или трехразрядный непо-
средственный операнд;
Часть III. Лабораторный 284 практикум и курсовое проектирование
􀂈 R* — содержимое регистра или косвенно адресуемая через регистр ячейка
памяти;
􀂈 ADR* — два младших разряда ADR поля регистра CR;
􀂈 V — адрес памяти, соответствующий вектору прерывания;
􀂈 М(*) — ячейка памяти, прямо или косвенно адресуемая в команде;
􀂈 I — пятиразрядный непосредственный операнд со знаком.
Таблица 9.6. Система команд учебной ЭВМ
КОП Мнемо-
код Название Действие
00 NOP Пустая операция Нет
01 IN Ввод Acc ← IR
02 OUT Вывод OR ← Acc
03 IRET Возврат из прерывания FLAGS.PC ← M(SP); INC(SP)
04 WRRB Загрузка RB RB ← CR[ADR]
05 WRSP Загрузка SP SP ← CR[ADR]
06 PUSH Поместить в стек DEC(SP); M(SP) ← R
07 POP Извлечь из стека R → M(SP); INC(SP)
08 RET Возврат PC → M(SP); INC(SP)
09 HLT Стоп Конец командных циклов
10 JMP Безусловный переход PC ← CR[ADR]
11 JZ Переход, если 0 if Acc = 0 then PC ← CR[ADR]
12 JNZ Переход, если не 0 if Acc ≠ 0 then PC ← CR[ADR]
13 JS Переход, если
отрицательно
if Acc < 0 then PC ← CR[ADR]
14 JNS Переход, если
положительно
if Acc ≥ 0 then PC ← CR[ADR]
15 JO Переход, если
переполнение
if |Acc| > 99999 then PC ← CR[ADR]
16 JNO Переход, если нет
переполнения
if |Acc| ≤ 99999 then PC ← CR[ADR]
17 JRNZ Цикл DEC(R); if R ≠ 0 then PC ← CR[ADR]
Глава 9. Описание архитектуры учебной ЭВМ 285
Таблица 9.6 (продолжение)
КОП Мнемо-
код Название Действие
18 INT Программное
прерывание
DEC(SP); M(SP) ← FLAGS.PC;
PC ← M(V)
19 CALL Вызов подпрограммы DEC(SP); M(SP) ← PC;
PC ← CR(ADR)
20 Нет
21 RD Чтение Acc ← DD
22 WR Запись M(*) ← Acc
23 ADD Сложение Acc ← Acc + DD
24 SUB Вычитание Acc ← Acc – DD
25 MUL Умножение Acc ← Acc × DD
26 DIV Деление Acc ← Acc/DD
27 Нет
28 EI Разрешить прерывание IF ← 1
29 DI Запретить прерывание IF ← 0
30 MOV Пересылка R1 ← R2
31 RD Чтение Acc ← R*
32 WR Запись R* ← Acc
33 ADD Сложение Acc ← Acc + R*
34 SUB Вычитание Acc ← Acc – R*
35 MUL Умножение Acc ← Acc × R*
36 DIV Деление Acc ← Acc/R*
37 IN Ввод Acc ← ВУ(CR[ADR*])
38 OUT Вывод ВУ(CR[ADR*]) ← Acc
39 Нет
40 Нет
41 RDI Чтение Acc ← I
Часть III. Лабораторный 286 практикум и курсовое проектирование
Таблица 9.6 (окончание)
КОП Мнемо-
код Название Действие
42 Нет
43 ADI Сложение Acc ← Acc + I
44 SBI Вычитание Acc ← Acc – I
45 MULI Умножение Acc ← Acc × I
46 DIVI Деление Acc ← Acc/I
Таблица 9.7. Таблица кодов ASCII (фрагмент)
0 1 2 3 4 5 6 7 8 9 A B C D E F
0 0 @ P ‘ p А Р а р
1 ! 1 A Q a q Б С б с
2 " 2 B R b r В Т в т
3 # 3 C S c s Г У г у
4 $ 4 D T d t Д Ф д ф
5 % 5 E U e u Е Х е х
6 & 6 F V f v Ж Ц ж ц
7 ‘ 7 G W g w З Ч з ч
8 ( 8 H X h x Ё ё И Ш и ш
9 ) 9 I Y i y Й Щ й щ
A * : J Z j z К Ъ к ъ
B + ; K [ k { Л Ы л ы
C , < L l | М Ь м ь
D - = M ] m } Н Э н э
E . > N n O Ю о ю
F / ? O _ o П Я п я
Глава 9. Описание архитектуры учебной ЭВМ 287
Таблица 9.8. Перевод НЕХ-кодов в десятичные числа
0 1 2 3 4 5 6 7 8 9 A B C D E F
0 0 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240
1 1 17 33 49 65 81 97 113 129 145 161 177 193 209 225 241
2 2 18 34 50 66 82 98 114 130 146 162 178 194 210 226 242
3 3 19 35 51 67 83 99 115 131 147 163 179 195 211 227 243
4 4 20 36 52 68 84 100 116 132 148 164 180 196 212 228 244
5 5 21 37 53 69 85 101 117 133 149 165 181 197 213 229 245
6 6 22 38 54 70 86 102 118 134 150 166 182 198 214 230 246
7 7 23 39 55 71 87 103 119 135 151 167 183 199 215 231 247
8 8 24 40 56 72 88 104 120 136 152 168 184 200 216 232 248
9 9 25 41 57 73 89 105 121 137 153 169 185 201 217 233 249
A 10 26 42 58 74 90 106 122 138 154 170 186 202 218 234 250
B 11 27 43 59 75 91 107 123 139 155 171 187 203 219 235 251
C 12 28 44 60 76 92 108 124 140 156 172 188 204 220 236 252
D 13 29 45 61 77 93 109 125 141 157 173 189 205 221 237 253
E 14 30 46 62 78 94 110 126 142 158 174 190 206 222 238 254
F 15 31 47 63 79 95 111 127 143 159 175 191 207 223 239 255
Глава 10
Лабораторные работы
Цикл лабораторных работ рассчитан на выполнение студентами в рамках
изучения курсов "Арифметические и логические основы ЭВМ", "Прикладная
теория цифровых автоматов" (№ 1, 2), "Архитектура ЭВМ" и других, подоб-
ных по содержанию (№ 3—10).
Работы № 1, 2 выполняются на программной модели АЛУ (ALU-1 или ALU-R,
описанных в главе 8), работы № 3—10 выполняются на программной модели
учебной ЭВМ и взаимодействующих с ней программных моделях ВУ и кэш-
памяти, описанных в главе 9.
Цикл включает работы и задания различного уровня. Так, в работе № 1 пред-
лагаются как варианты заданий для реализации простых алгоритмов (сложе-
ния/вычитания), так и более сложные задания, требующие организации цик-
лов (умножение, деление, сравнение весов двоичных векторов и т. п.). Работа
№ 2 предполагает "погружение" разработанной и отлаженной в первой рабо-
те микропрограммы в память управляющего автомата. Ее сложность соответ-
ствует сложности заданного (выбранного) алгоритма первой работы.
Лабораторные работы № 3—6 ориентированы на первичное знакомство с ар-
хитектурой процессора, системой команд, способами адресации и основными
приемами программирования на машинно-ориентированном языке. Лабора-
торная работа № 7 иллюстрирует реализацию командного цикла процессора
на уровне микроопераций. Лабораторная работа № 8 посвящена способам
организации связи процессора с внешними устройствами, а в лабораторных
работах № 9 и 10 рассматривается организация кэш-памяти и эффективность
различных алгоритмов замещения.
Описание работы включает постановку задачи, пример выполнения, набор
вариантов индивидуальных заданий, порядок выполнения работы, требова-
ния к содержанию отчета и контрольные вопросы.
Глава 10. Лабораторные работы 289
10.1. Лабораторная работа № 1.
Разработка алгоритма и микропрограммы
арифметической операции
В главе 3 подробно рассмотрены алгоритмы выполнения основных арифме-
тических операций. В данной работе следует разработать алгоритм задан-
ной (выбранной) операции с учетом выбранной вами среды реализации —
ОА ALU-1 или ALU-R.
10.1.1. Арифметические операции
сложения и вычитания
Эти задания не требуют реализации циклов в микропрограммах, достаточно
использовать лишь переходы, в зависимости от принятого способа кодирова-
ния операндов и сочетания их знаков.
В табл. 10.1 приведены варианты заданий. Их особенность состоит в том, что
часто операнды и результат представляются в различных кодах. Конечно,
в реальных АЛУ такого разнобоя в кодировке быть не может (это значитель-
но усложняет алгоритм при отсутствии преимуществ реализации). Однако
в учебных заданиях такой подход можно считать приемлемым, поскольку
это, во-первых, увеличивает разнообразие вариантов и, во-вторых, позволяет
читателю в рамках одного задания вспомнить особенности выполнения опе-
рации в различных кодах.
В табл. 10.1 приняты следующие обозначения:
􀂈 ПК — прямой код;
􀂈 ОК — обратный код;
􀂈 ДК — дополнительный код.
В задании указываются операция, код выполнения операции, коды входных
операндов и код результата. Если код выполнения операции прямой, необхо-
димо в процессе ее выполнения перевести оба операнда в прямой код и осу-
ществить заданную операцию с использованием микроопераций суммирова-
ния или вычитания двоичных векторов.
Если код выполнения операции дополнительный (обратный), необходимо
в процессе выполнения операции перевести оба операнда в дополнительный
(обратный) код. В случае выполнения вычитания далее необходимо опреде-
лить дополнительный (обратный) код противоположного по знаку числа,
осуществить операцию с использованием микрооперации суммирования дво-
Часть III. Лабораторный 290 практикум и курсовое проектирование
ичных векторов и, возможно, провести коррекцию результата. После выпол-
нения операции результат необходимо перевести в код, указанный в задании
как код результата.
Таблица 10.1. Варианты задания
№ Тип
операции
Код
1 операнда
Код
2 операнда
Код
выполнения
Код
результата
1 Сложение ПК ДК ОК ПК
2 Сложение ОК ПК ДК ПК
3 Вычитание ДК ПК ДК ПК
4 Сложение ПК ПК ОК ДК
5 Вычитание ДК ПК ДК ПК
6 Вычитание ПК ДК ПК ДК
7 Сложение ПК ПК ДК ПК
8 Сложение ДК ПК ПК ДК
9 Сложение ПК ПК ОК ДК
10 Вычитание ПК ПК ПК ПК
11 Сложение ПК ПК ОК ПК
12 Сложение ДК ПК ДК ДК
13 Вычитание ПК ПК ОК ПК
14 Сложение ПК ОК ДК ДК
В качестве образца реализации подобных заданий можно рассмотреть при-
меры 8.1 и 8.2.
10.1.2. Задания повышенной сложности
1. Разработать и отладить микропрограмму умножения. Формат сомножите-
лей — целое без знака, 8 бит. Формат произведения — целое без знака, 16 бит.
2. Разработать и отладить микропрограмму умножения. Формат сомножите-
лей — правильная дробь без знака, 8 бит. Формат произведения — пра-
вильная дробь без знака, 16 бит.
3. Разработать и отладить микропрограмму умножения. Формат сомножите-
лей — правильная дробь без знака, 8 бит. Формат произведения — пра-
вильная дробь без знака, 8 бит без округления.
Глава 10. Лабораторные работы 291
4. Разработать и отладить микропрограмму умножения. Формат сомножи-
телей — правильная дробь без знака, 8 бит. Формат произведения — пра-
вильная дробь без знака, 8 бит с округлением.
5. Разработать и отладить микропрограмму умножения. Формат сомножи-
телей и произведения — правильная дробь со знаком, 8 бит, прямой код.
6. Разработать и отладить микропрограмму умножения. Формат сомножи-
телей — правильная дробь со знаком, 8 бит, прямой код. Формат произ-
ведения — правильная дробь со знаком, 16 бит, прямой код.
7. Разработать и отладить микропрограмму умножения. Формат сомножи-
телей — целое без знака, 4 бита. Формат произведения — целое без зна-
ка, 8 бит.
8. Разработать и отладить микропрограмму деления методом "без восста-
новления остатка". Формат операндов и результата — правильная дробь
без знака, 8 бит. Результат не округляется.
9. Разработать и отладить микропрограмму деления методом "с восстанов-
лением остатка". Формат операндов и результата — правильная дробь без
знака, 8 бит. Результат не округляется.
10. Определить вес (количество единичных компонент) двоичного вектора.
11. Определить расстояние Хэмминга (количество несовпадающих компо-
нентов) между двумя двоичными векторами.
12. Сравнить веса двоичных векторов.
13. Определить позиции старшей единицы и младшего нуля двоичного век-
тора.
14. Определить позиции младшей единицы и старшего нуля двоичного век-
тора.
10.1.3. Порядок выполнения заданий
Задания как первой, так и второй группы можно выполнять на программной
модели ОА АЛУ ALU-1 или ALU-R. В рамках выполнения задания необхо-
димо:
1. Разработать граф-схему (ГСА) или текстовое описание алгоритма задан-
ной операции.
2. Разработать микропрограмму (в терминах микроопераций и логических
условий), реализующую разработанный в п. 1 алгоритм для ОА выбран-
ной модели АЛУ (ALU-1 или ALU-R).
Часть III. Лабораторный 292 практикум и курсовое проектирование
3. Проверить выполнение разработанной микропрограммы на нескольких
тестовых примерах (в частности, для микропрограммы выполнения ариф-
метической операции должны быть рассмотрены случаи одинаковых
и разных знаков операндов, отсутствия и наличия переполнения и т. д.),
убедиться в корректности работы микропрограммы для всех возможных
вариантов сочетаний операндов.
4. Предложить структуру операционного автомата (ОА), оптимальную для
реализации разработанного алгоритма.
10.1.4. Содержание отчета
1. Формулировка варианта задания.
2. Разработанный алгоритм заданной операции в форме ГСА.
3. Микропрограмма, соответствующая разработанному алгоритму и струк-
туре операционного автомата, на котором предполагается ее реализовать
(ALU-1 или ALU-R). Микропрограмму можно представить в форме
граф-схемы или в табличной форме, подобно приведенной в приме-
рах 8.1 или 8.2.
4. Результат тестирования микропрограммы на нескольких примерах (в фор-
ме таблицы, подобной табл. 8.4).
5. Структуру операционного автомата, оптимизированную для выполнения
только одной заданной операции (функциональная схема, список микро-
операций и логических условий).
10.1.5. Контрольные вопросы
1. Как обнаружить факт переполнения разрядной сетки при выполнении
операции алгебраического сложения в прямом коде? В обратном? В до-
полнительном?
2. По какому признаку можно завершать цикл умножения?
3. Как определить знак произведения при умножении дробных чисел, пред-
ставленных в прямом коде?
4. Как формируется очередная цифра частного при выполнении операции
деления методом "с восстановлением остатка"?
5. В чем отличие и преимущество метода деления "без восстановления ос-
татка" по сравнению с методом "с восстановлением остатка"?
6. Каким образом можно определить в АЛУ вес двоичного вектора?
Глава 10. Лабораторные работы 293
10.2. Лабораторная работа № 2.
Программирование управляющего автомата
Лабораторная работа № 2 является прямым продолжением работы № 1, по-
этому не предусматривает отдельных заданий. Необходимо разработанную
для выбранного типа АЛУ и протестированную микропрограмму, получен-
ную в работе № 1, запрограммировать и разместить в памяти соответствую-
щего управляющего автомата с программируемой логикой.
Форматы микрокоманд и способы программирования моделей УАПЛ под-
робно описаны в разд. 8.1.2 (для ALU-1) и 8.2.2 (для ALU-R).
10.2.1. Порядок выполнения заданий при работе
с программной моделью ALU-1
1. Выяснить, является ли разбиение микроопераций, предлагаемое по умол-
чанию стандартной таблицей кодировки, приемлемым для реализации
разработанной микропрограммы операционного автомата.
2. Если стандартное разбиение неприемлемо, разбить множество использо-
ванных в исходной микропрограмме микроопераций (МО) на подмноже-
ства несовместимых МО, закодировать микрооперации в подмножествах,
модернизировать таблицу кодировки и сохранить ее в отдельном файле.
3. Записать микропрограмму на языке микроассемблера, описанного в разд. 8.1.2,
и откомпилировать ее. При необходимости устранить синтаксические
ошибки.
4. Отладить микропрограмму в автономном режиме, задавая различные
значения логических условий вручную.
5. В режиме Управление от управляющего автомата проверить функциони-
рование АЛУ под управлением отлаженной микропрограммы на несколь-
ких примерах.
10.2.2. Содержание отчета при работе
с программной моделью ALU-1
1. Формулировка варианта задания — микропрограмма, подготовленная
в работе № 1.
2. Анализ пригодности разбиения множества микроопераций ОА По умол-
чанию для реализации исходной микропрограммы.
Часть III. Лабораторный 294 практикум и курсовое проектирование
3. В случае непригодности предлагаемого по умолчанию разбиения — соб-
ственный вариант разбиения и кодировки множества микроопераций.
4. Текст микропрограммы на языке микроассемблера.
5. Содержимое памяти микропрограмм УАПЛ (полученное после компиля-
ции текста микропрограммы). При необходимости — изменения, внесен-
ные в память при отладке микропрограммы.
6. Тестовые примеры, выполненные в процессе проверки работы АЛУ под
управлением УАПЛ.
10.2.3. Порядок выполнения заданий при работе
с программной моделью ALU-R
1. Подготовить исходную микропрограмму (полученную в результате вы-
полнения работы № 1) в форме, подобной табл. 8.5. При этом в столбце
Метки лучше сразу помещать абсолютные адреса (если размер микропро-
граммы и ваша внимательность позволяет это сделать). Следует помнить,
что две последовательные строки таблицы, первой из которых является
микрокоманда, а вторая — условный или безусловный переход, могут
размещаться в памяти УАПЛ в одной микрокоманде.
2. Загрузить двоичный код микропрограммы в память УАПЛ. Для этого сле-
дует открыть вкладку УА, установить флажок Добавление и, щелкая
мышью по соответствующим мнемоникам полей микрокоманды, занести
в память исходную микропрограмму. Если в ней фигурируют абсолютные
адреса переходов, их сразу можно заносить в поле Адрес, иначе адреса
переходов придется устанавливать при втором проходе.
3. Проверить правильность переходов по микропрограмме в автономном ре-
жиме, задавая различные значения логических условий вручную.
4. Установив флажок Подключить к ОА, отладить загруженную микропро-
грамму на ряде тестовых примеров.
10.2.4. Содержание отчета при работе
с программной моделью ALU-R
1. Формулировка варианта задания — микропрограмма, подготовленная
в работе № 1 в форме табл. 8.5.
2. Дамп памяти УАПЛ с загруженной микропрограммой.
3. Тестовые примеры, выполненные в процессе проверки работы АЛУ под
управлением УАПЛ.
Глава 10. Лабораторные работы 295
10.3. Лабораторная работа № 3.
Архитектура ЭВМ и система команд
10.3.1. Общие положения
Для решения с помощью ЭВМ некоторой задачи должна быть разработана
программа. Программа на языке ЭВМ представляет собой последователь-
ность команд. Код каждой команды определяет выполняемую опера-
цию, тип адресации и адрес. Выполнение программы, записанной в памяти
ЭВМ, осуществляется последовательно по командам в порядке возрастания
адресов команд или в порядке, определяемом командами передачи управ-
ления.
Для того чтобы получить результат выполнения программы, пользователь
должен:
􀂈 ввести программу в память ЭВМ;
􀂈 определить, если это необходимо, содержимое ячеек ОЗУ и РОН, содер-
жащих исходные данные, а также регистров IR и BR;
􀂈 установить в PC стартовый адрес программы;
􀂈 перевести модель в режим Работа.
Каждое из этих действий выполняется посредством интерфейса модели, опи-
санного в главе 8. Ввод программы может осуществляться как в машинных
кодах непосредственно в память модели, так и в мнемокодах в окно Текст
программы с последующим ассемблированием.
Цель настоящей лабораторной работы — знакомство с интерфейсом модели
ЭВМ, методами ввода и отладки программы, действиями основных классов
команд и способов адресации. Для этого необходимо ввести в память ЭВМ
и выполнить в режиме Шаг некоторую последовательность команд (опреде-
ленную вариантом задания) и зафиксировать все изменения на уровне про-
граммно-доступных объектов ЭВМ, происходящие при выполнении этих
команд.
Команды в память учебной ЭВМ вводятся в виде шестиразрядных десятич-
ных чисел (см. форматы команд на рис. 8.3, коды команд и способов адреса-
ции в табл. 8.2—8.4).
В данной лабораторной работе будем программировать ЭВМ в машинных
кодах.
Часть III. Лабораторный 296 практикум и курсовое проектирование
10.3.2. Пример
Дана последовательность мнемокодов, которую необходимо преобразовать
в машинные коды, занести в ОЗУ ЭВМ, выполнить в режиме Шаг и за-
фиксировать изменение состояний программно-доступных объектов ЭВМ
(табл. 10.2).
Таблица 10.2. Команды и коды
Последовательность Значения
Команды RD#20 WR30 ADD #5 WR@30 JNZ 002
Коды 21 1 020 22 0 030 23 1 005 22 2 030 12 0 002
Введем полученные коды последовательно в ячейки ОЗУ, начиная с адреса
000. Выполняя команды в режиме Шаг, будем фиксировать изменения про-
граммно-доступных объектов (в данном случае это Асс, PC и ячейки ОЗУ 020
и 030) в табл. 10.3.
Таблица 10.3. Содержимое регистров
PC Acc M(30) M(20) PC Acc M(30) M(20)
000 000000 000000 000000 004 000025
001 000020 002
002 000020 003 000030
003 000025 004 000030
10.3.3. Задание
1. Ознакомиться с архитектурой ЭВМ (см. часть I).
2. Записать в ОЗУ "программу", состоящую из пяти команд — варианты за-
дания выбрать из табл. 10.4. Команды разместить в последовательных
ячейках памяти.
3. При необходимости установить начальное значение в устройство ввода IR.
4. Определить те программно-доступные объекты ЭВМ, которые будут из-
меняться при выполнении этих команд.
Глава 10. Лабораторные работы 297
5. Выполнить в режиме Шаг введенную последовательность команд, фикси-
руя изменения значений объектов, определенных в п. 4, в таблице (см.
форму табл. 10.3).
6. Если в программе образуется цикл, необходимо просмотреть не более
двух повторений каждой команды, входящей в тело цикла.
Таблица 10.4. Варианты задания
№ IR Команда 1 Команда 2 Команда 3 Команда 4 Команда 5
1 000007 IN MUL #2 WR10 WR @10 JNS 001
2 X RD #17 SUB #9 WR16 WR @16 JNS 001
3 100029 IN ADD #16 WR8 WR@8 JS 001
4 X RD #2 MUL #6 WR 11 WR @11 JNZ 00
5 000016 IN WR8 DIV #4 WR @8 JMP 002
6 X RD #4 WR 11 RD @11 ADD #330 JS 000
7 000000 IN WR9 RD @9 SUB#1 JS 001
8 X RD 4 SUB #8 WR8 WR @8 JNZ 001
9 100005 IN ADD #12 WR 10 WR @10 JS 004
10 X RD 4 ADD #15 WR 13 WR @13 JMP 001
11 000315 IN SUB #308 WR11 WR @11 JMP 001
12 X RD #988 ADD #19 WR9 WR @9 JNZ 001
13 000017 IN WR11 ADD 11 WR @11 JMP 002
14 X RD #5 MUL #9 WR10 WR @10 JNZ 001
10.3.4. Содержание отчета
1. Формулировка варианта задания.
2. Машинные коды команд, соответствующих варианту задания.
3. Результаты выполнения последовательности команд в форме табл. 10.3.
10.3.5. Контрольные вопросы
1. Из каких основных частей состоит ЭВМ и какие из них представлены
в модели?
2. Что такое система команд ЭВМ?
Часть III. Лабораторный 298 практикум и курсовое проектирование
3. Какие классы команд представлены в модели?
4. Какие действия выполняют команды передачи управления?
5. Какие способы адресации использованы в модели ЭВМ? В чем отличие
между ними?
6. Какие ограничения накладываются на способ представления данных
в модели ЭВМ?
7. Какие режимы работы предусмотрены в модели и в чем отличие между
ними?
8. Как записать программу в машинных кодах в память модели ЭВМ?
9. Как просмотреть содержимое регистров процессора и изменить содер-
жимое некоторых регистров?
10. Как просмотреть и, при необходимости, отредактировать содержимое
ячейки памяти?
11. Как запустить выполнение программы в режиме приостановки работы
после выполнения каждой команды?
12. Какие способы адресации операндов применяются в командах ЭВМ?
13. Какие команды относятся к классу передачи управления?
10.4. Лабораторная работа № 4.
Программирование разветвляющегося
процесса
Для реализации алгоритмов, пути в которых зависят от исходных данных,
используют команды условной передачи управления.
10.4.1. Пример
В качестве примера (несколько упрощенного по сравнению с заданиями ла-
бораторной работы № 2) рассмотрим программу вычисления функции
( )
⎪⎩
⎪⎨
⎧
<
−
+ −
− − ≥
=
, при 16,
168
72 6400
11 125, при 16,
2
2
x
x x
x x
y
причем x вводится с устройства ввода IR, результат y выводится на OR.
Граф-схема алгоритма решения задачи показана на рис. 10.1.
Глава 10. Лабораторные работы 299
Рис. 10.1. Граф-схема алгоритма
В данной лабораторной работе используются двухсловные команды с непо-
средственной адресацией, позволяющие оперировать отрицательными чис-
лами и числами по модулю, превышающие 999, в качестве непосредственно-
го операнда.
Оценив размер программы примерно в 20—25 команд, отведем для области
данных ячейки ОЗУ, начиная с адреса 030. Составленная программа с ком-
ментариями представлена в виде табл. 10.5.
Таблица 10.5. Пример программы
Адрес
Команда
Примечание
Мнемокод Код
000 IN 01 0 000 Ввод x
001 WR 30 22 0 030 Размещение x в ОЗУ (ОЗО)
002 SUB #16 24 1 016 Сравнение с границей — (x −16)
003 JS 010 13 0 010 Переход по отрицательной разности
004 RD 30 21 0 030 Вычисления по первой формуле
005 SUB #11 24 1 011
006 WR 31 22 0 031
Часть III. Лабораторный 300 практикум и курсовое проектирование
Таблица 10.5 (окончание)
Адрес
Команда
Примечание
Мнемокод Код
007 MUL 31 25 0 031
008 SUB #125 24 1 125
009 JMP 020 10 0 020 Переход на вывод результата
010 RD 30 21 0 030 Вычисления по второй формуле
011 MUL 30 25 0 030
012 WR 31 22 0 031
013 RD 30 21 0 030
014 MUL #72 25 1 072
015 ADD 31 23 0 031
016 ADI
106400
43 0 000
017 10 6 400
018 DIVI
100168
46 0 000
019 10 0 168
020 OUT 02 0 000 Вывод результата
021 HLT 09 0 000 Стоп
10.4.2. Задание
1. Разработать программу вычисления и вывода значения функции:
⎩ ⎨ ⎧
<
≥
=
( ), при ,
( ), при ,
F x x a
F x x a
y
j
i
для вводимого из IR значения аргумента x . Функции и допустимые пре-
делы изменения аргумента приведены в табл. 10.6, варианты заданий —
в табл. 10.7.
2. Исходя из допустимых пределов изменения аргумента функций (табл. 10.6)
и значения параметра a для своего варианта задания (табл. 10.7) выделить
на числовой оси Ox области, в которых функция y вычисляется по пред-
Глава 10. Лабораторные работы 301
ставленной в п. 1 формуле, и недопустимые значения аргумента. На недо-
пустимых значениях аргумента программа должна выдавать на OR мак-
симальное по модулю отрицательное число: 199 999.
3. Ввести текст программы в окно Текст программы, при этом возможен
набор и редактирование текста непосредственно в окне Текст программы
или загрузка текста из файла, подготовленного в другом редакторе.
4. Ассемблировать текст программы, при необходимости исправить синтак-
сические ошибки.
5. Отладить программу. Для этого:
а) записать в IR значение аргумента x > a (в области допустимых значений);
б) записать в PC стартовый адрес программы;
в) проверить правильность выполнения программы (т. е. правильность ре-
зультата и адреса останова) в автоматическом режиме. В случае нали-
чия ошибки выполнить пп. 5, г и 5, д; иначе перейти к п. 5, е;
г) записать в PC стартовый адрес программы;
д) наблюдая выполнение программы в режиме Шаг, найти команду, яв-
ляющуюся причиной ошибки; исправить ее; выполнить пп. 5, а — 5, в;
е) записать в IR значение аргумента x < a (в области допустимых значе-
ний); выполнить пп. 5, б и 5, в;
ж) записать в IR недопустимое значение аргумента x и выполнить пп. 5, б
и 5, в.
6. Для выбранного допустимого значения аргумента x наблюдать выполне-
ние отлаженной программы в режиме Шаг и записать в форме табл. 10.3
содержимое регистров ЭВМ перед выполнением каждой команды.
Таблица 10.6. Функции
k Fk(x) k Fk(x)
1
17
1
x
x
+
−
; 2 ≤ x ≤12 5 ( )2 2
15
x +
; 50 ≤ x ≤ 75
2 ( )2 x 3
x
+
; 1 ≤ x ≤ 50 6
2x2 7
x
+ ; 1 ≤ x ≤ 30
3
1000
x +10
; −50 ≤ x ≤ −15 7
2 2
10
x + x ; −50 ≤ x ≤ 50
4 ( )3 x + 3 ; −20 ≤ x ≤ 20 8 2
8100
x
; 1 ≤ x ≤ 90
Часть III. Лабораторный 302 практикум и курсовое проектирование
Таблица 10.7. Варианты задания
Номер
варианта i j a Номер
варианта i j a
1 2 1 12 8 8 6 30
2 4 3 –20 9 2 6 25
3 8 4 15 10 5 7 50
4 6 1 12 11 2 4 18
5 5 2 50 12 8 1 12
6 7 3 15 13 7 6 25
7 6 2 11 14 1 4 5
10.4.3. Содержание отчета
Отчет о лабораторной работе должен содержать следующие разделы:
1. Формулировка варианта задания.
2. Граф-схема алгоритма решения задачи.
3. Размещение данных в ОЗУ.
4. Программа в форме табл. 9.5.
5. Последовательность состояний регистров ЭВМ при выполнении програм-
мы в режиме Шаг для одного значения аргумента.
6. Результаты выполнения программы для нескольких значений аргумента,
выбранных самостоятельно.
10.4.4. Контрольные вопросы
1. Как работает механизм косвенной адресации?
2. Какая ячейка будет адресована в команде с косвенной адресацией через
ячейку 043, если содержимое этой ячейки равно 102 347?
3. Как работают команды передачи управления?
4. Что входит в понятие "отладка программы"?
5. Какие способы отладки программы можно реализовать в модели?
Глава 10. Лабораторные работы 303
10.5. Лабораторная работа № 5.
Программирование цикла с переадресацией
При решении задач, связанных с обработкой массивов, возникает необходи-
мость изменения исполнительного адреса при повторном выполнении неко-
торых команд. Эта задача может быть решена путем использования косвен-
ной адресации.
10.5.1. Пример
Разработать программу вычисления суммы элементов массива чисел C1 ,
C2 , ..., Cn . Исходными данными в этой задаче являются: n — количество
суммируемых чисел и C1 , C2 , ..., Cn — массив суммируемых чисел. Заме-
тим, что должно выполняться условие n > 1, т. к. алгоритм предусматривает,
по крайней мере, одно суммирование. Кроме того, предполагается, что сум-
мируемые числа записаны в ОЗУ подряд, т. е. в ячейки памяти с последова-
тельными адресами. Результатом является сумма S .
Рис. 10.2. Граф-схема алгоритма для примера
Часть III. Лабораторный 304 практикум и курсовое проектирование
Составим программу для вычисления суммы со следующими конкретными
параметрами: число элементов массива — 10, элементы массива расположе-
ны в ячейках ОЗУ по адресам 040, 041, 042, ..., 049. Используемые для реше-
ния задачи промежуточные переменные имеют следующий смысл: Ai — ад-
рес числа Ci , i∈{1, 2, ...,10}; ОЗУ( Ai ) — число по адресу Ai , S — текущая
сумма; k — счетчик цикла, определяющий число повторений тела цикла.
Распределение памяти таково. Программу разместим в ячейках ОЗУ, начиная
с адреса 000, примерная оценка объема программы — 20 команд; промежу-
точные переменные: Ai — в ячейке ОЗУ с адресом 030, k — по адресу 031,
S — по адресу 032. ГСА программы показана на рис. 10.2, текст программы
с комментариями приведен в табл. 10.8.
Таблица 10.8. Текст программы примера
Адрес Команда Примечание
000 RD #40 Загрузка начального адреса массива 040
001 WR 30 в ячейку 030
002 RD #10 Загрузка параметра цикла k =10 в ячейку 031
003 WR 31
004 RD #0 Загрузка начального значения суммы S = 0
005 WR 32 в ячейку 032
006 M1: RD 32 Добавление
007 ADD @30 к текущей сумме
008 WR 32 очередного элемента массива
009 RD30 Модификация текущего
010 ADD #1 адреса массива
011 WR 30 (переход к следующему адресу)
012 RD 31 Уменьшение счетчика
013 SUB #1 (параметра цикла)
014 WR 31 на 1
015 JNZ M1 Проверка параметра цикла и переход при k ≠ 0
016 RD 32 Вывод
017 OUT результата
018 HLT Стоп
Глава 10. Лабораторные работы 305
10.5.2. Задание
1. Написать программу определения заданной характеристики после-
довательности чисел C1 , C2 , ..., Cn . Варианты заданий приведены
в табл. 10.9.
2. Записать программу в мнемокодах, введя ее в поле окна Текст программы.
3. Сохранить набранную программу в виде текстового файла и произвести
ассемблирование мнемокодов.
4. Загрузить в ОЗУ необходимые константы и исходные данные.
5. Отладить программу.
Таблица 10.9. Варианты задания
Номер варианта Характеристика последовательности чисел C1, C2, ..., Сn
1 Количество четных чисел
2 Номер минимального числа
3 Произведение всех чисел
4 Номер первого отрицательного числа
5 Количество чисел, равных C1
6 Количество отрицательных чисел
7 Максимальное отрицательное число
8 Номер первого положительного числа
9 Минимальное положительное число
10 Номер максимального числа
11 Количество нечетных чисел
12 Количество чисел, меньших C1
13 Разность сумм четных и нечетных элементов массивов
14 Отношение сумм четных и нечетных элементов массивов
Примечание. Под четными (нечетными) элементами массивов понимаются элементы масси-
вов, имеющие четные (нечетные) индексы. Четные числа — элементы массивов, делящиеся
без остатка на 2.
Часть III. Лабораторный 306 практикум и курсовое проектирование
10.5.3. Содержание отчета
1. Формулировка варианта задания.
2. Граф-схема алгоритма решения задачи.
3. Распределение памяти (размещение в ОЗУ переменных, программы и не-
обходимых констант).
4. Программа.
5. Значения исходных данных и результата выполнения программы.
10.5.4. Контрольные вопросы
1. Как организовать цикл в программе?
2. Что такое параметр цикла?
3. Как поведет себя программа, приведенная в табл. 10.8, если в ней будет
отсутствовать команда WR 31 по адресу 014?
4. Как поведет себя программа, приведенная в табл. 10.8, если метка Ml бу-
дет поставлена по адресу 005? 007?
10.6. Лабораторная работа № 6.
Подпрограммы и стек
В программировании часто встречаются ситуации, когда одинаковые дейст-
вия необходимо выполнять многократно в разных частях программы (напри-
мер, вычисление функции sin x ). При этом с целью экономии памяти не сле-
дует многократно повторять одну и ту же последовательность команд —
достаточно один раз написать так называемую подпрограмму (в терминах
языков высокого уровня — процедуру) и обеспечить правильный вызов этой
подпрограммы и возврат в точку вызова по завершению подпрограммы.
Для вызова подпрограммы необходимо указать ее начальный адрес в памяти
и передать (если необходимо) параметры — те исходные данные, с которыми
будут выполняться предусмотренные в подпрограмме действия. Адрес под-
программы указывается в команде вызова CALL, а параметры могут переда-
ваться через определенные ячейки памяти, регистры или стек.
Возврат в точку вызова обеспечивается сохранением адреса текущей коман-
ды (содержимого регистра PC) при вызове и использованием в конце подпро-
граммы команды возврата RET, которая возвращает сохраненное значение
адреса возврата в PC.
Глава 10. Лабораторные работы 307
Для реализации механизма вложенных подпрограмм (возможность вызова
подпрограммы из другой подпрограммы и т. д.) адреса возврата целесообраз-
но сохранять в стеке. Стек ("магазин") — особым образом организованная
безадресная память, доступ к которой осуществляется через единственную
ячейку, называемую верхушкой стека. При записи слово помещается в вер-
хушку стека, предварительно все находящиеся в нем слова смещаются вниз на
одну позицию; при чтении извлекается содержимое верхушки стека (оно при
этом из стека исчезает), а все оставшиеся слова смещаются вверх на одну пози-
цию. Такой механизм напоминает действие магазина стрелкового оружия (от-
сюда и второе название). В программировании называют такую дисциплину
обслуживания LIFO (Last In First Out, последним пришел — первым вышел)
в отличие от дисциплины типа очередь — FIFO (First In First Out, первым
пришел — первым вышел).
В обычных ОЗУ нет возможности перемещать слова между ячейками, поэто-
му при организации стека перемещается не массив слов относительно непод-
вижной верхушки, а верхушка относительно неподвижного массива. Под
стек отводится некоторая область ОЗУ, причем адрес верхушки хранится
в специальном регистре процессора — указателе стека SP.
В стек можно поместить содержимое регистра общего назначения по коман-
де PUSH или извлечь содержимое верхушки в регистр общего назначения по
команде POP. Кроме того, по команде вызова подпрограммы CALL значение
программного счетчика PC (адрес следующей команды) помещается в вер-
хушку стека, а по команде RET содержимое верхушки стека извлекается в PC.
При каждом обращении в стек указатель SP автоматически модифицируется.
В большинстве ЭВМ стек "растет" в сторону меньших адресов, поэтому пе-
ред каждой записью содержимое SP уменьшается на 1, а после каждого из-
влечения содержимое SP увеличивается на 1. Таким образом, SP всегда ука-
зывает на верхушку стека.
Цель настоящей лабораторной работы — изучение организации программ
с использованием подпрограмм. Кроме того, в процессе организации циклов
мы будем использовать новые возможности системы команд модели ЭВМ,
которые позволяют работать с новым классом памяти — сверхоперативной
(регистры общего назначения — РОН). В реальных ЭВМ доступ в РОН за-
нимает значительно меньшее время, чем в ОЗУ; кроме того, команды обра-
щения с регистрами короче команд обращения к памяти. Поэтому в РОН
размещаются наиболее часто используемые в программе данные, промежу-
точные результаты, счетчики циклов, косвенные адреса и т. п.
В системе команд учебной ЭВМ для работы с РОН используются специаль-
ные команды, мнемоники которых совпадают с мнемониками соответствую-
Часть III. Лабораторный 308 практикум и курсовое проектирование
щих команд для работы с ОЗУ, но в адресной части содержат символы реги-
стров R0—R9.
Кроме обычных способов адресации (прямой и косвенной) в регистровых
командах используются два новых — постинкрементная и преддекрементная
(см. табл. 9.5). Кроме того, к регистровым относится команда организации
цикла JRNZ R,М. По этой команде содержимое указанного в команде регистра
уменьшается на 1, и если в результате вычитания содержимого регистра не
равно 0, то управление передается на метку М. Эту команду следует ставить
в конце тела цикла, метку М — в первой команде тела цикла, а в регистр R
помещать число повторений цикла.
10.6.1. Пример
Даны три массива чисел. Требуется вычислить среднее арифметическое их
максимальных элементов. Каждый массив задается двумя параметрами: ад-
ресом первого элемента и длиной.
Очевидно, в программе трижды необходимо выполнить поиск максимально-
го элемента массива, поэтому следует написать соответствующую подпро-
грамму.
Параметры в подпрограмму будем передавать через регистры: R1 — началь-
ный адрес массива, R2 — длина массива.
Рассмотрим конкретную реализацию этой задачи. Пусть первый массив на-
чинается с адреса 085 и имеет длину 14 элементов, второй — 100 и 4, тре-
тий — 110 и 9. Программа будет состоять из основной части и подпрограммы.
Основная программа задает параметры подпрограмме, вызывает ее и сохра-
няет результаты работы подпрограммы в рабочих ячейках. Затем осуществ-
ляет вычисление среднего арифметического и выводит результат на устрой-
ство вывода. В качестве рабочих ячеек используются регистры общего
назначения R6 и R7 — для хранения максимальных элементов массивов.
Подпрограмма получает параметры через регистры R1 (начальный адрес
массива) и R2 (длина массива). Эти регистры используются подпрограммой
в качестве регистра текущего адреса и счетчика цикла соответственно. Кроме
того, R3 используется для хранения текущего максимума, а R4 — для вре-
менного хранения текущего элемента. Подпрограмма возвращает результат
через аккумулятор. В табл. 10.10 приведен текст основной программы и под-
программы. Обратите внимание, цикл в подпрограмме организован с помо-
щью команды JRNZ, а модификация текущего адреса — средствами пост-
инкрементной адресации.
Глава 10. Лабораторные работы 309
Таблица 10.10. Программа примера
Команда Примечания
Основная программа
RD #85 Загрузка
WR R1 параметров
RD #14 первого
WR R2 массива
CALL M Вызов подпрограммы
WR R6 Сохранение результата
RD #100 Загрузка
WR R1 параметров
RD #4 второго
WR R2 массива
CALL M Вызов подпрограммы
WR R7 Сохранение результата
RD #110 Загрузка
WR R1 параметров
RD #9 третьего
WR R2 массива
CALL M Вызов подпрограммы
ADD R7 Вычисление
ADD R6 среднего
DIV #3 арифметического
OUT Вывод результата
HLT Стоп
Подпрограмма MAX
M: RD @R1 Загрузка
WR R3 первого элемента в R3
L2: RD @R1+ Чтение элемента и модификация адреса
WR R4 Сравнение
Часть III. Лабораторный 310 практикум и курсовое проектирование
Таблица 10.10 (окончание)
Команда Примечания
Подпрограмма MAX
SUB R3 и замена,
JS L1 если R3 < R4
MOV R3,R4
L1: JRNZ R2,L2 Цикл
RD R3 Чтение результата в Асс
RET Возврат
10.6.2. Задание
Составить и отладить программу учебной ЭВМ для решения следующей за-
дачи. Три массива в памяти заданы начальными адресами и длинами. Вычис-
лить и вывести на устройство вывода среднее арифметическое параметров
этих массивов. Параметры определяются заданием к предыдущей лаборатор-
ной работе (см. табл. 10.9), причем соответствие между номерами вариантов
заданий к лабораторным работам № 5 и 6 устанавливается по табл. 10.11.
Таблица 10.11. Соответствие между номерами заданий
Номер варианта
задания к л. р. № 6 1 2 3 4 5 6 7 8 9
1
0
1
1
1
2
1
3
1
4
Номер строки
в табл. 10.9 5 7
1
3
1
1
9
1
2
1
1
0
1
4
3 6 8 2 4
10.6.3. Содержание отчета
1. Формулировка варианта задания.
2. Граф-схема алгоритма основной программы.
3. Граф-схема алгоритма подпрограммы.
4. Распределение памяти (размещение в ОЗУ переменных, программы и не-
обходимых констант).
5. Тексты программы и подпрограммы.
6. Значения исходных данных и результата выполнения программы.
Глава 10. Лабораторные работы 311
10.6.4. Контрольные вопросы
1. Как работает команда MOV R3, R7?
2. Какие действия выполняет процессор при реализации команды CALL?
3. Как поведет себя программа примера из разд. 10.6.1, если в ней вместо
команд CALL M использовать команды JMP M?
4. После начальной установки процессора (сигнал Сброс) указатель стека SP
устанавливается в 000. По какому адресу будет производиться запись
в стек первый раз, если не загружать SP командой WRSP?
5. Как, используя механизмы постинкрементной и преддекрементной адре-
сации, организовать дополнительный стек в произвольной области памя-
ти, не связанный с SP?
10.7. Лабораторная работа № 7.
Командный цикл процессора
Реализация программы в ЭВМ сводится к последовательному выполнению
команд. Каждая команда, в свою очередь, выполняется как последователь-
ность микрокоманд, реализующих элементарные действия над операцион-
ными элементами процессора.
В программной модели учебной ЭВМ предусмотрен Режим микрокоманд,
в котором действие командного цикла реализуется и отображается на уровне
микрокоманд. Список микрокоманд текущей команды выводится в специ-
альном окне Микрокомандный уровень (см. рис. 9.8).
10.7.1. Задание 1
Выполнить снова последовательность команд по варианту задания из
разд. 10.3.3 (см. табл. 10.4), но в режиме Шаг. Зарегистрировать изменения
состояния процессора и памяти в форме табл. 10.12, в которой приведены
состояния ЭВМ при выполнении примера из разд. 10.3.2 (фрагмент).
10.7.2. Задание 2
Записать последовательность микрокоманд для следующих команд модели
учебной ЭВМ:
􀂈 ADD R3
􀂈 ADD @R3
Часть III. Лабораторный 312 практикум и курсовое проектирование
Глава 10. Лабораторные работы 313
􀂈 ADD @R3+
􀂈 ADD -@R3
􀂈 JRNZ R3,M
􀂈 MOV R4,R2
􀂈 JMP M
􀂈 CALL M
􀂈 RET: PUSH R3
􀂈 POP R5
10.7.3. Контрольные вопросы
1. Какие микрокоманды связаны с изменением состояния аккумулятора?
2. Какие действия выполняются в модели по микрокоманде MRd? RWr?
3. Попробуйте составить микропрограмму (последовательность микроко-
манд, реализующих команду) для не существующей в данной модели ко-
манды "умножение модулей чисел".
4. Что изменится в работе процессора, если в каждой микропрограмме мик-
рокоманду увеличения программного счетчика PC := РС + 1 переместить
в самый конец микропрограммы?
10.8. Лабораторная работа № 8.
Программирование внешних устройств
Целью этой лабораторной работы является изучение способов организации
взаимодействия процессора и внешних устройств (ВУ) в составе ЭВМ.
Ранее отмечалось, что связь процессора и ВУ может осуществляться в син-
хронном или асинхронном режиме. Синхронный режим используется для
ВУ, всегда готовых к обмену. В нашей модели такими ВУ являются дисплей
и тоногенератор — процессор может обращаться к этим ВУ, не анализируя
их состояние (правда дисплей блокирует прием данных после ввода 128 сим-
волов, формируя флаг ошибки).
Асинхронный обмен предполагает анализ процессором состояния ВУ, кото-
рое определяет готовность ВУ выдать или принять данные или факт осуще-
ствления некоторого события, контролируемого системой. К таким устройст-
вам в нашей модели можно отнести клавиатуру и блок таймеров.
Часть III. Лабораторный 314 практикум и курсовое проектирование
Анализ состояния ВУ может осуществляться процессором двумя способами:
􀂈 в программно-управляемом режиме;
􀂈 в режиме прерывания.
В первом случае предполагается программное обращение процессора к реги-
стру состояния ВУ с последующим анализом значения соответствующего
разряда слова состояния. Такое обращение следует предусмотреть в про-
грамме с некоторой периодичностью, независимо от фактического наступле-
ния контролируемого события (например, нажатие клавиши).
Во втором случае при возникновении контролируемого события ВУ форми-
рует процессору запрос на прерывание программы, по которому процессор и
осуществляет связь с ВУ.
10.8.1. Задание
Свой вариант задания (табл. 10.13) требуется выполнить двумя способами —
сначала в режиме программного контроля, далее модифицировать программу
таким образом, чтобы события обрабатывались в режиме прерывания про-
граммы. Поскольку "фоновая" (основная) задача для этого случая в заданиях
отсутствует, роль ее может сыграть "пустой цикл":
M: NOP
NOP
JMP M
Таблица 10.13. Варианты задания
№ ва-
рианта Задание Используемые
ВУ Пояснения
1 Ввод пятиразрядных
чисел в ячейки ОЗУ
Клавиатура Программа должна обеспечивать
ввод последовательности ASCII-
кодов десятичных цифр (не длиннее
пяти), перекодировку в "8421", упа-
ковку в десятичное число (первый
введенный символ — старшая циф-
ра) и размещение в ячейке ОЗУ.
ASCII-коды не-цифр игнорировать
2 Программа ввода сим-
волов с клавиатуры с
выводом на дисплей
Клавиатура,
дисплей,
таймер
Очистка буфера клавиатуры после
ввода 50 символов или каждые 10 с
Глава 10. Лабораторные работы 315
Таблица 10.13 (продолжение)
№ ва-
рианта Задание Используемые
ВУ Пояснения
3 Вывод на дисплей трех
текстов, хранящихся в
памяти, с задержкой
Дисплей,
таймер
Первый текст выводится сразу при
запуске программы, второй — через
15 с, третий — через 20 с после вто-
рого
4 Вывод на дисплей од-
ного из трех текстовых
сообщений, в зависи-
мости от нажатой кла-
виши
Клавиатура,
дисплей
<1> — вывод на дисплей первого
текстового сообщения, <2> — вто-
рого, <3> — третьего, остальные
символы — нет реакции
5 Выбирать из потока
ASCII-кодов только
цифры и выводить их
на дисплей
Клавиатура,
дисплей,
тоногенератор
Вывод каждой цифры сопровожда-
ется коротким звуковым сигналом
6 Выводить на дисплей
каждый введенный с
клавиатуры символ,
причем цифру выводить
"в трех экземплярах"
Клавиатура,
дисплей,
тоногенератор
Вывод каждой цифры сопровожда-
ется троекратным звуковым сигна-
лом
7 Селективный ввод сим-
волов с клавиатуры
Клавиатура,
дисплей
Все русские буквы, встречающиеся
в строке ввода — в верхнюю часть
экрана дисплея (строки 1—4), все
цифры — в нижнюю часть экрана
(строки 5—8), остальные символы
не выводить
8 Вывод содержимого за-
данного участка памяти
на дисплей посимвольно
с заданным промежутком
времени между выводами
символов
Дисплей,
таймер
Остаток от деления на 256 трех
младших разрядов ячейки памяти
рассматривается как ASCII-код сим-
вола. Начальный адрес памяти, длина
массива вывода и промежуток време-
ни — параметры подпрограммы
9 Программа ввода сим-
волов с клавиатуры
с выводом на дисплей
Клавиатура,
дисплей
Очистка буфера клавиатуры после
ввода 35 символов
10 Выводить на дисплей
каждый введенный с
клавиатуры символ,
причем заглавную рус-
скую букву выводить
"в двух экземплярах"
Клавиатура,
дисплей,
таймер
Очистка буфера клавиатуры после
ввода 48 символов, очистка экрана
каждые 15 с
Часть III. Лабораторный 316 практикум и курсовое проектирование
Таблица 10.13 (окончание)
№ ва-
рианта Задание Используемые
ВУ Пояснения
11 Вывод на дисплей со-
держимого группы яче-
ек памяти в числовой
форме (адрес и длина
группы — параметры
подпрограммы)
Дисплей,
таймер
Содержимое ячейки распаковывает-
ся (с учетом знака), каждая цифра
преобразуется в соответствующий
ASCII-код и выдается на дисплей.
При переходе к выводу содержимого
очередной ячейки формируется за-
держка 10 с
12 Определить промежу-
ток времени между
двумя последователь-
ными нажатиями кла-
виш
Клавиатура,
таймер
Результат выдается на OR. (Учиты-
вая инерционность модели, нажатия
не следует производить слишком
быстро.)
10.8.2. Задания повышенной сложности
1. Разработать программу-тест на скорость ввода символов с клавиатуры. По
звуковому сигналу включается клавиатура и таймер на T секунд. Можно
начинать ввод символов, причем каждый символ отображается на дис-
плее, ведется подсчет количества введенных символов (после каждых 50
дается команда на очистку буфера клавиатуры, после 128 — очищается
дисплей). Переполнение таймера выключает клавиатуру и включает сиг-
нал завершения ввода (можно тон этого сигнала сопоставить с количест-
вом введенных символов). Параметр T вводится из IR. Результат S —
средняя скорость ввода (символ/с) выдается на OR. Учитывая, что модель
учебной ЭВМ оперирует только целыми числами, можно выдавать ре-
зультат в формате S × 60 символов/мин.
2. Разработать программу-тест на степень запоминания текста. Три различ-
ных варианта текста выводятся последовательно на дисплей на T1 секунд
с промежутками T2 секунд. Далее эти тексты (то, что запомнилось) вво-
дятся с клавиатуры (в режиме ввода строки) и программно сравниваются
с исходными текстами. Выдается количество (процент) ошибок.
3. Разработать программу-калькулятор. Осуществлять ввод из буфера кла-
виатуры последовательности цифр, упаковку (см. вариант 1 в табл. 10.13).
Разделители — знаки бинарных арифметических операций и =. Результат
переводится в ASCII-коды и выводится на дисплей.
Глава 10. Лабораторные работы 317
10.8.3. Порядок выполнения работы
1. Запустить программную модель учебной ЭВМ и подключить к ней опре-
деленные в задании внешние устройства (меню Внешние устройства |
Менеджер ВУ).
2. Написать и отладить программу, предусмотренную заданием, с использо-
ванием программного анализа флагов готовности ВУ. Продемонстриро-
вать работающую программу преподавателю.
3. Изменить отлаженную в п. 2 программу таким образом, чтобы процессор
реагировал на готовность ВУ с помощью подсистемы прерывания. Про-
демонстрировать работу измененной программы преподавателю.
10.8.4. Содержание отчета
1. Текст программы с программным анализом флагов готовности ВУ.
2. Текст программы с обработчиком прерывания.
10.8.5. Контрольные вопросы
1. При каких условиях устанавливается и сбрасывается флаг готовности кла-
виатуры Rd?
2. Возможно ли в блоке таймеров организовать работу всех трех таймеров
с разной тактовой частотой?
3. Как при получении запроса на прерывание от блока таймеров определить
номер таймера, достигшего состояния 99 999 (00 000)?
4. Какой текст окажется на экране дисплея, если после нажатия в окне обо-
зревателя дисплея кнопки Очистить и загрузки по адресу CR (11) кон-
станты #10 вывести по адресу DR (10) последовательно пять ASCII-кодов
русских букв А, Б, В, Г, Д?
5. В какой области памяти модели ЭВМ могут располагаться программы —
обработчики прерываний?
6. Какие изменения в работе отлаженной вами второй программы произой-
дут, если завершить обработчик прерываний командой RET, а не IRET?
10.9. Лабораторная работа № 9.
Принципы работы кэш-памяти
В разд. 8.8 описаны некоторые алгоритмы замещения строк кэш-памяти.
Цель настоящей лабораторной работы — проверить работу различных алго-
ритмов замещения при различных режимах записи.
Часть III. Лабораторный 318 практикум и курсовое проектирование
10.9.1. Задание
В качестве задания предлагается некоторая короткая "программа" (табл. 10.15),
которую необходимо выполнить с подключенной кэш-памятью (размером 4
и 8 ячеек) в шаговом режиме для следующих двух вариантов алгоритмов за-
мещения (табл. 10.14).
Таблица 10.14. Пояснения к вариантам задания
Номера вариантов Режим записи Алгоритм замещения
1, 7, 11 Сквозная СЗ, без учета бита записи
Обратная О, с учетом бита записи
2, 5, 9 Сквозная БИ, без учета бита записи
Обратная О, с учетом бита записи
3, 6, 12 Сквозная О, без учета бита записи
Обратная СЗ, с учетом бита записи
4, 8, 10 Сквозная БИ, без учета бита записи
Обратная БИ, с учетом бита записи
Таблица 10.15. Варианты задания
№
вари-
анта
Номера команд программы
1 2 3 4 5 6 7
1 RD #12 WR 10 WR @10 ADD 12 WR R0 SUB 10 PUSH R0
2 RD #65 WRR2 MOV R4,R2 WR 14 PUSH R2 POP R3 CALL 002
3 RD #16 SUB #5 WR 9 WR @9 WR R3 PUSH R3 POP R4
4 RD #99 WR R6 MOV R7,R6 ADD R7 PUSH R7 CALL 006 POP R8
5 RD #11 WR R2 WR -@R2 PUSH R2 CALL 005 POP R3 RET
6 RD #19 SUB #10 WR9 ADD #3 WR ©9 CALL 006 POPR4
7 RD #6 CALL 006 WR11 WRR2 PUSH R2 RET JMP 002
8 RD#8 WRR2 WR @R2+ PUSH R2 POP R3 WR -@R3 CALL 003
9 RD #13 WR14 WR@14 WR@13 ADD 13 CALL 006 RET
10 RD #42 SUB #54 WR16 WR@16 WRR1 ADD @R1+ PUSH R1
11 RD #10 WRR5 ADD R5 WRR6 CALL 005 PUSH R6 RET
12 JMP 006 RD #76 WR 14 WRR2 PUSH R2 RET CALL 001
Глава 10. Лабораторные работы 319
Не следует рассматривать заданную последовательность команд как фраг-
мент программы1. Некоторые конструкции, например, последовательность
команд PUSH R6, RET в общем случае не возвращает программу в точку вызо-
ва подпрограммы. Такие группы команд введены в задание для того, чтобы
обратить внимание студентов на особенности функционирования стека.
10.9.2. Порядок выполнения работы
1. Ввести в модель учебной ЭВМ текст своего варианта программы (см.
табл. 10.15), ассемблировать его и сохранить на диске в виде txt-файла.
2. Установить параметры кэш-памяти размером 4 ячейки, выбрать режим
записи и алгоритм замещения в соответствии с первой строкой своего ва-
рианта из табл. 10.14.
3. В шаговом режиме выполнить программу, фиксируя после каждого шага
состояние кэш-памяти.
4. Для одной из команд записи (WR) перейти в режим Такт и отметить,
в каких микрокомандах происходит изменение кэш-памяти.
5. Для кэш-памяти размером 8 ячеек установить параметры в соответствии
со второй строкой своего варианта из табл. 10.14 и выполнить программу
в шаговом режиме еще раз, фиксируя последовательность номеров заме-
щаемых ячеек кэш-памяти.
10.9.3. Содержание отчета
1. Вариант задания — текст программы и режимы кэш-памяти.
2. Последовательность состояний кэш-памяти размером 4 ячейки при одно-
кратном выполнении программы (команды 1—7).
3. Последовательность микрокоманд при выполнении команды WR с отмет-
кой тех микрокоманд, в которых возможна модификация кэш-памяти.
4. Для варианта кэш-памяти размером 8 ячеек — последовательность номе-
ров замещаемых ячеек кэш-памяти для второго варианта параметров кэш-
памяти при двукратном выполнении программы (команды 1—7).
10.9.4. Контрольные вопросы
1. В чем смысл включения кэш-памяти в состав ЭВМ?
2. Как работает кэш-память в режиме обратной записи? Сквозной записи?
1 Напомним, что программа определяется как последовательность команд, выполне-
ние которых позволит получить некий результат.
Часть III. Лабораторный 320 практикум и курсовое проектирование
3. Как зависит эффективность работы ЭВМ от размера кэш-памяти?
4. В какую ячейку кэш-памяти будет помещаться очередное слово, если сво-
бодные ячейки отсутствуют?
5. Какие алгоритмы замещения ячеек кэш-памяти вам известны?
10.10. Лабораторная работа № 10.
Алгоритмы замещения строк кэш-памяти
Цель работы — изучение влияния параметров кэш-памяти и выбранного ал-
горитма замещения на эффективность работы системы. Эффективность
в данном случае оценивается числом кэш-попаданий по отношению к обще-
му числу обращений к памяти. Учитывая разницу в алгоритмах в режимах
сквозной и обратной записи, эффективность использования кэш-памяти вы-
числяется выражениям (9.2) и (9.3) соответственно для сквозной и обратной
записи.
Очевидно, эффективность работы системы с кэш-памятью будет зависеть не
только от параметров кэш-памяти и выбранного алгоритма замещения, но
и от класса решаемой задачи. Так, линейные программы должны хорошо ра-
ботать с алгоритмами замещения типа очередь, а программы с большим чис-
лом условных переходов, зависящих от случайных входных данных, могут
давать неплохие результаты с алгоритмами случайного замещения. Можно
предположить, что программы, имеющие большое число повторяющихся
участков (часто вызываемых подпрограмм и/или циклов) при прочих равных
условиях обеспечат более высокую эффективность применения кэш-памяти,
чем линейные программы. И, разумеется, на эффективность напрямую дол-
жен влиять размер кэш-памяти.
Для проверки высказанных выше предположений выполняется настоящая
лабораторная работа.
10.10.1. Задание
В данной лабораторной работе все варианты задания одинаковы: исследо-
вать эффективность работы кэш-памяти при выполнении двух разнотипных
программ, написанных и отлаженных вами при выполнении лабораторных
работ № 4 и 6.
10.10.2. Порядок выполнения работы
1. Загрузить в модель учебной ЭВМ отлаженную программу из лаборатор-
ной работы № 4.
Глава 10. Лабораторные работы 321
2. В меню Работа установить режим Кэш-память.
3. В меню Вид выбрать команду Кэш-память, открыв тем самым окно Кэш-
память, в нем нажать первую слева кнопку на панели инструментов, от-
крыв диалоговое окно Параметры кэш-памяти, и установить следующие
параметры кэш-памяти: размер — 4, режим записи — сквозная, алгоритм
замещения — случайное, без учета бита записи (W).
4. Запустить программу в автоматическом режиме; по окончании работы
просмотреть результаты работы кэш-памяти в окне Кэш-память, вычис-
лить значение коэффициента эффективности K и записать в ячейку
табл. 10.16, помеченную звездочкой.
5. Выключить кэш-память модели (Работа | Кэш-память) и изменить один
из ее параметров — установить флаг с учетом бита записи (в окне Пара-
метры кэш-памяти).
6. Повторить п. 4, поместив значение полученного коэффициента эффек-
тивности в следующую справа ячейку табл. 10.16.
7. Последовательно меняя параметры кэш-памяти, повторить пп. 3—5, за-
полняя все ячейки табл. 10.16.
Совет
При очередном запуске программы не забывайте устанавливать процессор
модели в начальное состояние, нажимая кнопку R в окне Процессор!
8. Повторить все действия, описанные в пп. 1—7 для программы из лабора-
торной работы № 6, заполняя вторую таблицу по форме табл. 10.16.
10.10.3. Содержание отчета
1. Две таблицы по форме табл. 10.16 с результатами моделирования про-
грамм из лабораторных работ № 4 и 6 при разных режимах работы кэш-
памяти.
2. Выводы, объясняющие полученные результаты.
10.10.4. Контрольные вопросы
1. Как работает алгоритм замещения очередь при установленном флажке
С учетом бита записи в диалоговом окне Параметры кэш-памяти?
2. Какой алгоритм замещения будет наиболее эффективным в случае приме-
нения кэш-памяти большого объема (в кэш-память целиком помещается
программа)?
Часть III. Лабораторный 322 практикум и курсовое проектирование
3. Как скажется на эффективности алгоритмов замещения учет значения би-
та записи W при работе кэш-памяти в режиме обратной записи? Сквозной
записи?
4. Для каких целей в структуру ячейки кэш-памяти включен бит использова-
ния? Как устанавливается и сбрасывается этот бит?
Таблица 10.16. Результаты эксперимента
Способ Сквозная запись
Алгоритм Случайное замещение Очередь Бит U
Размер без W с W без W с W без W с W
4 *
8
16
32
Способ Обратная запись
Алгоритм Случайное замещение Очередь Бит U
Размер без W с W без W с W без W с W
4
8
16
32
Глава 11
Курсовая работа
11.1. Цель и содержание работы
Целью курсовой работы является:
􀂈 обобщение, закрепление и углубление знаний по дисциплинам, свя-
занным с проектированием средств ВТ;
􀂈 формирование навыков разработки и оформления текстовой и гра-
фической технической документации;
􀂈 развитие навыков устных сообщений по содержанию работы.
Содержанием курсовой работы является разработка арифметико-логи-
ческого устройства (АЛУ), реализующего заданный набор операций с уче-
том ограничений на код выполнения операций и способ построения управ-
ляющего автомата.
11.2. Задания
Задания на курсовую работу включают в себя некоторый набор исходных
данных и ограничений для проектирования АЛУ. Все варианты задания све-
дены в табл. 11.1. Строка таблицы представляет один вариант задания, при-
чем номер варианта определяется номером группы (1—2) и порядковым но-
мером студента по списку группы (1—25).
Разрабатываемое АЛУ должно выполнять одну арифметическую и одну по-
разрядную бинарную логическую операцию, причем на способ выполнения
арифметической операции заданием накладываются некоторые ограничения.
Варианты операций обозначаются в табл. 11.1 следующим образом:
􀂈 ± — алгебраическое сложение/вычитание;
􀂈 × — умножение обыкновенное;
Часть III. Лабораторный 324 практикум и курсовое проектирование
Таблица 11.1. Варианты курсовых заданий
№ Опера-
ции
Код
ВО Флаги Тип
УА № Операции Код
ВО Флаги Тип
УА
1-1 ± , & ПК OV, Z 2 2-1 ×2 , ⊕ ПК OV, P 4
1-2 × , ∨ ПК OV, P 3 2-2 × , ⊕ ПК OV, C 1
1-3 ÷1 , ⊕ ПК OV, Z 4 2-3 ± , & ОК OV, Z 5
1-4 ×2 , ≡ ПК OV, C 5 2-4 ÷2 , ≡ ПК OV, P 6
1-5 ÷2 , & ПК OV, Z 6 2-5 ± , & ПК OV, Z 4
1-6 × , ∨ ПК OV, P 1 2-6 ÷1 , ∨ ПК OV, P 3
1-7 ± , ≡ ОК OV, C 2 2-7 ± , & ДК OV, Z 2
1-8 ×2 , ⊕ ПК OV, P 3 2-8 ×2 , ≡ ПК OV, P 5
1-9 ÷1 , & ПК OV, Z 4 2-9 ÷2 , & ПК OV, Z 4
1-10 ×2 , ∨ ПК OV, C 5 2-10 ×2 , ∨ ПК OV, P 6
1-11 ± , ≡ ДК OV, Z 6 2-11 ± , & ОК OV, Z 1
1-12 × , ∨ ПК OV, P 5 2-12 ÷1 , ∨ ПК OV, Z 2
1-13 ± , ⊕ ОК OV, C 4 2-13 ± , & ДК OV, C 3
1-14 ÷2 , ∨ ПК OV, P 6 2-14 ×2 , ⊕ ПК OV, Z 4
1-15 ± , & ДК OV, Z 3 2-15 ÷1 , ≡ ПК OV, P 3
1-16 × , ∨ ПК OV, C 2 2-16 ÷2 , ∨ ПК OV, Z 2
1-17 ± , ≡ ПК OV, Z 1 2-17 ± , & ОК OV, C 1
1-18 ×2 , ⊕ ПК OV, P 1 2-18 × , ⊕ ПК OV, C 6
1-19 ± , & ОК OV, C 2 2-19 ÷1 , & ПК OV, Z 5
1-20 ÷2 , ∨ ПК OV, P 3 2-20 ×2 , ∨ ПК OV, P 1
1-21 ÷1 , & ПК OV, Z 4 2-21 ± , ≡ ОК OV, Z 2
1-22 × , ≡ ПК OV, C 5 2-22 × , ⊕ ПК OV, Z 6
1-23 ± , & ДК OV, Z 6 2-23 ± , & ДК OV, P 5
1-24 ×2 , ∨ ПК OV, P 3 2-24 ×2 , ∨ ПК OV, C 4
1-25 ×1 , ≡ ПК OV, C 5 2-25 ÷2 , ≡ ПК OV, Z 3
Глава 11. Курсовая работа 325
􀂈 ×2 — умножение ускоренное (с анализом двух разрядов множителя);
􀂈 ÷1 — деление с восстановлением остатка;
􀂈 ÷2 — деление без восстановления остатка;
􀂈 ∨ — дизъюнкция;
􀂈 & — конъюнкция;
􀂈 ⊕ — неравнозначность;
􀂈 ≡ — эквивалентность.
Для всех вариантов заданий исходные данные (операнды) поступают в фор-
мате 16-разрядных двоичных чисел с фиксированной запятой, представлен-
ных в прямом коде [a0a1...a15 ]d , [ ]d b0b1...b15 , причем нулевой разряд является
знаковым и запятая фиксирована после знакового разряда. Таким образом,
в арифметических операциях участвуют правильные дроби со своими знака-
ми (в логических операциях, естественно, положение запятой и знак игнори-
руются, операции выполняются над 16-разрядными двоичными векторами).
Соответственно, результат операции должен быть представлен в той же фор-
ме: [ ]d c0c1...c15 .
В задании вводится ограничение на код выполнения операции (столбец
Код ВО в табл. 11.1). Если код ВО отличается от прямого — обратный (ОК)
или дополнительный (ДК), то при выполнении арифметической операции
следует перевести операнды в заданный код, выполнить в нем операцию,
а результат вновь перевести в прямой код. Логические операции, естествен-
но, выполняются без всякого преобразования.
Результатом выполнения операции в АЛУ должно быть не только значение
суммы (произведения, конъюнкции и др.), но и признаки результата (флаги).
Каждый вариант задания предполагает формирования двух различных фла-
гов (заданных в столбце Флаги табл. 11.1) из приведенного далее множества:
􀂈 Z — признак нулевого результата;
􀂈 Р — признак четности числа единиц в результате;
􀂈 С — признак переноса (заема) из старшего разряда;
􀂈 OV — признак арифметического переполнения.
В столбце Тип УА задан номер типа управляющего автомата, который
необходимо использовать при проектировании заданного АЛУ. Список типов
УА приведен далее:
􀂈 1 — "жесткая логика", автомат Мура;
􀂈 2 — "жесткая логика", автомат Мили;
Часть III. Лабораторный 326 практикум и курсовое проектирование
􀂈 3 — программируемая логика, единый формат микрокоманды, прину-
дительная адресация;
􀂈 4 — программируемая логика, единый формат микрокоманды, естест-
венная адресация;
􀂈 5 — программируемая логика, различные форматы для операционных
микрокоманд и микрокоманд перехода, естественная адресация;
􀂈 6 — программируемая логика, различные форматы для операционных
микрокоманд и микрокоманд перехода, принудительная адресация.
В задании не определены ограничения на базис логических, операционных
элементов и элементов памяти. Поэтому при разработке структурных и функ-
циональных схем можно использовать любые стандартные логические и опе-
рационные элементы.
11.3. Этапы выполнения работы
В главе 4 подробно рассматривается процесс проектирования цифрового уст-
ройства. При проектировании его удобно представить в виде композиции
операционного и управляющего автоматов (см. разд. 4.2). Тогда процесс про-
ектирования устройства сводится к процедурам последовательного проекти-
рования операционного и управляющего автоматов. Здесь можно выделить
следующие этапы:
1. Разработка алгоритмов выполняемых операций. На этом этапе следует
определить список входных, выходных и внутренних переменных и вы-
брать коды выполняемых операций. Поскольку все задания предполагают
реализацию одной/двух арифметических и одной логической операций,
целесообразно представить все алгоритмы в форме объединенной ГСА.
2. Разработка структуры операционного автомата — определение состава
элементов и связей между ними. Разработка структуры нестандартных
элементов. Результатом работы на этом этапе должна стать структурная
(функциональная) схема операционного автомата, а также функциональ-
ные схемы всех использованных в ОА нестандартных элементов.
3. Определение списка микроопераций и логических условий. Необходимо
сопоставить каждому оператору из ГСА микрокоманду или группу микро-
команд, обеспечивающих реализацию этого оператора на разработанной
ранее структуре. На этом этапе возможно расширение набора элементов
и/или связей структуры, если без такого расширения не удается реализо-
вать все операторы ГСА. Кроме того, необходимо определить, где будут
формироваться значения логических переменных, которые анализируются
Глава 11. Курсовая работа 327
в логических вершинах ГСА, и при необходимости предусмотреть специ-
альные элементы структуры для формирования этих значений. Результат
работы на этом этапе — списки микроопераций и логических условий ОА.
4. Разработка микропрограммы выполнения заданных операций на выбран-
ной структуре ОА. В простейшем случае можно сохранить топологию
графа алгоритма и просто заменить операторы во всех операторных вер-
шинах на соответствующие микрооперации, а условия, которые анализи-
руются в условных вершинах — на соответствующие логические условия
из списка, полученного на предыдущем этапе. Однако при переходе от
ГСА к микропрограмме следует всегда стремиться к уменьшению числа
(операторных) вершин, что, в свою очередь, приведет к упрощению схемы
управляющего автомата. Достигнуть этого можно, например, совмещени-
ем двух или более операторных вершин ГСА в одну вершину микропро-
граммы, если смысл реализуемого алгоритма и разработанная ранее
структура операционного автомата позволяют выполнить эти действия
одновременно. Разработанная на этом этапе микропрограмма является ис-
ходной для проектирования управляющего автомата.
На этом заканчивается процесс разработки операционного автомата.
Этапы разработки управляющего автомата различны в зависимости от его
типа. Для разработки микропрограммного автомата с "жесткой" логикой
следует:
1. Осуществить разметку микропрограммы. Эта процедура устанавливает
соответствие между вершинами микропрограммы и состояниями автома-
та. В разд. 4.4.1 описано, как осуществлять разметку микропрограммы для
проектирования автомата Мура и автомата Мили.
2. Построить граф автомата. Граф автомата строят по размеченной микро-
программе, причем вершины графа соответствуют состояниям автомата,
а ребра — переходам, на этом этапе можно не показывать на графе функ-
цию переходов.
3. Выбрать тип элемента памяти, закодировать состояния автомата.
4. Составить автоматную таблицу переходов. Пример построения такой таб-
лицы для случая использования в качестве элементов памяти D-триггеров
приведен в разд. 4.4.1. Аналогичный формат имеет таблица при использо-
вании Т-триггеров. Если в качестве элемента памяти автомата выбран RS-
триггер, в каждом разряде необходимо сформировать две функции возбу-
ждения — для R- и S-входов.
5. Определить функции возбуждения для переключения элементов памяти.
Автоматная таблица может рассматриваться как таблица истинности,
задающая функции возбуждения для входов элементов памяти автомата.
Часть III. Лабораторный 328 практикум и курсовое проектирование
Все функции возбуждения в общем случае зависят от значений элементов
памяти Tj и значений логических условий X j . При необходимости мож-
но для каждой из функций построить карту Карно и записать ее мини-
мальное выражение. Иногда проще бывает предварительно дешифриро-
вать состояния автомата и записать функции возбуждения в зависимости
от текущего состояния автомата и слова логических условий.
6. Определить функции выходов, формирующие значения микроопераций. Для
автомата Мура функция выходов в каждом такте дискретного времени зави-
сит только от текущего состояния автомата и значение выхода определяется
содержимым операторной вершины микропрограммы, соответствующей это-
му состоянию автомата. В автомате Мили выходное слово соответствует со-
держимому той операторной вершины микропрограммы, через которую осу-
ществляется переход из текущего состояния автомата в следующее. Поэтому
функция выходов автомата Мили, как и его функция переходов, зависит от
текущего состояния автомата и слова логических условий.
7. Построить функциональную схему УА. Получив выражения для функций
возбуждения и выходов, можно построить функциональную схему управ-
ляющего автомата с использованием выбранных элементов памяти и стан-
дартного базиса логических и операционных элементов.
Для разработки микропрограммного автомата с программируемой логикой
следует:
1. Разбить множество микроопераций на подмножества попарно-несовмести-
мых микроопераций(этот пункт не выполняется, если выбран "вертикаль-
ный" или "горизонтальный" способ кодирования поля микроопераций).
2. Определить формат микрокоманды (микрокоманд).
3. Разработать функциональную схему управляющего автомата.
4. Заполнить таблицу программирования ПЗУ микрокоманд.
Проектирование управляющего автомата с программируемой логикой с раз-
личными способами адресации микрокоманд и кодирования микроопераций
подробно описаны в разд. 4.4.2.
11.4. Содержание пояснительной записки
Пояснительная записка к курсовой работе должна включать следующую ин-
формацию (для вариантов с управляющими автоматами с "жесткой" логикой):
1. Титульный лист.
2. Задание на проектирование АЛУ.
Глава 11. Курсовая работа 329
3. Форматы входных, выходных и внутренних переменных, с которыми
оперирует АЛУ.
4. ГСА выполняемых операций и объединенную ГСА.
5. Структурную схему операционного автомата АЛУ.
6. Функциональные схемы "нестандартных" элементов ОА. При необходи-
мости привести процедуры синтеза операционных элементов (например,
карты Карно для минимизации булевых функций).
7. Список микроопераций, реализуемых в ОА.
8. Список логических условий, формируемых в ОА.
9. Микропрограмму выполняемых в АЛУ операций в терминах микроопе-
раций и логических условий с разметкой состояний для проектирования
управляющего автомата.
10. Граф автомата.
11. Таблицу кодирования внутренних состояний автомата.
12. Описание выбранного элемента памяти (триггера) и его таблица функ-
ционирования.
13. Автоматную таблицу переходов.
14. Выражения для функций возбуждения элементов памяти (при необходи-
мости — процедуру минимизации).
15. Выражения для функций выходов управляющего автомата.
16. Функциональную схему управляющего автомата.
17. Заключение.
18. Библиографический список.
Для вариантов с управляющими автоматами с программируемой логикой
вместо информации, приведенной в пп. 9—16, необходимо включить:
1. Микропрограмму выполняемых в АЛУ операций в терминах микроопера-
ций и логических условий.
2. Формат или форматы микрокоманд с указанием размеров и назначения
нолей.
3. Разбиение множества микроопераций ОА на подмножества несовмести-
мых микроопераций.
4. Функциональную схему управляющего автомата.
5. Таблицу программирования ПЗУ микрокоманд.
Приложения
Приложение 1. Список сокращений, используемых
в тексте
Приложение 2. Описание компакт-диска
Приложение 1
Список сокращений,
используемых в тексте
CISC — Complex Instruction Set Computer, компьютер с полным набором
команд
CPL — текущий уровень привилегий
DPL — уровень привилегий дескриптора
EEPROM — энергонезависимая память перепрограммируемая, с электриче-
ским стиранием
GDT — глобальная дескрипторная таблица
IDT — дескрипторная таблица прерываний
IEEE — Institute of Electrical and Electronics Engineers, Институт инженеров
по электротехнике и электронике
LDT — локальная дескрипторная таблица
RISC — Reduced Instruction Set Computer, компьютер с сокращенным набо-
ром команд
RPL — запрашиваемый уровень привилегий
TLB — буфер ассоциативной трансляции
TSS — сегмент состояния задачи
АВМ — аналоговая вычислительная машина
АЛС — арифметико-логическая секция
АЛУ — арифметико-логическое устройство
БИС — большая интегральная схема
ВЗУ — внешнее запоминающее устройство
ВУ — внешнее устройство
334 Приложения
ГСА — граф-схема алгоритма
ЗУ — запоминающее устройство
ИС — интегральная схема
ИТ — интегральная технология
КЦ — командный цикл
МП — микропроцессор
МПС — микропроцессорная система
МЦ — машинный цикл
ОА — операционный автомат
ОЗУ — оперативное запоминающее устройство
ОМЭВМ — однокристальная микроЭВМ
ПВВ — подсистема ввода/вывода
ПДП — прямой доступ в память
ПЗУ — постоянное запоминающее устройство
РОН — регистр общего назначения
СБИС — сверхбольшая интегральная схема
СИС — интегральная схема средней степени интеграции
СОЗУ — сверхоперативное ОЗУ
ТТЛ — транзисторно-транзисторная логика
УА — управляющий автомат
УАЖЛ — управляющий автомат с "жесткой" логикой
УАПЛ — управляющий автомат с программируемой логикой
УВв — устройство ввода
УВВ — устройство ввода/вывода
УВыв — устройство вывода
УОД — устройство обработки данных
УСМ — устройство связи с магистралью
УУС — устройство управления и синхронизации
ЦУУ — центральное устройство управления
ЭЦВМ — электронные цифровые вычислительные машины
Приложение 2
Описание компакт-диска
На компакт-диске размещены три папки с программными моделями и тесто-
выми примерами:
􀂈 АЛУ-1 — программная модель арифметико-логического устройства АЛУ-1,
описанная в разд. 8.1.
􀂈 АЛУ-R — программная модель арифметико-логического устройства АЛУ-R,
описанная в разд. 8.2.
􀂈 Модель ЭВМ — программная модель учебной ЭВМ, подробно описанной
в разд. 9.5.
Каждая из программных моделей представлена в своем каталоге одним exe-
файлом, не требует инсталляции, может размещаться в любом каталоге на
жестком диске или флэш-накопителе и запускается обычным образом.
Примеры микропрограмм и программ, размещенные на компакт-диске, пред-
лагаются исключительно для первичного тестирования моделей. Автор наме-
ренно не приводит описания этих программ, чтобы оставить читателю воз-
можность самостоятельно программировать подобнее задачи. Однако при
желании читатель может проанализировать файлы с расширением txt (мик-
роассемблер АЛУ-1) в папке АЛУ-1 и файлы с расширением asm (ассемблер
учебной ЭВМ) в папке Модель ЭВМ.
Кратко опишем способы тестирования программных моделей с помощью
прилагаемых микропрограмм (программ).
Папка АЛУ-1. Для того чтобы познакомиться с моделью АЛУ-1 и убедиться
в ее работоспособности, можно:
1. Запустить файл alu-1.exe.
2. Подключить управляющий автомат (меню Подключить | Управляющий
автомат).
336 Приложения
3. Загрузить микропрограмму алгебраического сложения прямых кодов дво-
ичных чисел add-d.kom (меню Файл | Загрузить микропрограмму в окне
Управляющий автомат).
4. Установить в окне Управляющий автомат флажок Синхронизировать
с УА и перейти в основное окно Арифметико-логическое устройство.
5. Ввести в регистры Ax и Bx значения слагаемых в прямых кодах. Можно
воспользоваться сервисом Десятичный ввод.
6. На панели управления основного окна Арифметико-логическое устрой-
ство нажать последовательно кнопки Сброс и Авто. Результат алгебраи-
ческого сложения размещается в регистре С, а признак переполнения —
в триггере DL.
В данном случае мы воспользовались готовым двоичным кодом микропро-
граммы, сохраненным в файле add-d.kom. Для проверки компилятора можно
воспользоваться текстом той же микропрограммы, написанным на языке
микроассемблера. Для этого:
1. Повторяем пункты 1 и 2 предыдущих действий.
2. Вызывая пункт меню Компилятор в окне Управляющий автомат, от-
крываем окно Компиляция кода.
3. Загружаем в окно Компиляция кода текст микропрограммы из файла
add-d.txt.
4. В окне Компиляция кода устанавливаем флажок Очистить таблицу пе-
ред заполнением и нажимаем кнопку Компиляция.
5. Выполняем пункты 4—6 предыдущих действий.
Аналогично можно выполнить операцию беззнакового умножения байтов,
микропрограммы которой размещены в файлах mul.kom (двоичный код) и
mul.txt (текст). 8-разрядные сомножители размещаются в регистрах Ax и Bx ,
результат — 16-разрядное произведение — в регистрах C (старший байт) и D
(младший байт).
Папка АЛУ-R содержит файл Программная модель АЛУ-R.exe и три файла
микропрограмм, в которых в текстовом формате записаны коды микропро-
грамм алгебраического сложения (add-d.txt и add-с.txt) и беззнакового умно-
жения (mul.txt). Именно в таком формате микропрограмма может быть за-
гружена в память управляющего автомата модели.
Обе микропрограммы сложения внешне работают одинаково — в регистрах
R0 и R1 должны располагаться слагаемые в прямых кодах, сумма в прямом
Приложение 2. Описание компакт-диска 337
коде помещается в регистр R2, в регистре состояния флажок OV устанавли-
вается в 1 при переполнении разрядной сетки. Микропрограмма в файле
add-d.txt выполняет сложение в прямом коде (см., например, ГСА на рис. 3.3),
а в add-c.txt осуществляется перевод исходных операндов в дополнительный
код, сложение в дополнительном коде и обратный перевод результата в пря-
мой код. Читатель при желании может сравнить методы получения суммы
и обнаружения переполнения в прямом и дополнительном коде.
Микропрограмма mul.txt реализует умножение двух беззнаковых байтов (со-
держимое регистров R0 и R1). 16-разрядное произведение размещается в ре-
гистрах R2 (старший байт) и R3 (младший байт).
Для выполнения микропрограммы необходимо:
1. Запустить файл Программная модель АЛУ-R.exe.
2. Перейти на вкладку УА.
3. В Панели управления окна УА (Управляющий автомат) нажать кнопку
Загрузить и выбрать один из файлов микропрограмм. Там же установить
флажок Подключить к ОА.
4. Вернуться на вкладку ОА АЛУ. Загрузить в регистры R0 и R1 исходные
операнды (щелчок мыши по цифре разряда регистра инвертирует ее).
Можно воспользоваться сервисом Десятичный ввод (установить соот-
ветствующий флажок в Панели управления). При выполнении операции
сложения старший разряд байта интерпретируется как знак числа, поэтому
при использовании десятичного ввода следует дополнительно установить
флажок Со знаком.
5. Нажать на панели управления окна ОА АЛУ кнопку Авто. Результат опера-
ции сложения наблюдать в регистре R2, а умножения — в регистрах R2.R3.
Папка Модель ЭВМ содержит, помимо собственно программной модели
учебной ЭВМ CompModel.exe, два текстовых файла программ на языке ас-
семблера учебной ЭВМ, предназначенных для тестирования ее внешних уст-
ройств. Эти программы можно рассматривать как небольшие фрагменты за-
даний лабораторной работы № 8 (см. разд. 10.8).
Программа Test-KD.asm позволяет протестировать работу моделей клавиату-
ры и символьного дисплея. Для ее запуска необходимо:
1. Запустить программу модели ЭВМ CompModel.exe.
2. Загрузить в окно Текст программы файл Test-KD.asm и выполнить его
компиляцию (кнопка Компилировать или пункт меню Работа | Компи-
лировать).
338 Приложения
3. Открыть окно Подключаемые устройства (пункт меню Внешние уст-
ройства | Менеджер ВУ... или кнопка МВУ).
4. Подключить внешние устройства Контроллер клавиатуры и Контрол-
лер дисплея, не меняя предлагаемых по умолчанию параметров. Закрыть
окно Подключаемые устройства.
5. Запустить программу, нажав последовательно кнопки R (сброс) в окне
обозревателя Процессор и Пуск в основном окне модели.
6. Щелкнуть мышью по окну Контроллер клавиатуры, сделав его актив-
ным. Теперь после каждого нажатия на клавиши ПЭВМ соответствующий
символ вводится в буфер клавиатуры и передается на экран символьного
дисплея. После ввода 50 символов буфер клавиатуры заполняется полно-
стью, устанавливается флаг ошибки Err в регистре SR контроллера кла-
виатуры и дальнейший ввод символов блокируется.
Программа Test-TG.asm позволяет протестировать работу тоногенератора.
Программа реализует бесконечный цикл и выводит на динамик ПЭВМ по-
стоянно повышающийся тон, начиная с частоты 50 Гц с шагом 50 Гц. Для ее
запуска необходимо выполнить пункты 1—5 перечисленных ранее действий,
причем в пункте 2 загружается и компилируется файл Test-TG.asm, а в пунк-
те 4 подключается только Тоногенератор.
Литература
1. Акушский И. Я., Юдицкий Д. И. Машинная арифметика в остаточных
классах. — М.: Сов. радио, 1968.
2. Баранов С. И. Синтез микропрограммных автоматов. — Л.: Энергия,
1974.
3. Григорьев В. Л. Микропроцессор i486. Архитектура и программирование.
В четырех книгах. — М.: ГРАНАЛ, 1993.
4. Жмакин А. П., Титов В. С. Однокристальные микроЭВМ в системах
управления: Учебное пособие. — Курск: Курск. гос. тех. ун-т, 2002.
5. Закревский А. Д. Алгоритмы синтеза дискретных автоматов. — М.: Нау-
ка, 1971.
6. Каган Б. М. ЭВМ и системы. — М.: Энергоатомиздат, 1985.
7. Майоров С. А., Новиков Г. А. Принципы организации ЦВМ. — Л.: Ма-
шиностроение, 1974.
8. Савельев А. Я. Прикладная теория цифровых автоматов. — М.: Высшая
школа, 1987.
9. Соловьев Г. Н. Арифметические устройства ЦВМ. — М.: Энергия, 1978.
10. Стариченко Б. Е. Теоретические основы информатики. — М.: Горячая
линия — Телеком, 2003.
11. Таненбаум Э. Архитектура компьютера. 4-е изд. — СПб.: Питер, 2003.
12. Угрюмов Е. П. Цифровая схемотехника. 2-е изд. — СПб.: БХВ-
Петербург, 2005.
13. Хамахер К., Вранешич З., Заки С. Организация ЭВМ. 5-е изд. — СПб.:
Питер, 2003.
14. Хвощ С. Т. и др. Микропроцессоры и микроЭВМ в системах автоматиче-
ского управления: Справочник. — Л.: Машиностроение, 1987.
15. Юров В. И. Assembler. — СПб.: Питер, 2003.
Ïðåäìåòíûé óêàçàòåëü
A, C
Abort 190
CISC-архитектура 209
Code Privilege Level (CPL) 178
Current Privilege Level (CPL) 178
D, E, F
Descriptor Privilege Level (DPL) 177
Error code 195
Fault 189
R
Requested Privilege Level (RPL) 178
RISC-архитектур 209
T, W
Task State Segment (TSS) 184
Trap 190
Watch-Dog Timer (WDT) 221
А, Б
Авария 190
Автомат:
операционный (ОА) 80, 81
управляющий
(микропрограммный) 87
управляющий (УА) 80, 89
Мили 90
Мура 90
с жесткой логикой 89
с программируемой логикой 97
Адрес:
виртуальный 127
линейный 173
логический 172
физический 175
эффективный 172
Адресация 20
микрокоманд:
естественная 101
принудительная 100
Адресное пространство, единое 150
Алгоритм:
"Карабкающаяся страница"
(КС) 129
"Рабочий комплект" (РК) 130
деления без восстановления
остатка 83
замещения 128
строк 281
Минховского — Шора 128
НДИ 129
Альтернативное именование 184
Аналитическая машина
Ч. Беббеджа 6
Арифметико-логическое устройство
(АЛУ) 13
Архитектура:
EPIC 215
VLIW 215
гарвардская 220
Ассоциативное запоминающее
устройство (АЗУ) 119
Буфер ассоциативной
трансляции 176
342 Ïðåäìåòíûé óêàçàòåëü
В
Вектор:
знаковый 38
прерывания 163
Верхушка стека 307
Г
Гарвардская архитектура ЭВМ 13
Граф-схема алгоритма (ГСА) 39, 81
Д
Двоичный код десятичной цифры 68
Деление:
без восстановления остатка 62
модулей двоичных чисел 60
с восстановлением остатка 62
Дескриптор 169
Дескрипторная таблица 171
глобальная (GTD) 171
локальная (LTD) 171
прерываний (IDT) 171, 193
Диспетчер памяти 150
З
Загрузка по предположению 217
Задача 183
Запоминающее устройство (ЗУ) 13
Запрашиваемый уровень
привилегий 178
Защита:
доступа к данным 179
памяти:
на уровне сегментов 177
на уровне страниц 181
сегментов кода 180
Защищенный режим (protect mode,
P-режим) 168
И
Интегральная технология (ИТ) 132
Интерфейс Unibus 148
Исключение 189
К
Каталог раздела 174
Код:
"8421" 68
ошибки 195
с избытком три 69
числа:
дополнительный 41, 46
обратный 41
прямой 38
Команда 12, 16
двухадресная 19
одноадресная 19
привилегированная 178
трехадресная 19
Командный цикл 17
Конвейер 208
Контекст задачи 183
Контрольная точка 200
аппаратная по данным 205
аппаратная по командам 204
Кэш-память 121
ассоциативная по множеству 123
с обратной записью 125
с прямым отображением 121
со сквозной записью 125
Л
Ловушка 190, 201
Логическое условие 79
М
Межразрядная связь 73
Методы ускорения умножения 56
Микрокоманда 87
Микроконтроллер 219
MC68332 222
Микрооперации 79
несовместимые 106
совместимые 106
способ кодирования:
вертикальный 105
горизонтальный 104
смешанный 105
Микропрограмма 79, 87
Ïðåäìåòíûé óêàçàòåëü 343
Микропроцессор (МП):
i8086 138
адресное пространство 145
машина пользователя 145
система команд 147
многокристальный 135
однокристальный 135
поколения 133
Микропроцессорная система
(МПС) 137
МикроЭВМ, однокристальная 136, 219
от Motorola 221
Мультизадачность 183
Н
Нарушение 189
Нормализация результата 66
О
Обработчик прерывания 159
Операционное устройство 79
Операция 21
алгебраическая 39
Организация памяти 116
сегментная 168
страничная 173
Особый случай 189
двойное нарушение 198
контроль выравнивания 200
контрольная точка 197
нарушение:
границы массива 197
общей защиты 199
стека 199
недействительный код операции 197
недействительный сегмент TSS 198
немаскируемое прерывание NMI 197
неприсутствие сегмента 199
отладка 196
ошибка:
деления 196
операции плавающей с точкой 200
переполнение 197
страничное нарушение 199
устройство недоступно 197
Отладка 200
П
Память:
ассоциативная страничных
таблиц 176
виртуальная 127
сегментная организация 130
страничная организация 127
магазинная 21
оперативная 150
сверхоперативная 118
физическая 127
Параллелизм, динамический 212
Перевод из одной системы счисления
в другую 34
дробных чисел 31
целых чисел 27
Переполнение:
отрицательное 66
положительное 65
Подсистема ввода/вывода (ПВВ) 151
Подсистема прерываний 158
Поколения ЭВМ 8
Предикация 216
Представление числа:
беззнаковое 38
с фиксированной запятой 38
со знаком 38
Прерывание 158, 189
программное 189
Привилегия для сегмента 177
Принцип:
микропрограммного управления 79
мультиплексирования сигналов 138
программного управления 12
структурного описания 13
Программа 12, 16
Программный счетчик 17
Процессор:
8086 168
IA-64 215
Pentium 211
Pentium Pro 212
PowerPC 214
суперскалярный 212
Процессорный модуль 138, 142
Прямой доступ в память (ПДП) 165
344 Ïðåäìåòíûé óêàçàòåëü
Р
Разностная машина Ч. Беббеджа 6
Регистр команд 17
Регистр общего назначения (РОН) 119
Релейная машина Холлерита 6
С
Сверхоперативное ОЗУ (СОЗУ) 118
с ассоциативным доступом 119
с прямым доступом 119
Сегмент 169
подчиненный 180
состояния задачи 184
Система 13
команд процессора 18
Система оснований 74
Система счисления 24
аддитивная 25
в остаточных классах (СОК) 74
восьмеричная 34
двоичная 26, 34
непозиционная 24
основание 25
позиционная 25
римская 24
троичная 37
унарная 24
шестнадцатеричная 34
экономичность 36
Сложение, алгебраическое
в дополнительном коде 48
в обратном коде 42
Страничная таблица 127
Стек 21, 307
Сторожевой таймер 221
Страница, виртуальная 127
Страничный сбой 128
Структура системы 14
Счетная машина Паскаля 5
Счетчик команд 17
Т
Табулятор 6
Текущий уровень привилегий 178
Теория вычетов 74
У
Умножение чисел:
в дополнительном коде 56
методы ускорения 56
Уровень привилегий дескриптора 177
Устройство ввода (УВв) 13, 152
Устройство вывода (УВыв) 13, 152
Ф, Ц
Формат команды 18
Центральное устройство управления
(ЦУУ) 13
Цикл:
командный (КЦ) 140, 160
машинный (МЦ) 141, 160
асинхронный 142
синхронный 142
Ч
Число 24
Число с плавающей запятой 62
Ш
Шлюз:
вызова 181, 193
задачи 193
ловушки 193
прерывания 193
Э
Экономичность представления
числа 36
Элемент 14